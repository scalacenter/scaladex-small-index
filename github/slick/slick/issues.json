{
  "data":{
    "repository":{
      "issues":{
        "nodes":[
          {
            "number":906,
            "title":"Codegen : output several files instead of one big Tables.scala",
            "bodyText":"I think it would be great if there was a way to output the generated classes into several files (one per class) instead of having one big Tables.scala file.",
            "url":"https://github.com/slick/slick/issues/906"
          },
          {
            "number":1054,
            "title":"Tuple-based Tables.scala file generated by Codegen does not compile ",
            "bodyText":"I'm playing with slick 2 and codegen, using MySql for the database. I started with the Coffee / Suppliers example from the hello slick activator template.\nI'm trying to use codegen to create a new Tables.scala file from the Coffee and Suppliers database tables, which will allow the existing client code to work e.g.\ndb.withSession { implicit session =>\n  ...\n  suppliers += (101, \"Acme, Inc.\", \"99 Market Street\", \"Groundsville\", \"CA\", \"95199\")\n  suppliers += ( 49, \"Superior Coffee\", \"1 Party Place\", \"Mendocino\", \"CA\", \"95460\")\n  suppliers += (150, \"The High Ground\", \"100 Coffee Lane\", \"Meadows\", \"CA\", \"93966\")\n  ...\n}\n\nI've been posting to the slick google group for help. I've had to use a custom generator to use tuples for the rows instead of case classes:\nimport scala.slick.driver.MySQLDriver\nimport scala.slick.driver.MySQLDriver.simple._\nimport scala.slick.codegen.SourceCodeGenerator\nimport scala.slick.model.Model\n\nobject SlickAutoGen {\n  def main(args: Array[String]) {\n\n    val db = Database.forConfig(\"db\")\n\n    val model = db.withSession { implicit session =>\n        MySQLDriver.profile.createModel()\n    }\n\n    case class SourceGen(model: Model) extends SourceCodeGenerator(model) {\n      override def Table = new Table(_) {\n        override lazy val EntityType = new EntityType {\n          override val classEnabled: Boolean = false\n        }\n      }\n    }\n\n    SourceGen(model).writeToFile(\n      \"scala.slick.driver.MySQLDriver\", \"src/main/scala\", \"org.ludwiggj.finance.database\", \"Tables\", \"Tables.scala\")\n  }\n}\n\nThis generates the following code for Tables.scala (relevant parts shown only):\ntrait Tables {\n  ...\n  /** Row type of table Coffees */\n  type CoffeesRow = (String, Int, Double, Int, Int)\n  /** Constructor for CoffeesRow providing default values if available in the database schema. */\n  def CoffeesRow(name: String, supId: Int, price: Double, sales: Int, total: Int): CoffeesRow = {\n    (name, supId, price, sales, total)\n  }\n  /** GetResult implicit for fetching CoffeesRow objects using plain SQL queries */\n  implicit def GetResultCoffeesRow(implicit e0: GR[String], e1: GR[Int], e2: GR[Double]): GR[CoffeesRow] = GR{\n    prs => import prs._\n    CoffeesRow.tupled((<<[String], <<[Int], <<[Double], <<[Int], <<[Int]))\n  }\n  /** Table description of table COFFEES. Objects of this class serve as prototypes for rows in queries. */\n  class Coffees(_tableTag: Tag) extends Table[CoffeesRow](_tableTag, \"COFFEES\") {\n    def * = (name, supId, price, sales, total) <> (CoffeesRow.tupled, CoffeesRow.unapply)\n    /** Maps whole row to an option. Useful for outer joins. */\n    def ? = (name.?, supId.?, price.?, sales.?, total.?).shaped.<>({r=>import r._; _1.map(_=>\n        CoffeesRow.tupled((_1.get, _2.get, _3.get, _4.get, _5.get)))}, (_:Any) =>\n        throw new Exception(\"Inserting into ? projection not supported.\"))   \n    ...\n  }\n  ...\n}\n\nThis results in the following compilation errors:\nError:(28, 5) missing arguments for method CoffeesRow in trait Tables;\nfollow this method with `_' if you want to treat it as a partially applied function\nCoffeesRow.tupled((<<[String], <<[Int], <<[Double], <<[Int], <<[Int]))\n\nError:(32, 52) missing arguments for method CoffeesRow in trait Tables;\nfollow this method with `_' if you want to treat it as a partially applied function\ndef * = (name, supId, price, sales, total) <> (CoffeesRow.tupled, CoffeesRow.unapply)\n\nError:(32, 71) missing arguments for method CoffeesRow in trait Tables;\nfollow this method with `_' if you want to treat it as a partially applied function\ndef * = (name, supId, price, sales, total) <> (CoffeesRow.tupled, CoffeesRow.unapply)\n\nError:(34, 95) missing arguments for method CoffeesRow in trait Tables;\nfollow this method with `_' if you want to treat it as a partially applied function\ndef ? = (name.?, supId.?, price.?, sales.?, total.?).shaped.<>({r=>import r._; _1.map(_=> CoffeesRow.tupled((_1.get, _2.get, _3.get, _4.get, _5.get)))}, (_:Any) =>  throw new Exception(\"Inserting into ? projection not supported.\"))\n\nI've been advised on the forum to raise this as a bug against CodeGenerator, and that I could disable the PlainSqlMapper as follows:\ncase class SourceGen(model: m.Model) extends SourceCodeGenerator(model) {\n    override def Table = new Table(_) {\n        override lazy val EntityType = new EntityType {\n            override val classEnabled: Boolean = false\n        }\n        override lazy val PlainSqlMapper = new PlainSqlMapper{\n            override val enabled = false\n        }\n    }\n}\n\nDisabling the PlainSqlMapper as above removes the first compilation error, but not those connected with the incorrect definitions of the * and ? methods, so it still won't compile.\nI know I can fix this code by hand, but obviously codegen should produce the correctly compiling code!\n(As an aside, I also wonder why the default behaviour of the code generator is to create Tables.scala with case classes; will this change in future to generate the tuples only version, so that the existing way of populating the database works with the schema classes generated by codegen?)",
            "url":"https://github.com/slick/slick/issues/1054"
          },
          {
            "number":1126,
            "title":"Possible bug in Slick3 Custom Code Generator Sample Code",
            "bodyText":"I am migrating from slick 2 to Slick 3. As part of that, I am trying to use the Custom Code Generator given this link (http://slick.typesafe.com/doc/3.0.0-RC3/code-generation.html). However, the generated code was having the same name for the Table and TableQuery, which was giving compilation errors.\nThe issue was fixed by overriding the rawName in the TableValue\noverride def TableValue = new TableValue {\noverride def rawName = super.rawName.uncapitalize\n}",
            "url":"https://github.com/slick/slick/issues/1126"
          },
          {
            "number":1317,
            "title":"Unable to view SQL statements from insert queries",
            "bodyText":"Unless I am mistaken, it appears that its impossible to view the generated SQL from an insert statement, either directly or when using something like DBIO.seq(...). If you are using the DBIO.seq then the .result or .statement methods don't even exist. If you are using the insert query directly (i.e. SomeTables ++= Seq(...)), the .statements method prints ? in place of the actual values.\nThis appears to be a really big oversight. The first initial step in actually debugging slick is seeing what SQL is generated. In our case, we are trying to create a complex database migration, and we need to see the generated seed data (which is the result of an Slick query), and this is without sending it to a database to view database logs of the statements (or viewing the statements through Slick logging).\nObviously its possible to get around this by using proxy JDBC drivers (is there even a proxy JDBC driver for postgres?) or by having to manually create dummy database and inspecting logs, its something that is incredibly painful for something that should be as simple as action.insertStatements.\nThis also appears to be a regression, since it was easily possible in Slick 2.x",
            "url":"https://github.com/slick/slick/issues/1317"
          },
          {
            "number":1437,
            "title":"MySQL: auto-increment on secondary column in multiple-column index",
            "bodyText":"I originally posted a question related to this issue here.\nAfter following the advice in the comments (use codegen), here is a problem I have found:\n\n\ncreate the table foo\nCREATE TABLE foo (\n  id INTEGER NOT NULL AUTO_INCREMENT,\n  grp INTEGER NOT NULL ,\n  name VARCHAR(64),\n  PRIMARY KEY (id, grp)\n) ENGINE = MyISAM;\n\n\nuse codegen to build the Slick database model\n\n\ndelete the table in the database\n\n\nrebuild the table using Tables.schema. This throws the following error:\nException in thread \"main\" com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Incorrect table definition; there can be only one auto column and it must be defined as a key",
            "url":"https://github.com/slick/slick/issues/1437"
          },
          {
            "number":1446,
            "title":"Slick 3.1.0: UUIDJdbcType.sqlType for OracleDriver should be defined as java.sql.Types.BINARY",
            "bodyText":"In Slick 3.1.0, com.typesafe.slick.driver.oracle.OracleDriver overrides UUIDJdbcType and sets sqlType to java.sql.Types.OTHER.\nInserting a NULL value into a column defined as Column[Option[UUID]] (a nullable RAW(32) column), results in this exception: java.sql.SQLException: Invalid column type: 1111.\n1111 = java.sql.Types.OTHER.\nInstead setting this to java.sql.Types.BINARY resolves the issue.  Please note this only appears to be an issue when attempting to insert NULLs.   Please see the sample workaround below that we are currently using:\nimport com.typesafe.slick.driver.oracle.OracleDriver\n\ntrait CustomOracleDriver extends OracleDriver {\n\n  override val columnTypes = new JdbcTypes\n\n  class JdbcTypes extends super.JdbcTypes {\n\n    override val uuidJdbcType = new UUIDJdbcType\n\n    class UUIDJdbcType extends super.UUIDJdbcType {\n      override def sqlType = java.sql.Types.BINARY\n    }\n  }\n}\n\nobject CustomOracleDriver extends CustomOracleDriver\nI do believe java.sql.Types.BINARY is the more appropriate JDBC SQL type for Oracle RAW(16) or RAW(32) columns.\nI understand that slick-extensions is being contributed back to the core (thus I can see OracleProfile on the master branch) so I would assume it could be fixed in the next version of Slick (3.2.0 milestone?).",
            "url":"https://github.com/slick/slick/issues/1446"
          },
          {
            "number":1448,
            "title":"Postgresql, Code generation and default Tmestamp value \"current_date\"",
            "bodyText":"Hello.\nI have some table created with this code:\nCREATE SEQUENCE test_id_seq;\nCREATE TABLE TEST (\nid bigint default nextval('test_id_seq'),\nuserId bigint NOT NULL,\ncreateDate timestamp NOT NULL default current_date,\nPrimary Key (id),\nForeign Key (userId) references USERS (UserID)\n);\nduring code generation the error raised :\n[DEBUG] SlickException: Could not parse default value Some(('now'::text)::date) for column test.createdate of type java.sql.Timestamp, meta data: MColumn(MQName(public.test),createdate,93,timestamp,Some(29),Some(6),10,Some(false),None,Some(('now'::text)::date),29,6,Some(false),None,None,Some(false))\nWhere can i override parsing default value for dates and timestamps?",
            "url":"https://github.com/slick/slick/issues/1448"
          },
          {
            "number":1462,
            "title":"case class 22 argument limit",
            "bodyText":"Codegenerator still checks if there're less than 22 fields in a table to generate a case class, while in Scala 2.11 this issue was already fixed. Could we drop this line or enable such check explicitly via an extra argument?",
            "url":"https://github.com/slick/slick/issues/1462"
          },
          {
            "number":1687,
            "title":"com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Column length too big for column 'published_value' (max = 21845); use BLOB or TEXT instead",
            "bodyText":"I am trying to reopen this issue #1679 because I have some more information.\nI am using slick 3.1.1 and mysql innodb_version 5.7.17\nHere are the steps to replicate the issue.\n\ncreate database Test\nuse Test; create table Foo(bar mediumtext null)\ncreate database Test2\n\nNow using slick 3.1.1. generate source code against Test. You will get this code\npackage sql.models\n// AUTO-GENERATED Slick data model\n/** Stand-alone Slick data model for immediate use */\nobject Tables extends {\n  val profile = slick.driver.MySQLDriver\n} with Tables\n\n/** Slick data model trait for extension, choice of backend or usage in the cake pattern. (Make sure to initialize this late.) */\ntrait Tables {\n  val profile: slick.driver.JdbcProfile\n  import profile.api._\n  import slick.model.ForeignKeyAction\n  // NOTE: GetResult mappers for plain SQL are only generated for tables where Slick knows how to map the types of all columns.\n  import slick.jdbc.{GetResult => GR}\n\n  /** DDL for all tables. Call .create to execute. */\n  lazy val schema: profile.SchemaDescription = Foo.schema\n  @deprecated(\"Use .schema instead of .ddl\", \"3.0\")\n  def ddl = schema\n\n  /** Entity class storing rows of table Foo\n   *  @param bar Database column bar SqlType(MEDIUMTEXT), Length(16777215,true), Default(None) */\n  case class FooRow(bar: Option[String] = None)\n  /** GetResult implicit for fetching FooRow objects using plain SQL queries */\n  implicit def GetResultFooRow(implicit e0: GR[Option[String]]): GR[FooRow] = GR{\n    prs => import prs._\n    FooRow(<<?[String])\n  }\n  /** Table description of table Foo. Objects of this class serve as prototypes for rows in queries. */\n  class Foo(_tableTag: Tag) extends Table[FooRow](_tableTag, \"Foo\") {\n    def * = bar <> (FooRow, FooRow.unapply)\n\n    /** Database column bar SqlType(MEDIUMTEXT), Length(16777215,true), Default(None) */\n    val bar: Rep[Option[String]] = column[Option[String]](\"bar\", O.Length(16777215,varying=true), O.Default(None))\n  }\n  /** Collection-like TableQuery object for table Foo */\n  lazy val Foo = new TableQuery(tag => new Foo(tag))\n}\n\nNow try to recreate the database on Test2\n   val props = Map[String, String]()\n   val db = Database.forURL(\"jdbc:mysql://localhost:3306/Test2?user=foo&password=bar\", driver = slickDriver)\n   val action = Tables.schema.create\n   val future = db.run(action)\n   Await.result(future, Duration.Inf)\n\nAnd you will get error\nerror] (run-main-1) com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Column length too big for column 'bar' (max = 21845); use BLOB or TEXT instead\ncom.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Column length too big for column 'bar' (max = 21845); use BLOB or TEXT instead\n\nIf I look here http://stackoverflow.com/questions/13932750/tinytext-text-mediumtext-and-longtext-maximum-storage-sizes 21845 is the max length of the TEXT datatype. So it seems to me that slick is trying to recreate the table in Test2 using TEXT and not MEDIUMTEXT.",
            "url":"https://github.com/slick/slick/issues/1687"
          },
          {
            "number":1699,
            "title":"insertOrUpdate generates invalid SQL without primary key",
            "bodyText":"If insertOrUpdate is used with a row object for which no primary key is specified, invalid SQL gets generated:\n2017-03-06 14:47:02.675 DEBUG slick.jdbc.JdbcBackend.statement - Preparing statement: insert into \"foo\" (\"a\", \"b\", \"c\") values (?, ?, ?) on conflict () do update set \"a\"=EXCLUDED.\"a\", \"b\"=EXCLUDED.\"b\", \"c\"=EXCLUDED.\"c\"\n\nWhich results in the following database error with PostgreSQL:\norg.postgresql.util.PSQLException: ERROR: syntax error at or near \")\"\n  Position: 132\n        at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2412) ~[postgresql-42.0.0.jar:42.0.0]\n        at org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:2125) ~[postgresql-42.0.0.jar:42.0.0]\n        at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:297) ~[postgresql-42.0.0.jar:42.0.0]\n        at org.postgresql.jdbc.PgStatement.executeInternal(PgStatement.java:428) ~[postgresql-42.0.0.jar:42.0.0]\n        at org.postgresql.jdbc.PgStatement.execute(PgStatement.java:354) ~[postgresql-42.0.0.jar:42.0.0]\n        at org.postgresql.jdbc.PgPreparedStatement.executeWithFlags(PgPreparedStatement.java:169) ~[postgresql-42.0.0.jar:42.0.0]\n        at org.postgresql.jdbc.PgPreparedStatement.executeUpdate(PgPreparedStatement.java:136) ~[postgresql-42.0.0.jar:42.0.0]\n        at com.zaxxer.hikari.pool.ProxyPreparedStatement.executeUpdate(ProxyPreparedStatement.java:61) ~[HikariCP-2.5.1.jar:na]\n        at com.zaxxer.hikari.pool.HikariProxyPreparedStatement.executeUpdate(HikariProxyPreparedStatement.java) ~[HikariCP-2.5.1.jar:na]\n        at slick.jdbc.LoggingPreparedStatement$$anonfun$executeUpdate$5.apply$mcI$sp(LoggingStatement.scala:155) ~[slick_2.11-3.2.0.jar:na]\n        at slick.jdbc.LoggingPreparedStatement$$anonfun$executeUpdate$5.apply(LoggingStatement.scala:155) ~[slick_2.11-3.2.0.jar:na]\n        at slick.jdbc.LoggingPreparedStatement$$anonfun$executeUpdate$5.apply(LoggingStatement.scala:155) ~[slick_2.11-3.2.0.jar:na]\n        at slick.jdbc.LoggingStatement.logged(LoggingStatement.scala:84) ~[slick_2.11-3.2.0.jar:na]\n        at slick.jdbc.LoggingPreparedStatement.executeUpdate(LoggingStatement.scala:155) ~[slick_2.11-3.2.0.jar:na]\n        at slick.jdbc.JdbcActionComponent$InsertActionComposerImpl$InsertOrUpdateAction$$anonfun$nativeUpsert$1.apply(JdbcActionComponent.scala:564) ~[slick_2.11-3.2.0.jar:na]\n        at slick.jdbc.JdbcActionComponent$InsertActionComposerImpl$InsertOrUpdateAction$$anonfun$nativeUpsert$1.apply(JdbcActionComponent.scala:561) ~[slick_2.11-3.2.0.jar:na]\n        at slick.jdbc.JdbcBackend$SessionDef$class.withPreparedStatement(JdbcBackend.scala:372) ~[slick_2.11-3.2.0.jar:na]\n        at slick.jdbc.JdbcBackend$BaseSession.withPreparedStatement(JdbcBackend.scala:434) ~[slick_2.11-3.2.0.jar:na]\n        at slick.jdbc.JdbcActionComponent$InsertActionComposerImpl.preparedInsert(JdbcActionComponent.scala:502) ~[slick_2.11-3.2.0.jar:na]\n        at slick.jdbc.JdbcActionComponent$InsertActionComposerImpl$InsertOrUpdateAction.nativeUpsert(JdbcActionComponent.scala:561) ~[slick_2.11-3.2.0.jar:na]\n        at slick.jdbc.JdbcActionComponent$InsertActionComposerImpl$InsertOrUpdateAction.f$1(JdbcActionComponent.scala:544) ~[slick_2.11-3.2.0.jar:na]\n...\n\nSlick should detect this mapping anomaly issue an error message.\nThis is with Slick 3.2.0 and PostgreSQL.",
            "url":"https://github.com/slick/slick/issues/1699"
          }
        ]
      }
    }
  }
}
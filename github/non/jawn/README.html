<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h2><a id="user-content-jawn" class="anchor" href="https://github.com/non/jawn#jawn" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Jawn</h2> 
  <p>"Jawn is for parsing jay-sawn."</p> 
  <h3><a id="user-content-origin" class="anchor" href="https://github.com/non/jawn#origin" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Origin</h3> 
  <p>The term "jawn" comes from the Philadelphia area. It conveys about as much information as "thing" does. I chose the name because I had moved to Montreal so I was remembering Philly fondly. Also, there isn't a better way to describe objects encoded in JSON than "things". Finally, we get a catchy slogan.</p> 
  <p>Jawn was designed to parse JSON into an AST as quickly as possible.</p> 
  <p><a href="https://travis-ci.org/non/jawn" target="_blank"><img src="https://camo.githubusercontent.com/1292e9228777e717577c7a8b4f474575959036fa/68747470733a2f2f6170692e7472617669732d63692e6f72672f6e6f6e2f6a61776e2e737667" alt="Build Status" data-canonical-src="https://api.travis-ci.org/non/jawn.svg" style="max-width:100%;"></a> <a href="https://gitter.im/non/jawn?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" target="_blank"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Gitter" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a> <a href="https://index.scala-lang.org/non/jawn/jawn-parser" target="_blank"><img src="https://camo.githubusercontent.com/4152f64bcc847692611d239cfbcf9341ef8126c3/68747470733a2f2f696e6465782e7363616c612d6c616e672e6f72672f6e6f6e2f6a61776e2f6a61776e2d7061727365722f6c61746573742e7376673f636f6c6f723d6f72616e6765" alt="Latest version" data-canonical-src="https://index.scala-lang.org/non/jawn/jawn-parser/latest.svg?color=orange" style="max-width:100%;"></a></p> 
  <h3><a id="user-content-overview" class="anchor" href="https://github.com/non/jawn#overview" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Overview</h3> 
  <p>Jawn consists of three parts:</p> 
  <ol> 
   <li>A fast, generic JSON parser</li> 
   <li>A small, somewhat anemic AST</li> 
   <li>Support packages which parse to third-party ASTs</li> 
  </ol> 
  <p>Currently Jawn is competitive with the fastest Java JSON libraries (GSON and Jackson) and in the author's benchmarks it often wins. It seems to be faster than any other Scala parser that exists (as of July 2014).</p> 
  <p>Given the plethora of really nice JSON libraries for Scala, the expectation is that you are here for (1) and (3) not (2).</p> 
  <h3><a id="user-content-quick-start" class="anchor" href="https://github.com/non/jawn#quick-start" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Quick Start</h3> 
  <p>Jawn supports Scala 2.10, 2.11, and 2.12.</p> 
  <p>Here's a <code>build.sbt</code> snippet that shows you how to depend on Jawn in your own SBT project:</p> 
  <div class="highlight highlight-source-scala">
   <pre>resolvers <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-en">Resolver</span>.sonatypeRepo(<span class="pl-s"><span class="pl-pds">"</span>releases<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> use this if you just want jawn's parser, and will implement your own facade</span>
libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>org.spire-math<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>jawn-parser<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.10.4<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">//</span> use this if you want jawn's parser and also jawn's ast</span>
libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>org.spire-math<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>jawn-ast<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.10.4<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>If you want to use Jawn's parser with another project's AST, see the "Supporting external ASTs with Jawn" section. For example, with Spray you would say:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>org.spire-math<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>jawn-spray<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.10.4<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>There are a few reasons you might want to do this:</p> 
  <ul> 
   <li>The library's built-in parser is significantly slower than Jawn's.</li> 
   <li>Jawn supports more input types (<code>ByteBuffer</code>, <code>File</code>, etc.).</li> 
   <li>You need asynchronous JSON parsing.</li> 
  </ul> 
  <p>(NOTE: previous to version 0.8.3 the support libraries would have been named <code>"spray-support"</code> instead of <code>"jawn-spray"</code>.)</p> 
  <h3><a id="user-content-dependencies" class="anchor" href="https://github.com/non/jawn#dependencies" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Dependencies</h3> 
  <p><em>jawn-parser</em> has no dependencies other than Scala.</p> 
  <p><em>jawn-ast</em> depends on <em>jawn-parser</em> but nothing else.</p> 
  <p>The various support projects (e.g. <em>jawn-argonaut</em>) depend on the library they are supporting.</p> 
  <h3><a id="user-content-parsing" class="anchor" href="https://github.com/non/jawn#parsing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Parsing</h3> 
  <p>Jawn's parser is both fast and relatively featureful. Assuming you want to get back an AST of type <code>J</code> and you have a <code>Facade[J]</code> defined, you can use the following <code>parse</code> signatures:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">Parser</span>.parseUnsafe[<span class="pl-en">J</span>](<span class="pl-k">String</span>) <span class="pl-k">→</span> <span class="pl-en">J</span>
<span class="pl-en">Parser</span>.parseFromString[<span class="pl-en">J</span>](<span class="pl-k">String</span>) <span class="pl-k">→</span> <span class="pl-en">Try</span>[<span class="pl-en">J</span>]
<span class="pl-en">Parser</span>.parsefromPath[<span class="pl-en">J</span>](<span class="pl-k">String</span>) <span class="pl-k">→</span> <span class="pl-en">Try</span>[<span class="pl-en">J</span>]
<span class="pl-en">Parser</span>.parseFromFile[<span class="pl-en">J</span>](<span class="pl-en">File</span>) <span class="pl-k">→</span> <span class="pl-en">Try</span>[<span class="pl-en">J</span>]
<span class="pl-en">Parser</span>.parseFromChannel[<span class="pl-en">J</span>](<span class="pl-en">ReadableByteChannel</span>) <span class="pl-k">→</span> <span class="pl-en">Try</span>[<span class="pl-en">J</span>]
<span class="pl-en">Parser</span>.parseFromByteBuffer[<span class="pl-en">J</span>](<span class="pl-en">ByteBuffer</span>) <span class="pl-k">→</span> <span class="pl-en">Try</span>[<span class="pl-en">J</span>]</pre>
  </div> 
  <p>Jawn also supports asynchronous parsing, which allows users to feed the parser with data as it is available. There are three modes:</p> 
  <ul> 
   <li><code>SingleValue</code> waits to return a single <code>J</code> value once parsing is done.</li> 
   <li><code>UnwrapArray</code> if the top-level element is an array, return values as they become available.</li> 
   <li><code>ValueStream</code> parse one-or-more json values separated by whitespace.</li> 
  </ul> 
  <p>Here's an example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">jawn.</span><span class="pl-v">ast</span>
<span class="pl-k">import</span> <span class="pl-v">jawn.</span><span class="pl-v">AsyncParser</span>
<span class="pl-k">import</span> <span class="pl-v">jawn.</span><span class="pl-v">ParseException</span>

<span class="pl-k">val</span> <span class="pl-en">p</span> <span class="pl-k">=</span> ast.<span class="pl-en">JParser</span>.async(mode <span class="pl-k">=</span> <span class="pl-en">AsyncParser</span>.<span class="pl-en">UnwrapArray</span>)

<span class="pl-k">def</span> <span class="pl-en">chunks</span><span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-k">String</span>] <span class="pl-k">=</span> <span class="pl-k">???</span>
<span class="pl-k">def</span> <span class="pl-en">sink</span>(<span class="pl-v">j</span>: ast.<span class="pl-en">JValue</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span> <span class="pl-k">=</span> <span class="pl-k">???</span>

<span class="pl-k">def</span> <span class="pl-en">loop</span>(<span class="pl-v">st</span>: <span class="pl-en">Stream</span>[<span class="pl-k">String</span>])<span class="pl-k">:</span> <span class="pl-en">Either</span>[<span class="pl-en">ParseException</span>, <span class="pl-k">Unit</span>] <span class="pl-k">=</span>
  st <span class="pl-k">match</span> {
    <span class="pl-k">case</span> s <span class="pl-v">#:</span>: tail <span class="pl-k">=&gt;</span>
      p.absorb(s) <span class="pl-k">match</span> {
        <span class="pl-k">case</span> <span class="pl-en">Right</span>(js) <span class="pl-k">=&gt;</span>
          js.foreach(sink)
          loop(tail)
        <span class="pl-k">case</span> <span class="pl-en">Left</span>(e) <span class="pl-k">=&gt;</span>
          <span class="pl-en">Left</span>(e)
      }
    <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span>
      p.finish().right.map(_.foreach(sink))
  }

loop(chunks)</pre>
  </div> 
  <p>You can also call <code>jawn.Parser.async[J]</code> to use async parsing with an arbitrary data type (provided you also have an implicit <code>Facade[J]</code>).</p> 
  <h3><a id="user-content-supporting-external-asts-with-jawn" class="anchor" href="https://github.com/non/jawn#supporting-external-asts-with-jawn" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Supporting external ASTs with Jawn</h3> 
  <p>Jawn currently supports six external ASTs directly:</p> 
  <table> 
   <thead> 
    <tr> 
     <th>AST</th> 
     <th>2.10</th> 
     <th>2.11</th> 
     <th>2.12</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>Argonaut</td> 
     <td>6.2</td> 
     <td>6.2</td> 
     <td>6.2</td> 
    </tr> 
    <tr> 
     <td>Json4s</td> 
     <td>3.5.2</td> 
     <td>3.5.2</td> 
     <td>3.5.2</td> 
    </tr> 
    <tr> 
     <td>Play-json</td> 
     <td>2.4.11</td> 
     <td>2.5.15</td> 
     <td>2.6.0</td> 
    </tr> 
    <tr> 
     <td>Rojoma</td> 
     <td>2.4.3</td> 
     <td>2.4.3</td> 
     <td>2.4.3</td> 
    </tr> 
    <tr> 
     <td>Rojoma-v3</td> 
     <td>3.7.2</td> 
     <td>3.7.2</td> 
     <td>3.7.2</td> 
    </tr> 
    <tr> 
     <td>Spray</td> 
     <td>1.3.3</td> 
     <td>1.3.3</td> 
     <td>1.3.3</td> 
    </tr>
   </tbody>
  </table> 
  <p>Each of these subprojects provides a <code>Parser</code> object (an instance of <code>SupportParser[J]</code>) that is parameterized on the given project's AST (<code>J</code>). The following methods are available:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">Parser</span>.parseUnsafe(<span class="pl-k">String</span>) <span class="pl-k">→</span> <span class="pl-en">J</span>
<span class="pl-en">Parser</span>.parseFromString(<span class="pl-k">String</span>) <span class="pl-k">→</span> <span class="pl-en">Try</span>[<span class="pl-en">J</span>]
<span class="pl-en">Parser</span>.parsefromPath(<span class="pl-k">String</span>) <span class="pl-k">→</span> <span class="pl-en">Try</span>[<span class="pl-en">J</span>]
<span class="pl-en">Parser</span>.parseFromFile(<span class="pl-en">File</span>) <span class="pl-k">→</span> <span class="pl-en">Try</span>[<span class="pl-en">J</span>]
<span class="pl-en">Parser</span>.parseFromChannel(<span class="pl-en">ReadableByteChannel</span>) <span class="pl-k">→</span> <span class="pl-en">Try</span>[<span class="pl-en">J</span>]
<span class="pl-en">Parser</span>.parseFromByteBuffer(<span class="pl-en">ByteBuffer</span>) <span class="pl-k">→</span> <span class="pl-en">Try</span>[<span class="pl-en">J</span>]</pre>
  </div> 
  <p>These methods parallel those provided by <code>jawn.Parser</code>.</p> 
  <p>For the following snippets, <code>XYZ</code> is one of (<code>argonaut</code>, <code>json4s</code>, <code>play</code>, <code>rojoma</code>, <code>rojoma-v3</code> or <code>spray</code>):</p> 
  <p>This is how you would include the subproject in build.sbt:</p> 
  <div class="highlight highlight-source-scala">
   <pre>resolvers <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-en">Resolver</span>.sonatypeRepo(<span class="pl-s"><span class="pl-pds">"</span>releases<span class="pl-pds">"</span></span>)

libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>org.spire-math<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> jawn<span class="pl-k">-</span><span class="pl-s"><span class="pl-pds">"</span>XYZ<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.10.4<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>This is an example of how you might use the parser into your code:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">jawn.support.XYZ.</span><span class="pl-v">Parser</span>

<span class="pl-k">val</span> <span class="pl-en">myResult</span> <span class="pl-k">=</span> <span class="pl-en">Parser</span>.parseFromString(myString)</pre>
  </div> 
  <h3><a id="user-content-do-it-yourself-parsing" class="anchor" href="https://github.com/non/jawn#do-it-yourself-parsing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Do-It-Yourself Parsing</h3> 
  <p>Jawn supports building any JSON AST you need via type classes. You benefit from Jawn's fast parser while still using your favorite Scala JSON library. This mechanism is also what allows Jawn to provide "support" for other libraries' ASTs.</p> 
  <p>To include Jawn's parser in your project, add the following snippet to your <code>build.sbt</code> file:</p> 
  <div class="highlight highlight-source-scala">
   <pre>resolvers <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-en">Resolver</span>.sonatypeRepo(<span class="pl-s"><span class="pl-pds">"</span>releases<span class="pl-pds">"</span></span>)

libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>org.spire-math<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>jawn-parser<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.10.4<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>To support your AST of choice, you'll want to define a <code>Facade[J]</code> instance, where the <code>J</code> type parameter represents the base of your JSON AST. For example, here's a facade that supports Spray:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">spray.json.</span><span class="pl-v">_</span>
<span class="pl-k">object</span> <span class="pl-en">Spray</span> <span class="pl-k">extends</span> <span class="pl-e">SimpleFacade</span>[<span class="pl-en">JsValue</span>] {
  <span class="pl-k">def</span> <span class="pl-en">jnull</span>() <span class="pl-k">=</span> <span class="pl-en">JsNull</span>
  <span class="pl-k">def</span> <span class="pl-en">jfalse</span>() <span class="pl-k">=</span> <span class="pl-en">JsFalse</span>
  <span class="pl-k">def</span> <span class="pl-en">jtrue</span>() <span class="pl-k">=</span> <span class="pl-en">JsTrue</span>
  <span class="pl-k">def</span> <span class="pl-en">jnum</span>(<span class="pl-v">s</span>: <span class="pl-k">String</span>) <span class="pl-k">=</span> <span class="pl-en">JsNumber</span>(s)
  <span class="pl-k">def</span> <span class="pl-en">jint</span>(<span class="pl-v">s</span>: <span class="pl-k">String</span>) <span class="pl-k">=</span> <span class="pl-en">JsNumber</span>(s)
  <span class="pl-k">def</span> <span class="pl-en">jstring</span>(<span class="pl-v">s</span>: <span class="pl-k">String</span>) <span class="pl-k">=</span> <span class="pl-en">JsString</span>(s)
  <span class="pl-k">def</span> <span class="pl-en">jarray</span>(<span class="pl-v">vs</span>: <span class="pl-en">List</span>[<span class="pl-en">JsValue</span>]) <span class="pl-k">=</span> <span class="pl-en">JsArray</span>(vs)
  <span class="pl-k">def</span> <span class="pl-en">jobject</span>(<span class="pl-v">vs</span>: <span class="pl-en">Map</span>[<span class="pl-k">String</span>, <span class="pl-en">JsValue</span>]) <span class="pl-k">=</span> <span class="pl-en">JsObject</span>(vs)
}</pre>
  </div> 
  <p>Most ASTs will be easy to define using the <code>SimpleFacade</code> or <code>MutableFacade</code> traits. However, if an ASTs object or array instances do more than just wrap a Scala collection, it may be necessary to extend <code>Facade</code> directly.</p> 
  <p>You can also look at the facades used by the support projects to help you create your own. This could also be useful if you wanted to use an older version of a supported library.</p> 
  <h3><a id="user-content-using-the-ast" class="anchor" href="https://github.com/non/jawn#using-the-ast" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using the AST</h3> 
  <h4><a id="user-content-access" class="anchor" href="https://github.com/non/jawn#access" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Access</h4> 
  <p>For accessing atomic values, <code>JValue</code> supports two sets of methods: <em>get-style</em> methods and <em>as-style</em> methods.</p> 
  <p>The <em>get-style</em> methods return <code>Some(_)</code> when called on a compatible JSON value (e.g. strings can return <code>Some[String]</code>, numbers can return <code>Some[Double]</code>, etc.), and <code>None</code> otherwise:</p> 
  <div class="highlight highlight-source-scala">
   <pre>getBoolean <span class="pl-k">→</span> <span class="pl-en">Option</span>[<span class="pl-k">Boolean</span>]
getString <span class="pl-k">→</span> <span class="pl-en">Option</span>[<span class="pl-k">String</span>]
getLong <span class="pl-k">→</span> <span class="pl-en">Option</span>[<span class="pl-k">Long</span>]
getDouble <span class="pl-k">→</span> <span class="pl-en">Option</span>[<span class="pl-k">Double</span>]
getBigInt <span class="pl-k">→</span> <span class="pl-en">Option</span>[<span class="pl-en">BigInt</span>]
getBigDecimal <span class="pl-k">→</span> <span class="pl-en">Option</span>[<span class="pl-en">BigDecimal</span>]</pre>
  </div> 
  <p>In constrast, the <em>as-style</em> methods will either return an unwrapped value (instead of returning <code>Some(_)</code>) or throw an exception (instead of returning <code>None</code>):</p> 
  <div class="highlight highlight-source-scala">
   <pre>asBoolean <span class="pl-k">→</span> <span class="pl-k">Boolean</span> <span class="pl-c"><span class="pl-c">//</span> or exception</span>
asString <span class="pl-k">→</span> <span class="pl-k">String</span> <span class="pl-c"><span class="pl-c">//</span> or exception</span>
asLong <span class="pl-k">→</span> <span class="pl-k">Long</span> <span class="pl-c"><span class="pl-c">//</span> or exception</span>
asDouble <span class="pl-k">→</span> <span class="pl-k">Double</span> <span class="pl-c"><span class="pl-c">//</span> or exception</span>
asBigInt <span class="pl-k">→</span> <span class="pl-en">BigInt</span> <span class="pl-c"><span class="pl-c">//</span> or exception</span>
asBigDecimal <span class="pl-k">→</span> <span class="pl-en">BigDecimal</span> <span class="pl-c"><span class="pl-c">//</span> or exception</span></pre>
  </div> 
  <p>To access elements of an array, call <code>get</code> with an <code>Int</code> position:</p> 
  <div class="highlight highlight-source-scala">
   <pre>get(<span class="pl-v">i</span>: <span class="pl-k">Int</span>) <span class="pl-k">→</span> <span class="pl-en">JValue</span> <span class="pl-c"><span class="pl-c">//</span> returns JNull if index is illegal</span></pre>
  </div> 
  <p>To access elements of an object, call <code>get</code> with a <code>String</code> key:</p> 
  <div class="highlight highlight-source-scala">
   <pre>get(<span class="pl-v">k</span>: <span class="pl-k">String</span>) <span class="pl-k">→</span> <span class="pl-en">JValue</span> <span class="pl-c"><span class="pl-c">//</span> returns JNull if key is not found</span></pre>
  </div> 
  <p>Both of these methods also return <code>JNull</code> if the value is not the appropraite container. This allows the caller to chain lookups without having to check that each level is correct:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">v</span><span class="pl-k">:</span> <span class="pl-en">JValue</span> <span class="pl-k">=</span> <span class="pl-k">???</span>

<span class="pl-c"><span class="pl-c">//</span> returns JNull if a problem is encountered in structure of 'v'.</span>
<span class="pl-k">val</span> <span class="pl-en">t</span><span class="pl-k">:</span> <span class="pl-en">JValue</span> <span class="pl-k">=</span> v.get(<span class="pl-s"><span class="pl-pds">"</span>novels<span class="pl-pds">"</span></span>).get(<span class="pl-c1">0</span>).get(<span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> if 'v' had the right structure and 't' is JString(s), then Some(s).</span>
<span class="pl-c"><span class="pl-c">//</span> otherwise, None.</span>
<span class="pl-k">val</span> <span class="pl-en">titleOrNone</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-k">String</span>] <span class="pl-k">=</span> t.getString

<span class="pl-c"><span class="pl-c">//</span> equivalent to titleOrNone.getOrElse(throw ...)</span>
<span class="pl-k">val</span> <span class="pl-en">titleOrDie</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> t.asString</pre>
  </div> 
  <h4><a id="user-content-updating" class="anchor" href="https://github.com/non/jawn#updating" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Updating</h4> 
  <p>The atomic values (<code>JNum</code>, <code>JBoolean</code>, <code>JNum</code>, and <code>JString</code>) are immutable.</p> 
  <p>Objects are fully-mutable and can have items added, removed, or changed:</p> 
  <div class="highlight highlight-source-scala">
   <pre>set(<span class="pl-v">k</span>: <span class="pl-k">String</span>, <span class="pl-v">v</span>: <span class="pl-en">JValue</span>) <span class="pl-k">→</span> <span class="pl-k">Unit</span>
remove(<span class="pl-v">k</span>: <span class="pl-k">String</span>) <span class="pl-k">→</span> <span class="pl-en">Option</span>[<span class="pl-en">JValue</span>]</pre>
  </div> 
  <p>If <code>set</code> is called on a non-object, an exception will be thrown. If <code>remove</code> is called on a non-object, <code>None</code> will be returned.</p> 
  <p>Arrays are semi-mutable. Their values can be changed, but their size is fixed:</p> 
  <div class="highlight highlight-source-scala">
   <pre>set(<span class="pl-v">i</span>: <span class="pl-k">Int</span>, <span class="pl-v">v</span>: <span class="pl-en">JValue</span>) <span class="pl-k">→</span> <span class="pl-k">Unit</span></pre>
  </div> 
  <p>If <code>set</code> is called on a non-array, or called with an illegal index, an exception will be thrown.</p> 
  <p>(A future version of Jawn may provide an array whose length can be changed.)</p> 
  <h3><a id="user-content-profiling" class="anchor" href="https://github.com/non/jawn#profiling" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Profiling</h3> 
  <p>Jawn uses <a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank">JMH</a> along with the <a href="https://github.com/ktoso/sbt-jmh" target="_blank">sbt-jmh</a> plugin.</p> 
  <h4><a id="user-content-running-benchmarks" class="anchor" href="https://github.com/non/jawn#running-benchmarks" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Running Benchmarks</h4> 
  <p>The benchmarks are located in the <code>benchmark</code> project. You can run the benchmarks by typing <code>benchmark/run</code> from SBT. There are many supported arguments, so here are a few examples:</p> 
  <p>Run all benchmarks, with 10 warmups, 10 iterations, using 3 threads:</p> 
  <p><code>benchmark/run -wi 10 -i 10 -f1 -t3</code></p> 
  <p>Run just the <code>CountriesBench</code> test (5 warmups, 5 iterations, 1 thread):</p> 
  <p><code>benchmark/run -wi 5 -i 5 -f1 -t1 .*CountriesBench</code></p> 
  <h4><a id="user-content-benchmark-issues" class="anchor" href="https://github.com/non/jawn#benchmark-issues" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Benchmark Issues</h4> 
  <p>Currently, the benchmarks are a bit fiddily. The most obvious symptom is that if you compile the benchmarks, make changes, and compile again, you may see errors like:</p> 
  <pre><code>[error] (benchmark/jmh:generateJavaSources) java.lang.NoClassDefFoundError: jawn/benchmark/Bla25Bench
</code></pre> 
  <p>The fix here is to run <code>benchmark/clean</code> and try again.</p> 
  <p>You will also see intermittent problems like:</p> 
  <pre><code>[error] (benchmark/jmh:compile) java.lang.reflect.MalformedParameterizedTypeException
</code></pre> 
  <p>The solution here is easier (though frustrating): just try it again. If you continue to have problems, consider cleaning the project and trying again.</p> 
  <p>(In the future I hope to make the benchmarking here a bit more resilient. Suggestions and pull requests gladly welcome!)</p> 
  <h4><a id="user-content-files" class="anchor" href="https://github.com/non/jawn#files" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Files</h4> 
  <p>The benchmarks use files located in <code>benchmark/src/main/resources</code>. If you want to test your own files (e.g. <code>mydata.json</code>), you would:</p> 
  <ul> 
   <li>Copy the file to <code>benchmark/src/main/resources/mydata.json</code>.</li> 
   <li>Add the following code to <code>JmhBenchmarks.scala</code>:</li> 
  </ul> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">MyDataBench</span> <span class="pl-k">extends</span> <span class="pl-e">JmhBenchmarks</span>(<span class="pl-s"><span class="pl-pds">"</span>mydata.json<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>Jawn has been tested with much larger files, e.g. 100M - 1G, but these are obviously too large to ship with the project.</p> 
  <p>With large files, it's usually easier to comment out most of the benchmarking methods and only test one (or a few) methods. Some of the slower JSON parsers get <em>much</em> slower for large files.</p> 
  <h4><a id="user-content-interpreting-the-results" class="anchor" href="https://github.com/non/jawn#interpreting-the-results" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Interpreting the results</h4> 
  <p>Remember that the benchmarking results you see will vary based on:</p> 
  <ul> 
   <li>Hardware</li> 
   <li>Java version</li> 
   <li>JSON file size</li> 
   <li>JSON file structure</li> 
   <li>JSON data values</li> 
  </ul> 
  <p>I have tried to use each library in the most idiomatic and fastest way possible (to parse the JSON into a simple AST). Pull requests to update library versions and improve usage are very welcome.</p> 
  <h3><a id="user-content-future-work" class="anchor" href="https://github.com/non/jawn#future-work" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Future Work</h3> 
  <p>More support libraries could be added.</p> 
  <p>It's likely that some of Jawn's I/O could be optimized a bit more, and also made more configurable. The heuristics around all-at-once loading versus input chunking could definitely be improved.</p> 
  <p>In cases where the user doesn't need fast lookups into JSON objects, an even lighter AST could be used to improve parsing and rendering speeds.</p> 
  <p>Strategies to cache/intern field names of objects could pay big dividends in some cases (this might require AST changes).</p> 
  <p>If you have ideas for any of these (or other ideas) please feel free to open an issue or pull request so we can talk about it.</p> 
  <h3><a id="user-content-disclaimers" class="anchor" href="https://github.com/non/jawn#disclaimers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Disclaimers</h3> 
  <p>Jawn only supports UTF-8 when parsing bytes. This might change in the future, but for now that's the target case. You can always decode your data to a string, and handle the character set decoding using Java's standard tools.</p> 
  <p>Jawn's AST is intended to be very lightweight and simple. It supports simple access, and limited mutable updates. It intentionally lacks the power and sophistication of many other JSON libraries.</p> 
  <h3><a id="user-content-copyright-and-license" class="anchor" href="https://github.com/non/jawn#copyright-and-license" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Copyright and License</h3> 
  <p>All code is available to you under the MIT license, available at <a href="http://opensource.org/licenses/mit-license.php" target="_blank">http://opensource.org/licenses/mit-license.php</a>.</p> 
  <p>Copyright Erik Osheim, 2012-2016.</p> 
 </article>
</div>
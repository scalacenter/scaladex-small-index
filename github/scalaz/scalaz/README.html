<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-scalaz" class="anchor" href="https://github.com/scalaz/scalaz#scalaz" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Scalaz</h1> 
  <p>Scalaz is a Scala library for functional programming.</p> 
  <p>It provides purely functional data structures to complement those from the Scala standard library. It defines a set of foundational type classes (e.g. <code>Functor</code>, <code>Monad</code>) and corresponding instances for a large number of data structures.</p> 
  <p><a href="http://travis-ci.org/scalaz/scalaz" target="_blank"><img src="https://camo.githubusercontent.com/e147337d171c28ae435c4ea8b626660442b8a934/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f7363616c617a2f7363616c617a2e706e673f6272616e63683d7365726965732f372e332e78" alt="Build Status" data-canonical-src="https://secure.travis-ci.org/scalaz/scalaz.png?branch=series/7.3.x" style="max-width:100%;"></a></p> 
  <h2><a id="user-content-getting-scalaz" class="anchor" href="https://github.com/scalaz/scalaz#getting-scalaz" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting Scalaz</h2> 
  <p>The current stable version is 7.2.15, which is cross-built against Scala 2.10.x, 2.11.x and 2.12.x.</p> 
  <p>If you're using SBT, add the following line to your build file:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>org.scalaz<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>scalaz-core<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>7.2.15<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>For Maven and other build tools, you can visit <a href="http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.scalaz%22%20AND%20v%3A%227.2.15%22" target="_blank">search.maven.org</a>. (This search will also list all available modules of scalaz.)</p> 
  <p>To get sample configurations, click on the version of the module you are interested in. You can also find direct download links at the bottom of that page. Choose the file ending in <code>7.2.15.jar</code>.</p> 
  <h2><a id="user-content-quick-start" class="anchor" href="https://github.com/scalaz/scalaz#quick-start" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Quick Start</h2> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scalaz.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">std.option.</span><span class="pl-v">_, </span><span class="pl-v">std.list.</span><span class="pl-v">_ </span><span class="pl-c"><span class="pl-c">//</span> functions and type class instances for Option and List</span>

scala<span class="pl-k">&gt;</span> <span class="pl-en">Apply</span>[<span class="pl-en">Option</span>].apply2(some(<span class="pl-c1">1</span>), some(<span class="pl-c1">2</span>))((a, b) <span class="pl-k">=&gt;</span> a <span class="pl-k">+</span> b)
res0<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-c1">3</span>)

scala<span class="pl-k">&gt;</span> <span class="pl-en">Traverse</span>[<span class="pl-en">List</span>].traverse(<span class="pl-en">List</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>))(i <span class="pl-k">=&gt;</span> some(i))
res1<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">List</span>[<span class="pl-k">Int</span>]] <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-en">List</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>))</pre>
  </div> 
  <p>Use of the <code>Ops</code> classes, defined under <code>scalaz.syntax</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scalaz.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">std.list.</span><span class="pl-v">_ </span><span class="pl-c"><span class="pl-c">//</span> type class instances for List</span>
<span class="pl-k">import</span> <span class="pl-v">syntax.bind.</span><span class="pl-v">_ </span><span class="pl-c"><span class="pl-c">//</span> syntax for the Bind type class (and its parents)</span>

scala<span class="pl-k">&gt;</span> <span class="pl-en">List</span>(<span class="pl-en">List</span>(<span class="pl-c1">1</span>)).join
res0<span class="pl-k">:</span> <span class="pl-en">List</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-en">List</span>(<span class="pl-c1">1</span>)

scala<span class="pl-k">&gt;</span> <span class="pl-en">List</span>(<span class="pl-c1">true</span>, <span class="pl-c1">false</span>).ifM(<span class="pl-en">List</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>), <span class="pl-en">List</span>(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>))
res1<span class="pl-k">:</span> <span class="pl-en">List</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-en">List</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)</pre>
  </div> 
  <p>We've gone to great lengths to give you an <em>a-la-carte</em> importing experience, but if you prefer an all-you-can-eat buffet, you're in luck:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scalaz.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">Scalaz.</span><span class="pl-v">_</span>

scala<span class="pl-k">&gt;</span> <span class="pl-en">NonEmptyList</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>).cojoin
res0<span class="pl-k">:</span> scalaz.<span class="pl-en">NonEmptyList</span>[scalaz.<span class="pl-en">NonEmptyList</span>[<span class="pl-k">Int</span>]] <span class="pl-k">=</span> <span class="pl-en">NonEmptyList</span>(<span class="pl-en">NonEmptyList</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>), <span class="pl-en">NonEmptyList</span>(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>), <span class="pl-en">NonEmptyList</span>(<span class="pl-c1">3</span>))

scala<span class="pl-k">&gt;</span> <span class="pl-c1">1.</span>node(<span class="pl-c1">2.</span>leaf, <span class="pl-c1">3.</span>node(<span class="pl-c1">4.</span>leaf))
res1<span class="pl-k">:</span> scalaz.<span class="pl-en">Tree</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> &lt;<span class="pl-ent">tree</span>&gt;

scala<span class="pl-k">&gt;</span> <span class="pl-en">List</span>(some(<span class="pl-c1">1</span>), none).suml
res2<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-c1">1</span>)</pre>
  </div> 
  <h2><a id="user-content-resources" class="anchor" href="https://github.com/scalaz/scalaz#resources" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Resources</h2> 
  <p>Let the types speak for themselves via the <a href="http://scalaz.github.io/scalaz/#scaladoc" target="_blank">Scalaz Scaladocs</a>!</p> 
  <p>The <a href="https://github.com/scalaz/scalaz/tree/series/7.3.x/example/src/main/scala/scalaz/example" target="_blank">examples module</a> contains some snippets of Scalaz usage.</p> 
  <p>The <a href="https://github.com/scalaz/scalaz/wiki" target="_blank">wiki</a> contains release and migration information.</p> 
  <p>Talk with us by joining <a href="http://webchat.freenode.net/?channels=%23scalaz&amp;uio=d4" target="_blank">IRC: irc.freenode.net channel #scalaz</a>, or join <a href="https://groups.google.com/group/scalaz" target="_blank">the Scalaz mailing list on Google Groups</a>.</p> 
  <p>The <a href="http://typelevel.org/blog/" target="_blank">typelevel blog</a> has some great posts such as <a href="http://typelevel.org/blog/2013/10/13/towards-scalaz-1.html" target="_blank">Towards Scalaz</a> by <a href="https://twitter.com/adelbertchang" target="_blank">Adelbert Chang</a>.</p> 
  <p><a href="http://eed3si9n.com/learning-scalaz/index.html" target="_blank">Learning Scalaz</a> is a great series of blog posts by <a href="https://twitter.com/eed3si9n" target="_blank">Eugene Yokota</a>. Thanks, Eugene!</p> 
  <h2><a id="user-content-changes-in-version-7" class="anchor" href="https://github.com/scalaz/scalaz#changes-in-version-7" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Changes in Version 7</h2> 
  <p>Scalaz 7 represents a major reorganization of the library. We have taken a fresh look at the challenges of encoding type classes in Scala, in particular at when and how to employ the implicit scope.</p> 
  <h3><a id="user-content-at-a-glance" class="anchor" href="https://github.com/scalaz/scalaz#at-a-glance" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>At a glance</h3> 
  <ul> 
   <li><code>scalaz.{concurrent, effect, iteratee}</code> split to separate sub-projects; <code>scalaz.{http, geo}</code> dropped.</li> 
   <li>Refined and expanded the type class hierarchy.</li> 
   <li>Type class instances are no longer defined in the companion objects of the type class. Instances for standard library types are defined under <code>scalaz.std</code>, and instances for Scalaz data types are defined in the companion object for those types. An instance definition can provide multiple type classes in a single place, which was not always possible in Scalaz 6.</li> 
   <li>Type class instances have been organized to avoid ambiguity, a problem that arises when instances are dependent on other instances (for example, <code>Monoid[(A, B)]</code>)</li> 
   <li>Use of implicit views to provide access to Scalaz functionality as extension methods has been segregated to <code>scalaz.syntax</code>, and can be imported selectively, and need not be used at all.</li> 
   <li>Related functions are defined in the type class trait, to support standalone usage of the type class. In Scalaz 6, these were defined in <code>Identity</code>, <code>MA</code>, or <code>MAB</code>.</li> 
   <li>New data structures have been added, and existing ones generalized. A number of monad transformers have been provided, in some cases generalizing old data structures.</li> 
  </ul> 
  <h3><a id="user-content-modularity" class="anchor" href="https://github.com/scalaz/scalaz#modularity" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Modularity</h3> 
  <p>Scalaz has been modularised.</p> 
  <ul> 
   <li><strong>scalaz-core</strong>: Type class hierarchy, data structures, type class instances for the Scala and Java standard libraries, implicit conversions / syntax to access these.</li> 
   <li><strong>scalaz-effect</strong>: Data structures to represent and compose IO effects in the type system.</li> 
   <li><strong>scalaz-concurrent</strong>: Actor and Future implementation</li> 
   <li><strong>scalaz-iteratee</strong>: Experimental new Iteratee implementation</li> 
  </ul> 
  <h3><a id="user-content-type-class-hierarchy" class="anchor" href="https://github.com/scalaz/scalaz#type-class-hierarchy" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Type Class Hierarchy</h3> 
  <ul> 
   <li>Type classes form an inheritance hierarchy, as in Scalaz 6. This is convenient both at the call site and at the type class instance definition. At the call site, it ensures that you can call a method requiring a more general type class with an instance of a more specific type class:</li> 
  </ul> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">bar</span>[<span class="pl-en">M</span>[_]<span class="pl-k">:</span> <span class="pl-en">Functor</span>] <span class="pl-k">=</span> ()

<span class="pl-k">def</span> <span class="pl-en">foo</span>[<span class="pl-en">M</span>[_]<span class="pl-k">:</span> <span class="pl-en">Monad</span>] <span class="pl-k">=</span> bar[<span class="pl-en">M</span>] <span class="pl-c"><span class="pl-c">//</span> Monad[M] is a subtype of Functor[M]</span></pre>
  </div> 
  <ul> 
   <li>The hierarchy itself is largely the same as in Scalaz 6. However, there have been a few adjustments, some method signatures have been adjusted to support better standalone usage, so code depending on these will need to be re-worked.</li> 
  </ul> 
  <h3><a id="user-content-type-class-instance-definition" class="anchor" href="https://github.com/scalaz/scalaz#type-class-instance-definition" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Type Class Instance Definition</h3> 
  <ul> 
   <li><em>Constructive</em> implicits, which create a type class instance automatically based on instances of all parent type classes, are removed. These led to subtle errors with ambiguous implicits, such as this problem with <a href="http://stackoverflow.com/questions/7447591/how-do-i-use-name-as-an-applicative/7448111#7448111" target="_blank">FunctorBindApply</a></li> 
   <li>Type class instances are no longer declared in fragments in the companion objects of the type class. Instead, they are defined in the package <code>scalaz.std</code>, and must be imported. These instances are defined in traits which will be mixed together into an object for importing <em>en-masse</em>, if desired.</li> 
   <li>A single implicit can define a number of type class instances for a type.</li> 
   <li>A type class definition can override methods (including derived methods) for efficiency.</li> 
  </ul> 
  <p>Here is an instance definition for <code>Option</code>. Notice that the method <code>map</code> has been overriden.</p> 
  <div class="highlight highlight-source-scala">
   <pre>  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">option</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Traverse</span>[<span class="pl-en">Option</span>] <span class="pl-k">with</span> <span class="pl-e">MonadPlus</span>[<span class="pl-en">Option</span>] {
    <span class="pl-k">def</span> <span class="pl-en">point</span>[<span class="pl-en">A</span>](<span class="pl-v">a</span>: <span class="pl-k">=&gt;</span> <span class="pl-en">A</span>) <span class="pl-k">=</span> <span class="pl-en">Some</span>(a)
    <span class="pl-k">def</span> <span class="pl-en">bind</span>[<span class="pl-en">A</span>, <span class="pl-en">B</span>](<span class="pl-v">fa</span>: <span class="pl-en">Option</span>[<span class="pl-en">A</span>])(<span class="pl-v">f</span>: <span class="pl-en">A</span> <span class="pl-k">=&gt;</span> <span class="pl-en">Option</span>[<span class="pl-en">B</span>])<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">B</span>] <span class="pl-k">=</span> fa flatMap f
    <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">map</span>[<span class="pl-en">A</span>, <span class="pl-en">B</span>](<span class="pl-v">fa</span>: <span class="pl-en">Option</span>[<span class="pl-en">A</span>])(<span class="pl-v">f</span>: <span class="pl-en">A</span> <span class="pl-k">=&gt;</span> <span class="pl-en">B</span>)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">B</span>] <span class="pl-k">=</span> fa map f
    <span class="pl-k">def</span> <span class="pl-en">traverseImpl</span>[<span class="pl-en">F</span>[_], <span class="pl-en">A</span>, <span class="pl-en">B</span>](<span class="pl-v">fa</span>: <span class="pl-en">Option</span>[<span class="pl-en">A</span>])(<span class="pl-v">f</span>: <span class="pl-en">A</span> <span class="pl-k">=&gt;</span> <span class="pl-en">F</span>[<span class="pl-en">B</span>])(<span class="pl-k">implicit</span> <span class="pl-en">F</span><span class="pl-k">:</span> <span class="pl-en">Applicative</span>[<span class="pl-en">F</span>]) <span class="pl-k">=</span>
      fa map (a <span class="pl-k">=&gt;</span> <span class="pl-en">F</span>.map(f(a))(<span class="pl-en">Some</span>(_)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">B</span>])) getOrElse <span class="pl-en">F</span>.point(<span class="pl-c1">None</span>)
    <span class="pl-k">def</span> <span class="pl-en">empty</span>[<span class="pl-en">A</span>]<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> <span class="pl-c1">None</span>
    <span class="pl-k">def</span> <span class="pl-en">plus</span>[<span class="pl-en">A</span>](<span class="pl-v">a</span>: <span class="pl-en">Option</span>[<span class="pl-en">A</span>], <span class="pl-v">b</span>: <span class="pl-k">=&gt;</span> <span class="pl-en">Option</span>[<span class="pl-en">A</span>]) <span class="pl-k">=</span> a orElse b
    <span class="pl-k">def</span> <span class="pl-en">foldR</span>[<span class="pl-en">A</span>, <span class="pl-en">B</span>](<span class="pl-v">fa</span>: <span class="pl-en">Option</span>[<span class="pl-en">A</span>], <span class="pl-v">z</span>: <span class="pl-en">B</span>)(<span class="pl-v">f</span>: (<span class="pl-en">A</span>) <span class="pl-k">=&gt;</span> (<span class="pl-k">=&gt;</span> <span class="pl-en">B</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">B</span>)<span class="pl-k">:</span> <span class="pl-en">B</span> <span class="pl-k">=</span> fa <span class="pl-k">match</span> {
      <span class="pl-k">case</span> <span class="pl-en">Some</span>(a) <span class="pl-k">=&gt;</span> f(a)(z)
      <span class="pl-k">case</span> <span class="pl-c1">None</span> <span class="pl-k">=&gt;</span> z
    }
  }</pre>
  </div> 
  <p>To use this, one would:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scalaz.std.option.</span><span class="pl-v">optionInstance</span>
<span class="pl-c"><span class="pl-c">//</span> or, importing all instances en-masse</span>
<span class="pl-c"><span class="pl-c">//</span> import scalaz.Scalaz._</span>

<span class="pl-k">val</span> <span class="pl-en">M</span> <span class="pl-k">=</span> <span class="pl-en">Monad</span>[<span class="pl-en">Option</span>]
<span class="pl-k">val</span> <span class="pl-en">oi</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-en">M</span>.point(<span class="pl-c1">0</span>)</pre>
  </div> 
  <h3><a id="user-content-syntax" class="anchor" href="https://github.com/scalaz/scalaz#syntax" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Syntax</h3> 
  <p>We co-opt the term <em>syntax</em> to refer to the way we allow the functionality of Scalaz to be called in the <code>object.method(args)</code> form, which can be easier to read, and, given that type inference in Scala flows from left-to-right, can require fewer type annotations.</p> 
  <ul> 
   <li>No more <code>Identity</code>, <code>MA</code>, or <code>MAB</code> from Scalaz 6.</li> 
   <li>Syntax is segregated from rest of the library, in a sub-package <code>scalaz.syntax</code>.</li> 
   <li>All Scalaz functionality is available <em>without</em> using the provided syntax, by directly calling methods on the type class or its companion object.</li> 
   <li>Syntax is available <em>a-la-carte</em>. You can import the syntax for working with particular type classes where you need it. This avoids flooding the autocompletion in your IDE with every possible extension method. This should also help compiler performance, by reducing the implicit search space.</li> 
   <li>Syntax is layered in the same way as type classes. Importing the syntax for, say, <code>Applicative</code> will also provide the syntax for <code>Apply</code> and <code>Functor</code>.</li> 
  </ul> 
  <p>Syntax can be imported in two ways. Firstly, the syntax specialized for a particular instance of a type class can be imported directly from the instance itself.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> import the type class instance</span>
<span class="pl-k">import</span> <span class="pl-v">scalaz.std.option.</span><span class="pl-v">optionInstance</span>

<span class="pl-c"><span class="pl-c">//</span> import the implicit conversions to `MonadOps[Option, A]`, `BindOps[Option, A]`, ...</span>
<span class="pl-k">import</span> <span class="pl-v">optionInstance.monadSyntax.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">oi</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Option</span>[<span class="pl-k">Int</span>]] <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-en">Some</span>(<span class="pl-c1">1</span>))

<span class="pl-c"><span class="pl-c">//</span> Expands to: `ToBindOps(io).join`</span>
oi.join</pre>
  </div> 
  <p>Alternatively, the syntax can be imported for a particular type class.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> import the type class instance</span>
<span class="pl-k">import</span> <span class="pl-v">scalaz.std.option.</span><span class="pl-v">optionInstance</span>

<span class="pl-c"><span class="pl-c">//</span> import the implicit conversions to `MonadOps[F, A]`, `BindOps[F, A]`, ...</span>
<span class="pl-k">import</span> <span class="pl-v">scalaz.syntax.monad.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">oi</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Option</span>[<span class="pl-k">Int</span>]] <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-en">Some</span>(<span class="pl-c1">1</span>))

<span class="pl-c"><span class="pl-c">//</span> Expands to: ToBindOps(io).join</span>
oi.join</pre>
  </div> 
  <p>For some degree of backwards compatibility with Scalaz 6, the über-import of <code>import scalaz.Scalaz._</code> will import <em>all</em> implicit conversions that provide syntax (as well as type class instances and other functions). However, we recommend to review usage of this and replace with more focussed imports.</p> 
  <h3><a id="user-content-standalone-type-class-usage" class="anchor" href="https://github.com/scalaz/scalaz#standalone-type-class-usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Standalone Type Class Usage</h3> 
  <p>Type classes should be directly usable, without first needing to trigger implicit conversions. This might be desirable to reduce the runtime or cognitive overhead of the pimped types, or to define your own pimped types with a syntax of your choosing.</p> 
  <ul> 
   <li>The methods in type classes have been curried to maximize type inference.</li> 
   <li>Derived methods, based on the abstract methods in a type class, are defined in the type class itself.</li> 
   <li>Each type class companion object is fitted with a convenient <code>apply</code> method to obtain an instance of the type class.</li> 
  </ul> 
  <div class="highlight highlight-source-scala">
   <pre>    <span class="pl-c"><span class="pl-c">//</span> Equivalent to `implicitly[Monad[Option]]`</span>
    <span class="pl-k">val</span> <span class="pl-en">O</span> <span class="pl-k">=</span> <span class="pl-en">Monad</span>[<span class="pl-en">Option</span>]

    <span class="pl-c"><span class="pl-c">//</span> `bind` is defined with two parameter sections, so that the type of `x` is inferred as `Int`.</span>
    <span class="pl-en">O</span>.bind(<span class="pl-en">Some</span>(<span class="pl-c1">1</span>))(x <span class="pl-k">=&gt;</span> <span class="pl-en">Some</span>(x <span class="pl-k">*</span> <span class="pl-c1">2</span>))

    <span class="pl-k">def</span> <span class="pl-en">plus</span>(<span class="pl-v">a</span>: <span class="pl-k">Int</span>, <span class="pl-v">b</span>: <span class="pl-k">Int</span>) <span class="pl-k">=</span> a <span class="pl-k">+</span> b

    <span class="pl-c"><span class="pl-c">//</span> `Apply#lift2` is a function derived from `Apply#ap`.</span>
    <span class="pl-k">val</span> <span class="pl-en">plusOpt</span> <span class="pl-k">=</span> <span class="pl-en">O</span>.lift2(plus)</pre>
  </div> 
  <h3><a id="user-content-type-class-instance-dependencies" class="anchor" href="https://github.com/scalaz/scalaz#type-class-instance-dependencies" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Type Class Instance Dependencies</h3> 
  <p>Type class instances may depend on other instances. In simple cases, this is as straightforward as adding an implicit parameter (or, equivalently, a context bound), to the implicit method.</p> 
  <div class="highlight highlight-source-scala">
   <pre>  <span class="pl-k">implicit</span> <span class="pl-k">def</span> <span class="pl-en">optionMonoid</span>[<span class="pl-en">A</span><span class="pl-k">:</span> <span class="pl-en">Semigroup</span>]<span class="pl-k">:</span> <span class="pl-en">Monoid</span>[<span class="pl-en">Option</span>[<span class="pl-en">A</span>]] <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Monoid</span>[<span class="pl-en">Option</span>[<span class="pl-en">A</span>]] {
    <span class="pl-k">def</span> <span class="pl-en">append</span>(<span class="pl-v">f1</span>: <span class="pl-en">Option</span>[<span class="pl-en">A</span>], <span class="pl-v">f2</span>: <span class="pl-k">=&gt;</span> <span class="pl-en">Option</span>[<span class="pl-en">A</span>])<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> (f1, f2) <span class="pl-k">match</span> {
      <span class="pl-k">case</span> (<span class="pl-en">Some</span>(a1), <span class="pl-en">Some</span>(a2)) <span class="pl-k">=&gt;</span> <span class="pl-en">Some</span>(<span class="pl-en">Semigroup</span>[<span class="pl-en">A</span>].append(a1, a2))
      <span class="pl-k">case</span> (<span class="pl-en">Some</span>(a1), <span class="pl-c1">None</span>) <span class="pl-k">=&gt;</span> f1
      <span class="pl-k">case</span> (<span class="pl-c1">None</span>, <span class="pl-en">Some</span>(a2)) <span class="pl-k">=&gt;</span> f2
      <span class="pl-k">case</span> (<span class="pl-c1">None</span>, <span class="pl-c1">None</span>) <span class="pl-k">=&gt;</span> <span class="pl-c1">None</span>
    }

    <span class="pl-k">def</span> <span class="pl-en">zero</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> <span class="pl-c1">None</span>
  }</pre>
  </div> 
  <p>Type class instances for 'transformers', such as <code>OptionT</code>, present a more subtle challenge. <code>OptionT[F, A]</code> is a wrapper for a value of type <code>F[Option[A]]</code>. It allows us to write:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">ot</span> <span class="pl-k">=</span> <span class="pl-en">OptionT</span>(<span class="pl-en">List</span>(<span class="pl-en">Some</span>(<span class="pl-c1">1</span>), <span class="pl-c1">None</span>))
ot.map((<span class="pl-v">a</span>: <span class="pl-k">Int</span>) <span class="pl-k">=&gt;</span> a <span class="pl-k">*</span> <span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">//</span> OptionT(List(Some(2), None))</span></pre>
  </div> 
  <p>The method <code>OptionT#map</code> requires an implicit parameter of type <code>Functor[F]</code>, whereas <code>OptionT#flatMap</code> requires one of type <code>Monad[F]</code>. The capabilities of <code>OptionT</code> increase with those of <code>F</code>. We need to encode this into the type class instances for <code>[a]OptionT[F[A]]</code>.</p> 
  <p>This is done with a hierarchy of <a href="https://github.com/scalaz/scalaz/blob/v7.1.2/core/src/main/scala/scalaz/OptionT.scala#L122" target="_blank">type class implementation traits</a> and a corresponding set of <a href="https://github.com/scalaz/scalaz/blob/v7.1.2/core/src/main/scala/scalaz/OptionT.scala#L24" target="_blank">prioritized implicit methods</a>.</p> 
  <p>In case of ambiguous implicits, Scala will favour one defined in a sub-class of the other. This is to avoid ambiguity when in cases like the following:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">type</span> <span class="pl-en">OptionTList</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> <span class="pl-en">OptionT</span>[<span class="pl-en">List</span>[<span class="pl-en">A</span>]]
implicitly[<span class="pl-en">Functor</span>[<span class="pl-en">OptionTList</span>]]

<span class="pl-c"><span class="pl-c">//</span> Candidates:</span>
<span class="pl-c"><span class="pl-c">//</span> 1. OptionT.OptionTFunctor[List](implicitly[Functor[List]])</span>
<span class="pl-c"><span class="pl-c">//</span> 2. OptionT.OptionTMonad[List](implicitly[Functor[List]])</span>
<span class="pl-c"><span class="pl-c">//</span> #2 is defined in a subclass of the enclosing class of #1, so #2 is preferred.</span></pre>
  </div> 
  <h3><a id="user-content-transformers-and-identity" class="anchor" href="https://github.com/scalaz/scalaz#transformers-and-identity" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Transformers and Identity</h3> 
  <p>A stronger emphasis has been placed on transformer data structures (aka Monad Transformers). For example <code>State</code> is now a type alias for <code>StateT[Id, A, B]</code>.</p> 
  <p><code>Id</code> is defined in the <code>scalaz</code> package object as:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">type</span> <span class="pl-en">Id</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> <span class="pl-en">A</span></pre>
  </div> 
  <h2><a id="user-content-contributing" class="anchor" href="https://github.com/scalaz/scalaz#contributing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Contributing</h2> 
  <p><a href="https://github.com/scalaz/scalaz/blob/series/7.3.x/CONTRIBUTING.md" target="_blank">Documentation for contributors</a></p> 
  <h2><a id="user-content-credits" class="anchor" href="https://github.com/scalaz/scalaz#credits" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Credits</h2> 
  <p>Support for Scalaz development is provided by <a href="http://www.jetbrains.com/idea/" target="_blank">Jetbrains</a>.</p> 
  <p>Thanks to Mark Harrah and the sbt contributors for providing <a href="http://www.scala-sbt.org" target="_blank">our build tool</a>.</p> 
 </article>
</div>
{
  "data":{
    "repository":{
      "issues":{
        "nodes":[
          {
            "number":561,
            "title":"NPE when encoding and decoding nested case class",
            "bodyText":"Hi, I have a case class where one of the fields is referencing another object of the same type.\nWhen I try to decode[NestedClass](str), it throws an NPE. Same when I try to encode to Json.\nI'm using circe version 0.7.0 with scala 2.12.\nHere is an simple example:\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\n\nobject NestedExample {\n  case class NestedClass(id: Long, displayName: String, nesting: Option[NestedClass])\n\n  implicit val nestedClassDecoder: Decoder[NestedClass] =\n    Decoder.forProduct3(\"id\", \"display_name\", \"nesting\")(NestedClass.apply)\n\n  implicit val nestedClassEncoder: Encoder[NestedClass] =\n    Encoder.forProduct3(\"id\", \"display_name\", \"nesting\") { nc =>\n      (nc.id, nc.displayName, nc.nesting)\n    }\n\n  def main(args: Array[String]): Unit = {\n    val testString =\n      \"\"\"\n        |{\n        |  \"id\": 10000,\n        |  \"display_name\": \"foobar\",\n        |  \"nesting\": {\n        |    \"id\": 10001,\n        |    \"display_name\": \"quux\"\n        |  }\n        |}\n      \"\"\".stripMargin\n\n    val errorOrNesting = decode[NestedClass](testString) // NPE\n\n    val inner: NestedClass = NestedClass(10001L, \"inner\", None)\n    val outer: NestedClass = NestedClass(10000L, \"outer\", Some(inner))\n    println(outer.asJson.spaces2) // NPE\n  }\n}\nStacktrace when decoding\nException in thread \"main\" java.lang.NullPointerException\n\tat io.circe.Decoder$.$anonfun$decodeOption$1(Decoder.scala:623)\n\tat io.circe.Decoder$$anon$27.tryDecode(Decoder.scala:312)\n\tat io.circe.ACursor.as(ACursor.scala:336)\n\tat io.circe.ACursor.get(ACursor.scala:343)\n\tat io.circe.ProductDecoders$$anon$3.apply(ProductDecoders.scala:36)\n\tat io.circe.Decoder.decodeJson(Decoder.scala:48)\n\tat io.circe.Decoder.decodeJson$(Decoder.scala:48)\n\tat io.circe.ProductDecoders$$anon$3.decodeJson(ProductDecoders.scala:35)\n\tat io.circe.Parser.finishDecode(Parser.scala:11)\n\tat io.circe.Parser.finishDecode$(Parser.scala:8)\n\tat io.circe.parser.package$.finishDecode(package.scala:5)\n\tat io.circe.Parser.decode(Parser.scala:25)\n\tat io.circe.Parser.decode$(Parser.scala:24)\n\tat io.circe.parser.package$.decode(package.scala:5)\n\tat com.marcoy.circe.nested.NestedExample$.main(NestedExample.scala:32)\n\tat com.marcoy.circe.nested.NestedExample.main(NestedExample.scala)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)\n\nStacktrace when encoding\nException in thread \"main\" java.lang.NullPointerException\n\tat io.circe.Encoder$$anon$28.apply(Encoder.scala:215)\n\tat io.circe.Encoder$$anon$28.apply(Encoder.scala:213)\n\tat io.circe.ProductEncoders$$anon$3.encodeObject(ProductEncoders.scala:38)\n\tat io.circe.ObjectEncoder.apply(ObjectEncoder.scala:13)\n\tat io.circe.ObjectEncoder.apply$(ObjectEncoder.scala:13)\n\tat io.circe.ProductEncoders$$anon$3.apply(ProductEncoders.scala:35)\n\tat io.circe.syntax.package$EncoderOps$.asJson$extension(package.scala:8)\n\tat com.marcoy.circe.nested.NestedExample$.main(NestedExample.scala:36)\n\tat com.marcoy.circe.nested.NestedExample.main(NestedExample.scala)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)",
            "url":"https://github.com/circe/circe/issues/561"
          },
          {
            "number":630,
            "title":"Make Encoder.forProductN methods actually use\u2026 ProductN",
            "bodyText":"Currently all the Encoder.forProductN methods take a function from the type that we're defining an Encoder for to a tuple with the appropriate arity. I don't see any reason not to allow the more general Source => ProductN[...], which would make definitions simpler for case classes (no more (User.unapply _).andThen(_.get) stuff) and would also help with e.g. Scrooge-generated types.",
            "url":"https://github.com/circe/circe/issues/630"
          }
        ]
      }
    }
  }
}
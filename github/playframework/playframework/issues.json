{
  "data":{
    "repository":{
      "issues":{
        "nodes":[
          {
            "number":2581,
            "title":"Support SLF4J Mapped Diagnostic Context (MDC) on internal server error",
            "bodyText":"On this code the internal server errors are logged, before displaying an html error page (that is customizable)\nplay.api.Application#handleError\n  /**\n   * Handle a runtime error during the execution of an action\n   */\n  private[play] def handleError(request: RequestHeader, e: Throwable): Future[SimpleResult] = try {\n    e match {\n      case e: UsefulException => throw e\n      case e: Throwable => {\n\n        val source = sources.flatMap(_.sourceFor(e))\n\n        throw new PlayException.ExceptionSource(\n          \"Execution exception\",\n          \"[%s: %s]\".format(e.getClass.getSimpleName, e.getMessage),\n          e) {\n          def line = source.flatMap(_._2).map(_.asInstanceOf[java.lang.Integer]).orNull\n          def position = null\n          def input = source.map(_._1).map(scalax.file.Path(_).string).orNull\n          def sourceName = source.map(_._1.getAbsolutePath).orNull\n        }\n      }\n    }\n  } catch {\n    case NonFatal(e) => try {\n      Logger.error(\n        \"\"\"\n        |\n        |! %sInternal server error, for (%s) [%s] ->\n        |\"\"\".stripMargin.format(e match {\n          case p: PlayException => \"@\" + p.id + \" - \"\n          case _ => \"\"\n        }, request.method, request.uri),\n        e\n      )\n      global.onError(request, e)\n    } catch {\n      case NonFatal(e) => DefaultGlobal.onError(request, e)\n    }\n  }\nThe matter is that it seems impossible to me to be able to attach an MDC value to this log statement.\nTypically I want to be able to attach each technical error to a given user if the request is bound to an applicative user.\nThis forces me to log the same error another time in the Global callback:\n  override def onError(request: RequestHeader, ex: Throwable): Future[SimpleResult] = {\n    val mdcUser: Option[User] = ex match {\n      case RuntimeExceptionForStampleUser.InCausalChainExtractor(user, cause) => Some(user)\n      case _ => None\n    }\n\n    mdcUser.foreach(u => MDC.put(\"username\", u.username))\n    Logger.error(\"Internal server error:\", ex)\n    mdcUser.foreach(u => MDC.remove(\"username\"))\n\n    super.onError(request, ex)\n  }\nIs there any alternative?",
            "url":"https://github.com/playframework/playframework/issues/2581"
          },
          {
            "number":5172,
            "title":"Improve field constructor documentation",
            "bodyText":"The custom field constructor documentation neglects to say where you should (or can) put the field constructor template.  The answer is of course anywhere, but I think it would be good if the documentation suggested a filename relative to the project directory, both for the field constructor and the MyHelpers object, and a little explanation around choosing the location of the file and what would need to change if you used a different location would be good.",
            "url":"https://github.com/playframework/playframework/issues/5172"
          },
          {
            "number":5275,
            "title":"Provide helper method to parse json requests",
            "bodyText":"Right now to get the value of a JSON request you need to do:\nJson.fromJson(request().body().asJson(), Pet.class)\n\nIt seems like it'd be simpler to have a method that was something a bit more like:\nrequest().body().asJson(Pet.class)",
            "url":"https://github.com/playframework/playframework/issues/5275"
          },
          {
            "number":5546,
            "title":"[feature] Create JUnit matchers for CompletionStage, Future, Optional",
            "bodyText":"It would help with writing Java tests to have some matchers for Java 8 types. I don't think they're in JUnit or Hamcrest yet.\nE.g.\nassertThat(completionStage, futureValue(is(3)));\nassertThat(future, futureValue(is(3)));\nassertThat(optional, isEmpty());\nassertThat(optional, hasValue(\"x\"));",
            "url":"https://github.com/playframework/playframework/issues/5546"
          },
          {
            "number":5957,
            "title":"Mention scala-guice helpers in docs",
            "bodyText":"There are a few libraries with Scala DSLs for guice like https://github.com/codingwell/scala-guice. Would be good to mention some or all of them in the docs.",
            "url":"https://github.com/playframework/playframework/issues/5957"
          },
          {
            "number":6412,
            "title":"playGenerateSecret Shows No Output if logLevel := Level.Warn",
            "bodyText":"The playGenerateSecret output should not be sent to a logger. Instead, playGenerateSecret should send output to the default output mechanisms for SBT tasks.",
            "url":"https://github.com/playframework/playframework/issues/6412"
          },
          {
            "number":6573,
            "title":"[doc] Include examples of implicit request in Action documentation",
            "bodyText":"Play Version (2.5.x / etc)\ncurrent\nExpected Behavior\nThe Play documentation does not go far enough in pushing the importance of an implicit request in an action.  See #6428 for CSRF for example, and likewise Form processing and template handling is impractical without an implicit request.\nThe following pages should include references to implicit request:\n\nScalaActions\nScalaAsync\nScalaTemplates\nJavaTemplates",
            "url":"https://github.com/playframework/playframework/issues/6573"
          },
          {
            "number":6935,
            "title":"Functional test doc recommends using deprecated method",
            "bodyText":"This page https://www.playframework.com/documentation/2.5.x/JavaFunctionalTest contains the following code snippet under Creating Application instances for testing:\nApplication fakeAppWithGlobal = fakeApplication(new GlobalSettings() { ... });\nBut Helpers.fakeApplication(GlobalSettings) is deprecated.\nOn a related topic, should all of the variants of the Helpers.fakeApplication() method be deprecated?  They all  create FakeApplication objects and the FakeApplication class itself is deprecated.",
            "url":"https://github.com/playframework/playframework/issues/6935"
          },
          {
            "number":7009,
            "title":"Javadoc for AkkaGuiceSupport has incorrect example code",
            "bodyText":"See https://playframework.com/documentation/2.5.12/api/java/play/libs/akka/AkkaGuiceSupport.html#bindActorFactory-java.lang.Class-java.lang.Class-. sender().send should be sender().tell and the call to injectedChild doesn't make sense. We have a correct example here: https://www.playframework.com/documentation/2.5.x/JavaAkka#Dependency-injecting-child-actors",
            "url":"https://github.com/playframework/playframework/issues/7009"
          },
          {
            "number":7105,
            "title":"Stop exposing implementation data on 404 errors",
            "bodyText":"When no route matches, you get a page with play logo displayed.\nExposing the site was built using play framework is not ideal form the security standpoint.",
            "url":"https://github.com/playframework/playframework/issues/7105"
          },
          {
            "number":7417,
            "title":"DefaultHttpErrorHandler should expose throwableToUsefulException method as protected scope",
            "bodyText":"Are you looking for help?\nNo. Filing an enhancement request.\nPlay Version (2.5.x / etc)\n2.5.x and master\nAPI (Scala / Java / Neither / Both)\nJava\nOperating System (Ubuntu 15.10 / MacOS 10.10 / Windows 10)\nAll\nJDK (Oracle 1.8.0_72, OpenJDK 1.8.x, Azul Zing)\n1.8\nLibrary Dependencies\nNone\nExpected Behavior\nPlease describe the expected behavior of the issue, starting from the first action.\n\nExtend DefaultHttpErrorHandler.java class for custom error handler.\nWant to use logServerError method of the super, which takes an UsefulException type.\nWant to use the super's utility method throwableToUsefulException to convert it.\n\nActual Behavior\n\nExtended DefaultHttpErrorHandler.java class for custom error handler.\nWanted to use logServerError method of the super, which takes an UsefulException type.\nWanted to use the super's utility method throwableToUsefulException to convert it. Since it's defined as \"private\" scope, I had to reimplement(copy and paste) this in my custom error handler class.\n\nReproducible Test Case\nn/a. This is an enhancement.",
            "url":"https://github.com/playframework/playframework/issues/7417"
          },
          {
            "number":7669,
            "title":"AkkaRequestTimeoutSpec is flaky",
            "bodyText":"I think I've seen this test failing a few times in CI now so here's an issue to track it and make it reliable.\n[error]   x support sub-second timeouts\n[error]    Expected: java.io.IOException. Got nothing (AkkaRequestTimeoutSpec.scala:63)\n\n[error] Failed: Total 752, Failed 1, Errors 0, Passed 735, Skipped 16, Pending 4\n[error] Failed tests:\n[error] \tplay.it.http.AkkaRequestTimeoutSpec\n[error] (Play-Integration-Test/test:test) sbt.TestsFailedException: Tests unsuccessful",
            "url":"https://github.com/playframework/playframework/issues/7669"
          },
          {
            "number":7788,
            "title":"Document usage of List in routes",
            "bodyText":"The docs mention offhand that List[String] is a valid parameter type, but don't say how to use it. I was trying a bunch of stuff like param=a,b,c,d that wasn't working. I finally saw somewhere that suggested the usage might be param=a&param=b&param=c&param=d (note I haven't tried that syntax, so am not 100% certain it works)",
            "url":"https://github.com/playframework/playframework/issues/7788"
          },
          {
            "number":7796,
            "title":"docs say Mockito is included but it's not",
            "bodyText":"This page https://www.playframework.com/documentation/2.6.x/JavaTest states\nThe Mockito library is included in your project build to assist you in using mocks.\nbut this doesn't appear to be true.  I needed to include\n\"org.mockito\" % \"mockito-core\" % \"2.9.0\"\nin the libraryDependencies section of my build.sbt file in order for Mockito classes to be available.",
            "url":"https://github.com/playframework/playframework/issues/7796"
          }
        ]
      }
    }
  }
}
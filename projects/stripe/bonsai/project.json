{
  "organization" : "stripe",
  "repository" : "bonsai",
  "creationDate" : null,
  "githubStatus" : {
    "Ok" : {
      "updateDate" : 1644286373641
    }
  },
  "githubInfo" : {
    "homepage" : null,
    "description" : "Beautiful trees, without the landscaping.                          ",
    "logo" : "https://avatars.githubusercontent.com/u/856813?v=4",
    "stars" : 128,
    "forks" : 14,
    "watchers" : 133,
    "issues" : 3,
    "creationDate" : 1443923677000,
    "readme" : "<div id=\"readme\" class=\"md\" data-path=\"README.md\"><article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><h1 dir=\"auto\"><a id=\"user-content-bonsai\" class=\"anchor\" aria-hidden=\"true\" href=\"#bonsai\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Bonsai</h1>\n<p dir=\"auto\">Beautiful trees, without the landscaping. Bonsai is a Scala library for\ntransforming arbitrary tree structures into read-only versions that take up a\nfraction of the space.</p>\n<h2 dir=\"auto\"><a id=\"user-content-overview\" class=\"anchor\" aria-hidden=\"true\" href=\"#overview\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Overview</h2>\n<p dir=\"auto\">Bonsai compresses trees in 2 ways: by using significantly less space to store\nthe tree structure itself (tree compression), and by encoding the node labels\nin a memory efficient structure (label compression).</p>\n<h3 dir=\"auto\"><a id=\"user-content-what-is-a-tree\" class=\"anchor\" aria-hidden=\"true\" href=\"#what-is-a-tree\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>What is a \"Tree\"?</h3>\n<p dir=\"auto\">Bonsai works over arbitrary trees, so it assumes a fairly generic interface\nfor interacting with trees. In Bonsai a tree;</p>\n<ul dir=\"auto\">\n<li>has 0 or 1 root nodes</li>\n<li>each node has 0 or more children</li>\n<li>each node has a label attached to it</li>\n</ul>\n<p dir=\"auto\">The actual type of the node is unimportant. What is important is the node labels\nand the relationships between the nodes (parent, child, sibling, etc). This\nstructure is enough to describe most of the types of trees you are familiar\nwith.</p>\n<p dir=\"auto\">Bonsai encodes this notion of trees with the <a href=\"https://github.com/stripe/bonsai/blob/master/bonsai-core/src/main/scala/com/stripe/bonsai/TreeOps.scala\">TreeOps type class</a>. Here\nis a truncated version of the type class:</p>\n<div class=\"highlight highlight-source-scala position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"trait TreeOps[Tree, Label] {\n\n  /** The type of the nodes in the tree. */\n  type Node\n\n  /**\n   * Returns the root node of the tree.\n   */\n  def root(t: Tree): Option[Node]\n\n  /**\n   * Returns all the direct children of the given node. The order may or may\n   * not matter. TreeOps does not provide any guarantees here.\n   */\n  def children(node: Node): Iterable[Node]\n\n  /**\n   * Returns the label attached to the given node.\n   */\n  def label(node: Node): Label\n\n  ...\n}\"><pre><span class=\"pl-k\">trait</span> <span class=\"pl-en\">TreeOps</span>[<span class=\"pl-en\">Tree</span>, <span class=\"pl-en\">Label</span>] {\n\n<span class=\"pl-c\">  <span class=\"pl-c\">/**</span> The type of the nodes in the tree. <span class=\"pl-c\">*/</span></span>\n  <span class=\"pl-k\">type</span> <span class=\"pl-en\">Node</span>\n\n<span class=\"pl-c\">  <span class=\"pl-c\">/**</span></span>\n<span class=\"pl-c\">   * Returns the root node of the tree.</span>\n<span class=\"pl-c\">   <span class=\"pl-c\">*/</span></span>\n  <span class=\"pl-k\">def</span> <span class=\"pl-en\">root</span>(<span class=\"pl-v\">t</span>: <span class=\"pl-en\">Tree</span>)<span class=\"pl-k\">:</span> <span class=\"pl-en\">Option</span>[<span class=\"pl-en\">Node</span>]\n\n<span class=\"pl-c\">  <span class=\"pl-c\">/**</span></span>\n<span class=\"pl-c\">   * Returns all the direct children of the given node. The order may or may</span>\n<span class=\"pl-c\">   * not matter. TreeOps does not provide any guarantees here.</span>\n<span class=\"pl-c\">   <span class=\"pl-c\">*/</span></span>\n  <span class=\"pl-k\">def</span> <span class=\"pl-en\">children</span>(<span class=\"pl-v\">node</span>: <span class=\"pl-en\">Node</span>)<span class=\"pl-k\">:</span> <span class=\"pl-en\">Iterable</span>[<span class=\"pl-en\">Node</span>]\n\n<span class=\"pl-c\">  <span class=\"pl-c\">/**</span></span>\n<span class=\"pl-c\">   * Returns the label attached to the given node.</span>\n<span class=\"pl-c\">   <span class=\"pl-c\">*/</span></span>\n  <span class=\"pl-k\">def</span> <span class=\"pl-en\">label</span>(<span class=\"pl-v\">node</span>: <span class=\"pl-en\">Node</span>)<span class=\"pl-k\">:</span> <span class=\"pl-en\">Label</span>\n\n  ...\n}</pre></div>\n<p dir=\"auto\">The type <code>T</code> is our actual tree type. The <code>Node</code> type is the way we reference\ninternal nodes in our tree <code>T</code>. The actual type of <code>Node</code> isn't important,\nhowever, and is mostly an implementation detail. The important bit is the\n<code>Label</code> type, which is the user-facing data associated with each node.</p>\n<p dir=\"auto\">The <code>bonsai-example</code> subproject has <a href=\"https://github.com/stripe/bonsai/blob/master/bonsai-example/src/main/scala/com/stripe/bonsai/example/Huffman.scala\">an example of a Huffman tree</a>.\nA Huffman tree is used to store a Huffman coding for decoding a compressed\nmessage (a bitstring). We decode the bitstring, bit-by-bit, using the tree.</p>\n<p dir=\"auto\">Starting at the root of the tree, we follow the left child if the current bit\nis a 0 and the right child if it is a 1. We continue until reaching a leaf node,\nat which poitn we output the symbol associated with it, then start back at the\nbeginning of the tree.  When we've exhausted the entire bitstring, we'll have\nour decoded message.</p>\n<p dir=\"auto\">Here is how we may implement a Huffman tree in Scala:</p>\n<div class=\"highlight highlight-source-scala position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"sealed trait HuffmanTree[+A]\ncase class Branch[+A](zero: HuffmanTree[A], one: HuffmanTree[A]) extends HuffmanTree[A]\ncase class Leaf[+A](value: A) extends HuffmanTree[A]\"><pre><span class=\"pl-k\">sealed</span> <span class=\"pl-k\">trait</span> <span class=\"pl-en\">HuffmanTree</span>[<span class=\"pl-k\">+</span><span class=\"pl-en\">A</span>]\n<span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">Branch</span>[<span class=\"pl-k\">+</span><span class=\"pl-en\">A</span>](<span class=\"pl-v\">zero</span>: <span class=\"pl-en\">HuffmanTree</span>[<span class=\"pl-en\">A</span>], <span class=\"pl-v\">one</span>: <span class=\"pl-en\">HuffmanTree</span>[<span class=\"pl-en\">A</span>]) <span class=\"pl-k\">extends</span> <span class=\"pl-e\">HuffmanTree</span>[<span class=\"pl-en\">A</span>]\n<span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">Leaf</span>[<span class=\"pl-k\">+</span><span class=\"pl-en\">A</span>](<span class=\"pl-v\">value</span>: <span class=\"pl-en\">A</span>) <span class=\"pl-k\">extends</span> <span class=\"pl-e\">HuffmanTree</span>[<span class=\"pl-en\">A</span>]</pre></div>\n<p dir=\"auto\">And here is how we would implement its <code>TreeOps</code> instance:</p>\n<div class=\"highlight highlight-source-scala position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"import com.stripe.bonsai.TreeOps\n\nobject HuffmanTree {\n  implicit def huffmanTreeOps[A]: TreeOps[HuffmanTree[A], Option[A]] =\n    new TreeOps[HuffmanTree[A], Option[A]] {\n      type Node = HuffmanTree[A]\n\n      def root(tree: HuffmanTree[A]): Option[HuffmanTree[A]] = Some(tree)\n      def children(tree: HuffmanTree[A]): Iterable[HuffmanTree[A]] = tree match {\n        case Branch(l, r) =&gt; l :: r :: Nil\n        case _ =&gt; Nil\n      }\n      def label(tree: HuffmanTree[A]): Option[A] = tree match {\n        case Leaf(value) =&gt; Some(value)\n        case _ =&gt; None\n      }\n    }\n}\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">com</span>.<span class=\"pl-en\">stripe</span>.<span class=\"pl-en\">bonsai</span>.<span class=\"pl-en\">TreeOps</span>\n\n<span class=\"pl-k\">object</span> <span class=\"pl-en\">HuffmanTree</span> {\n  <span class=\"pl-k\">implicit</span> <span class=\"pl-k\">def</span> <span class=\"pl-en\">huffmanTreeOps</span>[<span class=\"pl-en\">A</span>]<span class=\"pl-k\">:</span> <span class=\"pl-en\">TreeOps</span>[<span class=\"pl-en\">HuffmanTree</span>[<span class=\"pl-en\">A</span>], <span class=\"pl-en\">Option</span>[<span class=\"pl-en\">A</span>]] <span class=\"pl-k\">=</span>\n    <span class=\"pl-k\">new</span> <span class=\"pl-en\">TreeOps</span>[<span class=\"pl-en\">HuffmanTree</span>[<span class=\"pl-en\">A</span>], <span class=\"pl-en\">Option</span>[<span class=\"pl-en\">A</span>]] {\n      <span class=\"pl-k\">type</span> <span class=\"pl-en\">Node</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">HuffmanTree</span>[<span class=\"pl-en\">A</span>]\n\n      <span class=\"pl-k\">def</span> <span class=\"pl-en\">root</span>(<span class=\"pl-v\">tree</span>: <span class=\"pl-en\">HuffmanTree</span>[<span class=\"pl-en\">A</span>])<span class=\"pl-k\">:</span> <span class=\"pl-en\">Option</span>[<span class=\"pl-en\">HuffmanTree</span>[<span class=\"pl-en\">A</span>]] <span class=\"pl-k\">=</span> <span class=\"pl-en\">Some</span>(tree)\n      <span class=\"pl-k\">def</span> <span class=\"pl-en\">children</span>(<span class=\"pl-v\">tree</span>: <span class=\"pl-en\">HuffmanTree</span>[<span class=\"pl-en\">A</span>])<span class=\"pl-k\">:</span> <span class=\"pl-en\">Iterable</span>[<span class=\"pl-en\">HuffmanTree</span>[<span class=\"pl-en\">A</span>]] <span class=\"pl-k\">=</span> tree <span class=\"pl-k\">match</span> {\n        <span class=\"pl-k\">case</span> <span class=\"pl-en\">Branch</span>(l, r) <span class=\"pl-k\">=&gt;</span> l <span class=\"pl-k\">::</span> r <span class=\"pl-k\">::</span> <span class=\"pl-en\">Nil</span>\n        <span class=\"pl-k\">case</span> _ <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">Nil</span>\n      }\n      <span class=\"pl-k\">def</span> <span class=\"pl-en\">label</span>(<span class=\"pl-v\">tree</span>: <span class=\"pl-en\">HuffmanTree</span>[<span class=\"pl-en\">A</span>])<span class=\"pl-k\">:</span> <span class=\"pl-en\">Option</span>[<span class=\"pl-en\">A</span>] <span class=\"pl-k\">=</span> tree <span class=\"pl-k\">match</span> {\n        <span class=\"pl-k\">case</span> <span class=\"pl-en\">Leaf</span>(value) <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">Some</span>(value)\n        <span class=\"pl-k\">case</span> _ <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">None</span>\n      }\n    }\n}</pre></div>\n<p dir=\"auto\">As long as we are careful to implement all our operations on a Huffman tree by\nusing its more generic <code>TreeOps</code> interface, rather than <code>HuffmanTree</code> directly,\nwe can then swap out the actual tree data structure, without affecting the code\nusing it.</p>\n<p dir=\"auto\">For example, below we implement a <code>decode</code> operation as an implicit class using just <code>TreeOps</code>.</p>\n<div class=\"highlight highlight-source-scala position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"import scala.collection.immutable.BitSet\n\nimplicit class HuffmanTreeOps[T, A](tree: T)(implicit treeOps: TreeOps[T, Option[A]]) {\n  // Importing treeOps gives us some useful methods on `tree`\n  import treeOps._\n\n  def decode(bits: BitSet, len: Int): Vector[A] = {\n    val root = tree.root.get\n    val (_, result) = (0 until len)\n      .foldLeft((root, Vector.empty[A])) { case ((node, acc), i) =&gt;\n        node.label match {\n          case Some(value) =&gt; (root, acc :+ value)\n          case None if bits(i) =&gt; (node.children.head, acc)\n          case None =&gt; (node.children.iterator.drop(1).next, acc)\n        }\n      }\n    result\n  }\n}\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">scala</span>.<span class=\"pl-en\">collection</span>.<span class=\"pl-en\">immutable</span>.<span class=\"pl-en\">BitSet</span>\n\n<span class=\"pl-k\">implicit</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">HuffmanTreeOps</span>[<span class=\"pl-en\">T</span>, <span class=\"pl-en\">A</span>](<span class=\"pl-v\">tree</span>: <span class=\"pl-en\">T</span>)(<span class=\"pl-k\">implicit</span> <span class=\"pl-v\">treeOps</span>: <span class=\"pl-en\">TreeOps</span>[<span class=\"pl-en\">T</span>, <span class=\"pl-en\">Option</span>[<span class=\"pl-en\">A</span>]]) {\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> Importing treeOps gives us some useful methods on `tree`</span>\n  <span class=\"pl-k\">import</span> <span class=\"pl-en\">treeOps</span>.<span class=\"pl-en\">_</span>\n\n  <span class=\"pl-k\">def</span> <span class=\"pl-en\">decode</span>(<span class=\"pl-v\">bits</span>: <span class=\"pl-en\">BitSet</span>, <span class=\"pl-v\">len</span>: <span class=\"pl-en\">Int</span>)<span class=\"pl-k\">:</span> <span class=\"pl-en\">Vector</span>[<span class=\"pl-en\">A</span>] <span class=\"pl-k\">=</span> {\n    <span class=\"pl-k\">val</span> <span class=\"pl-smi\">root</span> <span class=\"pl-k\">=</span> tree.root.get\n    <span class=\"pl-k\">val</span> (_, result) <span class=\"pl-k\">=</span> (<span class=\"pl-c1\">0</span> until len)\n      .foldLeft((root, <span class=\"pl-en\">Vector</span>.empty[<span class=\"pl-en\">A</span>])) { <span class=\"pl-k\">case</span> ((node, acc), i) <span class=\"pl-k\">=&gt;</span>\n        node.label <span class=\"pl-k\">match</span> {\n          <span class=\"pl-k\">case</span> <span class=\"pl-en\">Some</span>(value) <span class=\"pl-k\">=&gt;</span> (root, acc <span class=\"pl-k\">:</span><span class=\"pl-k\">+</span> value)\n          <span class=\"pl-k\">case</span> <span class=\"pl-en\">None</span> <span class=\"pl-k\">if</span> bits(i) <span class=\"pl-k\">=&gt;</span> (node.children.head, acc)\n          <span class=\"pl-k\">case</span> <span class=\"pl-en\">None</span> <span class=\"pl-k\">=&gt;</span> (node.children.iterator.drop(<span class=\"pl-c1\">1</span>).next, acc)\n        }\n      }\n    result\n  }\n}</pre></div>\n<p dir=\"auto\">The goal of this indirection through <code>TreeOps</code> is to let us use a compressed\nversion of the <code>tree</code> instead of an actual <code>HuffmanTree</code>, which will see below.</p>\n<h3 dir=\"auto\"><a id=\"user-content-tree-compression\" class=\"anchor\" aria-hidden=\"true\" href=\"#tree-compression\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Tree Compression</h3>\n<p dir=\"auto\">Bonsai's tree compression is based off of a <a href=\"https://en.wikipedia.org/wiki/Succinct_data_structure\" title=\"Succinct Data Structures\" rel=\"nofollow\">succinct data structure</a>\nfor binary trees. Bonsai supports k-ary trees by first transforming the\noriginal tree into a <a href=\"https://en.wikipedia.org/wiki/Left-child_right-sibling_binary_tree\" rel=\"nofollow\">left-child right-sibling tree</a>, which\npreserves all the relationships from the original tree, but ensures we have at\nmost 2 children per node. You can read more about the details of the actual\ncompression algorithm used in\n<a href=\"http://www.dcc.uchile.cl/~gnavarro/algoritmos/ps/wea05.pdf\" rel=\"nofollow\">\"Practical Implementation of Rank and Select Queries\"</a>. <strong>The upshot is\nthat we can store the entire structure of a tree in only ~2.73bits per node.</strong>\nThis replaces the normal strategy of using JVM objects for nodes and references\nto store the relationships.</p>\n<p dir=\"auto\">We actually compress trees by transforming them into <a href=\"https://github.com/stripe/bonsai/blob/master/bonsai-core/src/main/scala/com/stripe/bonsai/Tree.scala\">Bonsai <code>Tree</code>s</a>.\nBonsai's <code>Tree</code> constructor takes any arbitrary tree <code>T</code> that has a\n<code>TreeOps[T]</code> available and will return a <a href=\"https://github.com/stripe/bonsai/blob/master/bonsai-core/src/main/scala/com/stripe/bonsai/Tree.scala\"><code>Tree</code></a> with the same structure\nand labels (and <code>Label</code> type) as the original tree. However, the entire\nstructure and labels of the tree will have been compressed, so this new tree\nrequires significantly less space.</p>\n<p dir=\"auto\">In the example in <code>bonsai-example</code>, we use the Huffman encoding described above\nto construct a simple Huffman tree for the printable ASCII characters (0x20 -&gt;\n0x7E) and compress it using Bonsai's <code>Tree</code>. The result is a <strong>11x reduction</strong>\nin memory requirements. Since our <code>decode</code> operation was implemented using\n<code>TreeOps</code>, we can use this compressed tree just as we would've used the\noriginal tree.</p>\n<p dir=\"auto\">This example is a bit contrived, since the trees are small to begin with, but\nyou can imagine that applying this to a large random forest yields great\nresults.</p>\n<h3 dir=\"auto\"><a id=\"user-content-label-compression\" class=\"anchor\" aria-hidden=\"true\" href=\"#label-compression\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Label Compression</h3>\n<p dir=\"auto\">Bonsai provides a <a href=\"https://github.com/stripe/bonsai/blob/master/bonsai-core/src/main/scala/com/stripe/bonsai/Layout.scala\">Layout</a> type class, along with some simple\ncombinators, for describing how to (de)serialize your labels. At the lowest\nlevel are a set of Layout \"primitives\" that can encode simple data types into\ncompact data structures. The combinators then allow more complex structures to\nbe described (tuples, <code>Either</code>, mappings to case classes, etc), without adding\nmuch, if any, overhead.</p>\n<p dir=\"auto\">Here is an example of a <code>Layout</code> for some <code>Widget</code> type we made up:</p>\n<div class=\"highlight highlight-source-scala position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"import com.stripe.bonsai.Layout\n\nsealed trait Widget\ncase class Sprocket(radius: Int, weight: Option[Double]) extends Widget\ncase class Doodad(length: Int, width: Int, weight: Option[Double]) extends Widget\n\nobject Widget {\n  implicit val WidgetLayout: Layout[Widget] = {\n    Layout[Either[(Int, Option[Double]), ((Int, Int), Option[Double])]].transform(\n      {\n        case Left((r, wt)) =&gt; Sprocket(r, wt)\n        case Right(((l, w), wt)) =&gt; Doodad(l, w, wt)\n      },\n      {\n        case Sprocket(r, wt) =&gt; Left((r, wt))\n        case Doodad(l, w, wt) =&gt; Right(((l, w), wt))\n      }\n    )\n  }\n}\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">com</span>.<span class=\"pl-en\">stripe</span>.<span class=\"pl-en\">bonsai</span>.<span class=\"pl-en\">Layout</span>\n\n<span class=\"pl-k\">sealed</span> <span class=\"pl-k\">trait</span> <span class=\"pl-en\">Widget</span>\n<span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">Sprocket</span>(<span class=\"pl-v\">radius</span>: <span class=\"pl-en\">Int</span>, <span class=\"pl-v\">weight</span>: <span class=\"pl-en\">Option</span>[<span class=\"pl-en\">Double</span>]) <span class=\"pl-k\">extends</span> <span class=\"pl-e\">Widget</span>\n<span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">Doodad</span>(<span class=\"pl-v\">length</span>: <span class=\"pl-en\">Int</span>, <span class=\"pl-v\">width</span>: <span class=\"pl-en\">Int</span>, <span class=\"pl-v\">weight</span>: <span class=\"pl-en\">Option</span>[<span class=\"pl-en\">Double</span>]) <span class=\"pl-k\">extends</span> <span class=\"pl-e\">Widget</span>\n\n<span class=\"pl-k\">object</span> <span class=\"pl-en\">Widget</span> {\n  <span class=\"pl-k\">implicit</span> <span class=\"pl-k\">val</span> <span class=\"pl-smi\">WidgetLayout</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Layout</span>[<span class=\"pl-en\">Widget</span>] <span class=\"pl-k\">=</span> {\n    <span class=\"pl-en\">Layout</span>[<span class=\"pl-en\">Either</span>[(<span class=\"pl-en\">Int</span>, <span class=\"pl-en\">Option</span>[<span class=\"pl-en\">Double</span>]), ((<span class=\"pl-en\">Int</span>, <span class=\"pl-en\">Int</span>), <span class=\"pl-en\">Option</span>[<span class=\"pl-en\">Double</span>])]].transform(\n      {\n        <span class=\"pl-k\">case</span> <span class=\"pl-en\">Left</span>((r, wt)) <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">Sprocket</span>(r, wt)\n        <span class=\"pl-k\">case</span> <span class=\"pl-en\">Right</span>(((l, w), wt)) <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">Doodad</span>(l, w, wt)\n      },\n      {\n        <span class=\"pl-k\">case</span> <span class=\"pl-en\">Sprocket</span>(r, wt) <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">Left</span>((r, wt))\n        <span class=\"pl-k\">case</span> <span class=\"pl-en\">Doodad</span>(l, w, wt) <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">Right</span>(((l, w), wt))\n      }\n    )\n  }\n}</pre></div>\n<p dir=\"auto\">You can see the <a href=\"https://github.com/stripe/bonsai/blob/master/bonsai-example/src/main/scala/com/stripe/bonsai/example/Widget.scala\">full Widget code/example</a> in the <code>bonsai-example</code> sub\nproject. In that example, we compress a <code>Vector[Option[Widget]]</code> using the\nlayout and end up with over a <strong>6x reduction</strong> in memory requirements.</p>\n<p dir=\"auto\">Currently, Bonsai focuses mainly on compressing the overhead of the structure\nyour data requires (eg options, eithers, tuples), rather than the data itself.\nThis will likely change in future releases, and we'll support better\ncompression for primitive types, as well as things like dictionary encoding for\nall types.</p>\n<h1 dir=\"auto\"><a id=\"user-content-using-bonsai-in-sbt-or-maven\" class=\"anchor\" aria-hidden=\"true\" href=\"#using-bonsai-in-sbt-or-maven\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Using Bonsai in SBT or Maven</h1>\n<p dir=\"auto\">Bonsai is published on sonatype. To use it in your SBT project, you can add the\nfollowing to your <code>build.sbt</code>:</p>\n<div class=\"highlight highlight-source-scala position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"libraryDependencies += &quot;com.stripe&quot; %% &quot;bonsai&quot; % &quot;0.3.0&quot;\"><pre>libraryDependencies <span class=\"pl-k\">+</span><span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>com.stripe<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">%%</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>bonsai<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">%</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>0.3.0<span class=\"pl-pds\">\"</span></span></pre></div>\n<h1 dir=\"auto\"><a id=\"user-content-miscellaneous\" class=\"anchor\" aria-hidden=\"true\" href=\"#miscellaneous\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Miscellaneous</h1>\n<p dir=\"auto\">Bonsai is Open Source and available under the MIT License.</p>\n<p dir=\"auto\">For more help, feel free to contact the authors or create an issue.</p>\n</article></div>",
    "contributors" : [
      {
        "login" : "thomas-stripe",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/23123246?v=4",
        "url" : "https://api.github.com/users/thomas-stripe",
        "contributions" : 50
      },
      {
        "login" : "erik-stripe",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/16106269?v=4",
        "url" : "https://api.github.com/users/erik-stripe",
        "contributions" : 16
      },
      {
        "login" : "travisbrown-stripe",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/28275810?v=4",
        "url" : "https://api.github.com/users/travisbrown-stripe",
        "contributions" : 15
      },
      {
        "login" : "tixxit",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/120314?v=4",
        "url" : "https://api.github.com/users/tixxit",
        "contributions" : 7
      },
      {
        "login" : "gkk-stripe",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/24235374?v=4",
        "url" : "https://api.github.com/users/gkk-stripe",
        "contributions" : 4
      },
      {
        "login" : "aegarbutt-stripe",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/80711584?v=4",
        "url" : "https://api.github.com/users/aegarbutt-stripe",
        "contributions" : 1
      },
      {
        "login" : "jhoon-stripe",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/23085125?v=4",
        "url" : "https://api.github.com/users/jhoon-stripe",
        "contributions" : 1
      },
      {
        "login" : "leanne-stripe",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/87873932?v=4",
        "url" : "https://api.github.com/users/leanne-stripe",
        "contributions" : 1
      }
    ],
    "commits" : 95,
    "topics" : [
    ],
    "contributingGuide" : null,
    "codeOfConduct" : null,
    "chatroom" : null,
    "openIssues" : [
      {
        "number" : 11,
        "title" : "Consider variance",
        "url" : "https://github.com/stripe/bonsai/issues/11"
      },
      {
        "number" : 9,
        "title" : "Consider removing implicit/default Layouts",
        "url" : "https://github.com/stripe/bonsai/issues/9"
      },
      {
        "number" : 1,
        "title" : "Interleave dictionaries and bits",
        "url" : "https://github.com/stripe/bonsai/issues/1"
      }
    ]
  },
  "settings" : {
    "defaultStableVersion" : true,
    "defaultArtifact" : null,
    "strictVersions" : false,
    "customScalaDoc" : null,
    "documentationLinks" : [
    ],
    "deprecated" : false,
    "contributorsWanted" : false,
    "artifactDeprecations" : [
    ],
    "cliArtifacts" : [
    ],
    "category" : "algorithms-and-data-structures",
    "beginnerIssuesLabel" : null
  }
}
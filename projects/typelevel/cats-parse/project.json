{
  "organization" : "typelevel",
  "repository" : "cats-parse",
  "creationDate" : 1604112872000,
  "githubStatus" : {
    "Ok" : {
      "updateDate" : 1730781419038
    }
  },
  "githubInfo" : {
    "homepage" : "https://typelevel.org/cats-parse/",
    "description" : "A parsing library for the cats ecosystem",
    "logo" : "https://avatars.githubusercontent.com/u/3731824?v=4",
    "stars" : 233,
    "forks" : 53,
    "watchers" : 16,
    "issues" : 27,
    "creationDate" : 1604094804000,
    "readme" : "<div id=\"readme\" class=\"md\" data-path=\"README.md\"><article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><div class=\"markdown-heading\" dir=\"auto\"><h1 class=\"heading-element\" dir=\"auto\">cats-parse</h1><a id=\"user-content-cats-parse\" class=\"anchor\" aria-label=\"Permalink: cats-parse\" href=\"#cats-parse\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><a href=\"https://github.com/typelevel/cats-parse/actions?query=workflow%3A%22Continuous+Integration%22\"><img src=\"https://github.com/typelevel/cats-parse/workflows/Continuous%20Integration/badge.svg\" alt=\"Continuous Integration\" style=\"max-width: 100%;\"></a><a href=\"https://codecov.io/gh/typelevel/cats-parse\" rel=\"nofollow\"><img src=\"https://camo.githubusercontent.com/b2c28a35eebac336c183a04b027d82245dceb3f55fc4509124de599aa084f47a/68747470733a2f2f636f6465636f762e696f2f67682f747970656c6576656c2f636174732d70617273652f6272616e63682f6d61696e2f67726170682f62616467652e737667\" alt=\"codecov\" data-canonical-src=\"https://codecov.io/gh/typelevel/cats-parse/branch/main/graph/badge.svg\" style=\"max-width: 100%;\"></a></p>\n<p dir=\"auto\">A parsing library for the cats ecosystem.</p>\n<p dir=\"auto\">To use in sbt add, the following to your <code>libraryDependencies</code>:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// use this snippet for the JVM\nlibraryDependencies += &quot;org.typelevel&quot; %% &quot;cats-parse&quot; % &quot;0.3.9&quot;\n\n// use this snippet for JS, or cross-building\nlibraryDependencies += &quot;org.typelevel&quot; %%% &quot;cats-parse&quot; % &quot;0.3.9&quot;\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> use this snippet for the JVM</span>\nlibraryDependencies <span class=\"pl-k\">+</span><span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>org.typelevel<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">%%</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>cats-parse<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">%</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>0.3.9<span class=\"pl-pds\">\"</span></span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> use this snippet for JS, or cross-building</span>\nlibraryDependencies <span class=\"pl-k\">+</span><span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>org.typelevel<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">%%%</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>cats-parse<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">%</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>0.3.9<span class=\"pl-pds\">\"</span></span></pre></div>\n<p dir=\"auto\">The <a href=\"https://javadoc.io/doc/org.typelevel/cats-parse_2.13/0.3.9/cats/parse/index.html\" rel=\"nofollow\">API docs</a> are published.</p>\n<p dir=\"auto\">Why another parsing library? See this <a href=\"https://posco.medium.com/designing-a-parsing-library-in-scala-d5076de52536\" rel=\"nofollow\">blog post detailing the\ndesign</a>. To reiterate,\nthis library has a few goals:</p>\n<ol dir=\"auto\">\n<li>Compatibility: should work on all scala platforms and recent versions. Currently it supports JVM, JS on versions 2.11, 2.12, 2.13, and 3. The core library should have minimal dependencies. Currently this library only depends on cats.</li>\n<li>Excellent performance: should be as fast or faster than any parser combinator that has comparable scala version support.</li>\n<li>Cats friendliness: method names match cats style, and out of the box support for cats typeclasses.</li>\n<li>Precise errors: following the <a href=\"https://hackage.haskell.org/package/trifecta\" rel=\"nofollow\">Haskell Trifecta parsing library</a>, backtracking is opt-in vs opt-out. This design tends to make it easier to write parsers that point correctly to failure points.</li>\n<li>Safety: by separating Parser0, a parser that may consume no input, from Parser, a parser must consume at least one character on success. Most combinators and methods can be made safer to use and less prone to runtime errors.</li>\n<li>Stability: we are very reluctant to break compatibility between versions. We want to put a minimal tax on users to stay on the latest versions.</li>\n</ol>\n<div class=\"markdown-heading\" dir=\"auto\"><h1 class=\"heading-element\" dir=\"auto\">Tutorial</h1><a id=\"user-content-tutorial\" class=\"anchor\" aria-label=\"Permalink: Tutorial\" href=\"#tutorial\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<div class=\"markdown-heading\" dir=\"auto\"><h2 class=\"heading-element\" dir=\"auto\">Simple parser</h2><a id=\"user-content-simple-parser\" class=\"anchor\" aria-label=\"Permalink: Simple parser\" href=\"#simple-parser\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">The library provides a set of simple parsers which might be combined to create any parsing logic. The simplest parser is <code>Parser.anyChar</code> which is successful where there is one char at the input. It has type <code>Parser[Char]</code> which means it returns one parsed char.</p>\n<p dir=\"auto\">To provide any input to parser one need to use <code>parse</code> method.</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import cats.parse.Parser\n\nval p: Parser[Char] = Parser.anyChar\n\np.parse(&quot;t&quot;)\n\np.parse(&quot;&quot;)\n\np.parse(&quot;two&quot;)\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Parser</span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">Char</span>] <span class=\"pl-k\">=</span> <span class=\"pl-en\">Parser</span>.anyChar\n\np.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>t<span class=\"pl-pds\">\"</span></span>)\n\np.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-pds\">\"</span></span>)\n\np.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>two<span class=\"pl-pds\">\"</span></span>)</pre></div>\n<p dir=\"auto\">Notice the return type. <code>Tuple2[String, Char]</code> contains the rest of the input string and one parsed char if parsing was successful. It returns <code>Left</code> with error message if there was some parsing error.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h2 class=\"heading-element\" dir=\"auto\">Mapping output</h2><a id=\"user-content-mapping-output\" class=\"anchor\" aria-label=\"Permalink: Mapping output\" href=\"#mapping-output\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">The output of the parser might be processed with <code>map</code> method:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import cats.parse.Parser\n\ncase class CharWrapper(value: Char)\n\nval p: Parser[CharWrapper] = Parser.anyChar.map(char =&gt; CharWrapper(char))\n\np.parse(&quot;t&quot;)\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Parser</span>\n\n<span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">CharWrapper</span>(<span class=\"pl-v\">value</span>: <span class=\"pl-en\">Char</span>)\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">CharWrapper</span>] <span class=\"pl-k\">=</span> <span class=\"pl-en\">Parser</span>.anyChar.map(char <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">CharWrapper</span>(char))\n\np.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>t<span class=\"pl-pds\">\"</span></span>)</pre></div>\n<p dir=\"auto\">There are built-in methods for mapping the output to types <code>String</code> or <code>Unit</code>:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import cats.parse.Rfc5234.digit\nimport cats.parse.Parser\n\n/* String */\n\nval p2: Parser[String] = digit.map((c: Char) =&gt; c.toString)\n// is analog to\nval p3: Parser[String] = digit.string\n\np3.parse(&quot;1&quot;)\n\n/* Unit */\n\nval p4: Parser[Unit] = digit.map(_ =&gt; ())\n// is analog to\nval p5: Parser[Unit] = digit.void\n\np5.parse(&quot;1&quot;)\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Rfc5234</span>.<span class=\"pl-en\">digit</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Parser</span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">/*</span> String <span class=\"pl-c\">*/</span></span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p2</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">String</span>] <span class=\"pl-k\">=</span> digit.map((<span class=\"pl-v\">c</span>: <span class=\"pl-en\">Char</span>) <span class=\"pl-k\">=&gt;</span> c.toString)\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> is analog to</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p3</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">String</span>] <span class=\"pl-k\">=</span> digit.string\n\np3.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>1<span class=\"pl-pds\">\"</span></span>)\n\n<span class=\"pl-c\"><span class=\"pl-c\">/*</span> Unit <span class=\"pl-c\">*/</span></span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p4</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">Unit</span>] <span class=\"pl-k\">=</span> digit.map(_ <span class=\"pl-k\">=&gt;</span> ())\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> is analog to</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p5</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">Unit</span>] <span class=\"pl-k\">=</span> digit.void\n\np5.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>1<span class=\"pl-pds\">\"</span></span>)</pre></div>\n<div class=\"markdown-heading\" dir=\"auto\"><h2 class=\"heading-element\" dir=\"auto\">Combining parsers</h2><a id=\"user-content-combining-parsers\" class=\"anchor\" aria-label=\"Permalink: Combining parsers\" href=\"#combining-parsers\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">The parsers might be combined through operators:</p>\n<ul dir=\"auto\">\n<li><code>~</code> - product. Allows continuing parsing if the left side was successful;</li>\n<li><code>&lt;*</code>, <code>*&gt;</code> - productL and productR. Works just like product but drop part of result;</li>\n<li><code>surroundedBy</code> - identical to <code>border *&gt; parsingResult &lt;* border</code>;</li>\n<li><code>between</code> - identical to <code>border1 *&gt; parsingResult &lt;* border2</code>;</li>\n<li><code>|</code>, <code>orElse</code>. Parser will be successful if any of sides is successful.</li>\n</ul>\n<p dir=\"auto\">For this example we'll be using <code>cats.parse.Rfc5234</code> package which contains such parsers as <code>alpha</code> (Latin alphabet) and <code>sp</code> (whitespace).</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import cats.parse.Rfc5234.{sp, alpha, digit}\nimport cats.parse.Parser\n\n/* Product */\n\n// the sp parser won't return the whitespace, it just returns Unit if it successful\nval p1: Parser[(Char, Unit)] = alpha ~ sp\n\np1.parse(&quot;t&quot;)\n\np1.parse(&quot;t &quot;)\n\n\n/* productL, productR */\n\n// The type is just Char because we dropping the space\n// to drop the alphabet change the arrow side: alpha *&gt; sp\nval p2: Parser[Char] = alpha &lt;* sp\n\n// still error since we need the space even if we drop it\np2.parse(&quot;t&quot;)\n\np2.parse(&quot;t &quot;)\n\n\n/* surroundedBy */\n\nval p4: Parser[Char] = sp *&gt; alpha &lt;* sp\nval p5: Parser[Char] = alpha.surroundedBy(sp)\n\np4.parse(&quot; a &quot;)\n\np5.parse(&quot; a &quot;)\n\n\n/* between */\n\nval p6: Parser[Char] = sp *&gt; alpha &lt;* digit\nval p7: Parser[Char] = alpha.between(sp, digit)\n\np6.parse(&quot; a1&quot;)\n\np7.parse(&quot; a1&quot;)\n\n\n/* OrElse */\n\nval p3: Parser[AnyVal] = alpha | sp\n\np3.parse(&quot;t&quot;)\n\np3.parse(&quot; &quot;)\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Rfc5234</span>.{<span class=\"pl-en\">sp</span>, <span class=\"pl-en\">alpha</span>, <span class=\"pl-en\">digit</span>}\n<span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Parser</span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">/*</span> Product <span class=\"pl-c\">*/</span></span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> the sp parser won't return the whitespace, it just returns Unit if it successful</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p1</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[(<span class=\"pl-en\">Char</span>, <span class=\"pl-en\">Unit</span>)] <span class=\"pl-k\">=</span> alpha <span class=\"pl-k\">~</span> sp\n\np1.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>t<span class=\"pl-pds\">\"</span></span>)\n\np1.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>t <span class=\"pl-pds\">\"</span></span>)\n\n\n<span class=\"pl-c\"><span class=\"pl-c\">/*</span> productL, productR <span class=\"pl-c\">*/</span></span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> The type is just Char because we dropping the space</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> to drop the alphabet change the arrow side: alpha *&gt; sp</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p2</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">Char</span>] <span class=\"pl-k\">=</span> alpha <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">*</span> sp\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> still error since we need the space even if we drop it</span>\np2.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>t<span class=\"pl-pds\">\"</span></span>)\n\np2.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>t <span class=\"pl-pds\">\"</span></span>)\n\n\n<span class=\"pl-c\"><span class=\"pl-c\">/*</span> surroundedBy <span class=\"pl-c\">*/</span></span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p4</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">Char</span>] <span class=\"pl-k\">=</span> sp <span class=\"pl-k\">*</span><span class=\"pl-k\">&gt;</span> alpha <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">*</span> sp\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p5</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">Char</span>] <span class=\"pl-k\">=</span> alpha.surroundedBy(sp)\n\np4.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span> a <span class=\"pl-pds\">\"</span></span>)\n\np5.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span> a <span class=\"pl-pds\">\"</span></span>)\n\n\n<span class=\"pl-c\"><span class=\"pl-c\">/*</span> between <span class=\"pl-c\">*/</span></span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p6</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">Char</span>] <span class=\"pl-k\">=</span> sp <span class=\"pl-k\">*</span><span class=\"pl-k\">&gt;</span> alpha <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">*</span> digit\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p7</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">Char</span>] <span class=\"pl-k\">=</span> alpha.between(sp, digit)\n\np6.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span> a1<span class=\"pl-pds\">\"</span></span>)\n\np7.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span> a1<span class=\"pl-pds\">\"</span></span>)\n\n\n<span class=\"pl-c\"><span class=\"pl-c\">/*</span> OrElse <span class=\"pl-c\">*/</span></span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p3</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">AnyVal</span>] <span class=\"pl-k\">=</span> alpha <span class=\"pl-k\">|</span> sp\n\np3.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>t<span class=\"pl-pds\">\"</span></span>)\n\np3.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span> <span class=\"pl-pds\">\"</span></span>)</pre></div>\n<div class=\"markdown-heading\" dir=\"auto\"><h2 class=\"heading-element\" dir=\"auto\">Repeating parsers</h2><a id=\"user-content-repeating-parsers\" class=\"anchor\" aria-label=\"Permalink: Repeating parsers\" href=\"#repeating-parsers\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Sometimes we need something to repeat zero or more times. The cats-parse have <code>rep</code> and <code>rep0</code> methods for repeating values. <code>rep</code> means that the parser must be successful <em>at least one time</em>. <code>rep0</code> means that the parser output might be empty.</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import cats.data.NonEmptyList\nimport cats.parse.Rfc5234.alpha\nimport cats.parse.{Parser, Parser0}\n\nval p1: Parser[NonEmptyList[Char]]  = alpha.rep\nval p2: Parser0[List[Char]] = alpha.rep0\n\np1.parse(&quot;&quot;)\n\np2.parse(&quot;&quot;)\n\np2.parse(&quot;something&quot;)\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">data</span>.<span class=\"pl-en\">NonEmptyList</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Rfc5234</span>.<span class=\"pl-en\">alpha</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.{<span class=\"pl-en\">Parser</span>, <span class=\"pl-en\">Parser0</span>}\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p1</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">NonEmptyList</span>[<span class=\"pl-en\">Char</span>]]  <span class=\"pl-k\">=</span> alpha.rep\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p2</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser0</span>[<span class=\"pl-en\">List</span>[<span class=\"pl-en\">Char</span>]] <span class=\"pl-k\">=</span> alpha.rep0\n\np1.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-pds\">\"</span></span>)\n\np2.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-pds\">\"</span></span>)\n\np2.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>something<span class=\"pl-pds\">\"</span></span>)</pre></div>\n<p dir=\"auto\">Notice the types of parsers. <code>Parser</code> type always means some non-empty output and the output of <code>Parser0</code> might be empty.</p>\n<p dir=\"auto\">One common task in this example is to parse a full line (or words) of text. In the example it is done by <code>rep</code>, and then it could be mapped to <code>String</code> in different ways:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import cats.data.NonEmptyList\nimport cats.parse.Rfc5234.alpha\nimport cats.parse.Parser\n\nval p: Parser[String]  = alpha.rep.map((l: NonEmptyList[Char]) =&gt; l.toList.mkString)\n\nval p2: Parser[String] = alpha.rep.string\nval p3: Parser[String] = alpha.repAs[String]\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">data</span>.<span class=\"pl-en\">NonEmptyList</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Rfc5234</span>.<span class=\"pl-en\">alpha</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Parser</span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">String</span>]  <span class=\"pl-k\">=</span> alpha.rep.map((<span class=\"pl-v\">l</span>: <span class=\"pl-en\">NonEmptyList</span>[<span class=\"pl-en\">Char</span>]) <span class=\"pl-k\">=&gt;</span> l.toList.mkString)\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p2</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">String</span>] <span class=\"pl-k\">=</span> alpha.rep.string\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p3</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">String</span>] <span class=\"pl-k\">=</span> alpha.repAs[<span class=\"pl-en\">String</span>]</pre></div>\n<p dir=\"auto\">All three parsers will be identical in parsing results, but <code>p2</code> and <code>p3</code> are using built-in methods which will not create intermediate list. <code>rep</code> + <code>map</code> creates intermediate list which is mapped to string in this example.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h2 class=\"heading-element\" dir=\"auto\">Parsers with empty output</h2><a id=\"user-content-parsers-with-empty-output\" class=\"anchor\" aria-label=\"Permalink: Parsers with empty output\" href=\"#parsers-with-empty-output\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Some parsers never return a value. They have a type <code>Parser0</code>. One might get this type of parser when using <code>rep0</code> or <code>.?</code> methods.</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import cats.parse.Rfc5234.{alpha, sp}\nimport cats.parse.Parser\n\nval p: Parser[String] = (alpha.rep &lt;* sp.?).rep.string\n\np.parse(&quot;hello world&quot;)\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Rfc5234</span>.{<span class=\"pl-en\">alpha</span>, <span class=\"pl-en\">sp</span>}\n<span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Parser</span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">String</span>] <span class=\"pl-k\">=</span> (alpha.rep <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">*</span> sp.<span class=\"pl-k\">?</span>).rep.string\n\np.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>hello world<span class=\"pl-pds\">\"</span></span>)</pre></div>\n<p dir=\"auto\">Notice the type we got - <code>Parser[String]</code>. That is because we have <code>rep</code> outside and our <code>alpha.rep</code> parser with <code>Parser</code> type is on the left side of the clause. But what if we want to parse strings with spaces at the beginning?</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"val p = (sp.? *&gt; alpha.rep &lt;* sp.?).rep.string\"><pre lang=\"scala:fail\" class=\"notranslate\"><code>val p = (sp.? *&gt; alpha.rep &lt;* sp.?).rep.string\n</code></pre></div>\n<p dir=\"auto\">We will get an error <code>value rep is not a member of cats.parse.Parser0</code>. This happens since we have the left-side parser as optional in <code>sp.? *&gt; alpha.rep &lt;* sp.?</code> clause. This clause has a type <code>Parser0</code> which can't be repeated.</p>\n<p dir=\"auto\">But this parser can't be empty because of <code>alpha.rep</code> parser, and we know it. For these types of parsers we need to use <code>with1</code> wrapper method on the <em>left side</em> of the clause:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import cats.parse.Rfc5234.{alpha, sp}\nimport cats.parse.Parser\n\n\nval p: Parser[String] = (sp.?.with1 *&gt; alpha.rep &lt;* sp.?).rep.string\n\np.parse(&quot;hello world&quot;)\n\np.parse(&quot; hello world&quot;)\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Rfc5234</span>.{<span class=\"pl-en\">alpha</span>, <span class=\"pl-en\">sp</span>}\n<span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Parser</span>\n\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">String</span>] <span class=\"pl-k\">=</span> (sp.<span class=\"pl-k\">?</span>.with1 <span class=\"pl-k\">*</span><span class=\"pl-k\">&gt;</span> alpha.rep <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">*</span> sp.<span class=\"pl-k\">?</span>).rep.string\n\np.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>hello world<span class=\"pl-pds\">\"</span></span>)\n\np.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span> hello world<span class=\"pl-pds\">\"</span></span>)</pre></div>\n<p dir=\"auto\">If we have multiple <code>Parser0</code> parsers before the <code>Parser</code> - we'd need to use parenthesis like this:\n<code>(sp.? ~ sp.?).with1 *&gt; alpha.rep</code>.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h2 class=\"heading-element\" dir=\"auto\">Error handling</h2><a id=\"user-content-error-handling\" class=\"anchor\" aria-label=\"Permalink: Error handling\" href=\"#error-handling\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Parser might be interrupted by parsing error. There are two kinds of errors:</p>\n<ul dir=\"auto\">\n<li>an error that has consumed 0 characters (<strong>epsilon failure</strong>);</li>\n<li>an error that has consumed 1 or more characters (<strong>arresting failure</strong>) (sometimes called halting failure).</li>\n</ul>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import cats.parse.Rfc5234.{alpha, sp}\nimport cats.parse.Parser\n\nval p1: Parser[Char] = alpha\nval p2: Parser[Char] = sp *&gt; alpha\n\n// epsilon failure\np1.parse(&quot;123&quot;)\n\n// arresting failure\np2.parse(&quot; 1&quot;)\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Rfc5234</span>.{<span class=\"pl-en\">alpha</span>, <span class=\"pl-en\">sp</span>}\n<span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Parser</span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p1</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">Char</span>] <span class=\"pl-k\">=</span> alpha\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p2</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser</span>[<span class=\"pl-en\">Char</span>] <span class=\"pl-k\">=</span> sp <span class=\"pl-k\">*</span><span class=\"pl-k\">&gt;</span> alpha\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> epsilon failure</span>\np1.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>123<span class=\"pl-pds\">\"</span></span>)\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> arresting failure</span>\np2.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span> 1<span class=\"pl-pds\">\"</span></span>)</pre></div>\n<p dir=\"auto\">We need to make this difference because the first type of error allows us to say that parser is not matching the input before we started to process it and the second error happens while parser processing the input.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">Backtrack</h3><a id=\"user-content-backtrack\" class=\"anchor\" aria-label=\"Permalink: Backtrack\" href=\"#backtrack\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Backtrack allows us to convert an <em>arresting failure</em> to <em>epsilon failure</em>. It also rewinds the input to the offset to that used before parsing began. The resulting parser might still be combined with others. Let's look at the example:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import cats.parse.Rfc5234.{digit, sp}\n\nval p = sp *&gt; digit &lt;* sp\n\np.parse(&quot; 1&quot;)\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Rfc5234</span>.{<span class=\"pl-en\">digit</span>, <span class=\"pl-en\">sp</span>}\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p</span> <span class=\"pl-k\">=</span> sp <span class=\"pl-k\">*</span><span class=\"pl-k\">&gt;</span> digit <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">*</span> sp\n\np.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span> 1<span class=\"pl-pds\">\"</span></span>)</pre></div>\n<p dir=\"auto\"><code>Parser.Error</code> contains two parameters:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"final case class Error(input: String, failedAtOffset: Int, expected: NonEmptyList[Expectation])\n\ncase class InRange(offset: Int, lower: Char, upper: Char) extends Expectation\"><pre><span class=\"pl-k\">final</span> <span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">Error</span>(<span class=\"pl-v\">input</span>: <span class=\"pl-en\">String</span>, <span class=\"pl-v\">failedAtOffset</span>: <span class=\"pl-en\">Int</span>, <span class=\"pl-v\">expected</span>: <span class=\"pl-en\">NonEmptyList</span>[<span class=\"pl-en\">Expectation</span>])\n\n<span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">InRange</span>(<span class=\"pl-v\">offset</span>: <span class=\"pl-en\">Int</span>, <span class=\"pl-v\">lower</span>: <span class=\"pl-en\">Char</span>, <span class=\"pl-v\">upper</span>: <span class=\"pl-en\">Char</span>) <span class=\"pl-k\">extends</span> <span class=\"pl-en\">Expectation</span></pre></div>\n<p dir=\"auto\">In the error message we see the failed offset and the expected value. There is a lot of expected error types which can be found in source code.</p>\n<p dir=\"auto\">One thing we can do in this situation is providing a fallback parser which can be used in case of error. We can do this by using <code>backtrack</code> (which rewinds the input, so it will be passed to fallback parser as it was before the error) and combining it with <code>orElse</code> operator:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import cats.parse.Rfc5234.{digit, sp}\n\nval p1 = sp *&gt; digit &lt;* sp\nval p2 = sp *&gt; digit\n\np1.backtrack.orElse(p2).parse(&quot; 1&quot;)\n\n(p1.backtrack | p2 ).parse(&quot; 1&quot;)\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Rfc5234</span>.{<span class=\"pl-en\">digit</span>, <span class=\"pl-en\">sp</span>}\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p1</span> <span class=\"pl-k\">=</span> sp <span class=\"pl-k\">*</span><span class=\"pl-k\">&gt;</span> digit <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">*</span> sp\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p2</span> <span class=\"pl-k\">=</span> sp <span class=\"pl-k\">*</span><span class=\"pl-k\">&gt;</span> digit\n\np1.backtrack.orElse(p2).parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span> 1<span class=\"pl-pds\">\"</span></span>)\n\n(p1.backtrack <span class=\"pl-k\">|</span> p2 ).parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span> 1<span class=\"pl-pds\">\"</span></span>)</pre></div>\n<p dir=\"auto\">Notice that <code>(p1.backtrack | p2)</code> clause is another parser by itself since we're still combining parsers by using <code>orElse</code>.</p>\n<p dir=\"auto\">But we've already used <code>orElse</code> in example before without any <code>backtrack</code> operator, and it worked just fine. Why do we need <code>backtrack</code> now? Let's look at this example:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import cats.parse.Rfc5234.{digit, sp}\n\nval p1 = sp *&gt; digit &lt;* sp\nval p2 = sp *&gt; digit\nval p3 = digit\n\n(p1 | p2).parse(&quot; 1&quot;)\n\n(p1 | p2 | p3).parse(&quot;1&quot;)\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Rfc5234</span>.{<span class=\"pl-en\">digit</span>, <span class=\"pl-en\">sp</span>}\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p1</span> <span class=\"pl-k\">=</span> sp <span class=\"pl-k\">*</span><span class=\"pl-k\">&gt;</span> digit <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">*</span> sp\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p2</span> <span class=\"pl-k\">=</span> sp <span class=\"pl-k\">*</span><span class=\"pl-k\">&gt;</span> digit\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p3</span> <span class=\"pl-k\">=</span> digit\n\n(p1 <span class=\"pl-k\">|</span> p2).parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span> 1<span class=\"pl-pds\">\"</span></span>)\n\n(p1 <span class=\"pl-k\">|</span> p2 <span class=\"pl-k\">|</span> p3).parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>1<span class=\"pl-pds\">\"</span></span>)</pre></div>\n<p dir=\"auto\">The first parser combination is interrupted by <em>arresting failures</em> and the second parsing combination will only suffer from <em>epsilon failures</em>. The second parser works because <code>orElse</code> and <code>|</code> operators actually allows recovering from epsilon failures, but not from arresting failures.</p>\n<p dir=\"auto\">So the <code>backtrack</code> helps us where the <em>left side</em> returns arresting failure.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">Soft</h3><a id=\"user-content-soft\" class=\"anchor\" aria-label=\"Permalink: Soft\" href=\"#soft\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">This method might look similar to <code>backtrack</code>, but it allows us to <em>proceed</em> the parsing when the <em>right side</em> is returning an epsilon failure. It is really useful for ambiguous parsers when we can't really tell what exactly we are parsing before the end. Let's say we want to parse some input to the search engine which contains fields. This might look like \"field:search_query\". Let's try to write a parser for this:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import cats.parse.Rfc5234.{alpha, sp}\nimport cats.parse.Parser\nimport cats.parse.Parser.{char =&gt; pchar}\n\nval searchWord = alpha.rep.string\n\nval fieldValue = alpha.rep.string ~ pchar(':')\n\nval p1 = fieldValue.? ~ (searchWord ~ sp.?).rep.string\n\n\np1.parse(&quot;title:The Wind Has Risen&quot;)\n\np1.parse(&quot;The Wind Has Risen&quot;)\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Rfc5234</span>.{<span class=\"pl-en\">alpha</span>, <span class=\"pl-en\">sp</span>}\n<span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Parser</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">Parser</span>.{<span class=\"pl-en\">char</span> <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">pchar</span>}\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">searchWord</span> <span class=\"pl-k\">=</span> alpha.rep.string\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">fieldValue</span> <span class=\"pl-k\">=</span> alpha.rep.string <span class=\"pl-k\">~</span> pchar(<span class=\"pl-s\">':'</span>)\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p1</span> <span class=\"pl-k\">=</span> fieldValue.<span class=\"pl-k\">?</span> <span class=\"pl-k\">~</span> (searchWord <span class=\"pl-k\">~</span> sp.<span class=\"pl-k\">?</span>).rep.string\n\n\np1.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>title:The Wind Has Risen<span class=\"pl-pds\">\"</span></span>)\n\np1.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>The Wind Has Risen<span class=\"pl-pds\">\"</span></span>)</pre></div>\n<p dir=\"auto\">This error happens because we can't really tell if we are parsing the <code>fieldValue</code> before we met a <code>:</code> char. We might do this with by writing two parsers, converting the first one's failure to epsilon failure by <code>backtrack</code> and then providing fallback parser by <code>|</code> operator (which allows the epsilon failures):</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val p2 = fieldValue.? ~ (searchWord ~ sp.?).rep.string\n\nval p3 = (searchWord ~ sp.?).rep.string\n\n(p2.backtrack | p3).parse(&quot;title:The Wind Has Risen&quot;)\n\n(p2.backtrack | p3).parse(&quot;The Wind Has Risen&quot;)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">p2</span> <span class=\"pl-k\">=</span> fieldValue.<span class=\"pl-k\">?</span> <span class=\"pl-k\">~</span> (searchWord <span class=\"pl-k\">~</span> sp.<span class=\"pl-k\">?</span>).rep.string\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p3</span> <span class=\"pl-k\">=</span> (searchWord <span class=\"pl-k\">~</span> sp.<span class=\"pl-k\">?</span>).rep.string\n\n(p2.backtrack <span class=\"pl-k\">|</span> p3).parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>title:The Wind Has Risen<span class=\"pl-pds\">\"</span></span>)\n\n(p2.backtrack <span class=\"pl-k\">|</span> p3).parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>The Wind Has Risen<span class=\"pl-pds\">\"</span></span>)</pre></div>\n<p dir=\"auto\">But this problem might be resolved with <code>soft</code> method inside the first parser since the right side of it actually returns an epsilon failure itself:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val fieldValueSoft = alpha.rep.string.soft ~ pchar(':')\n\nval p4 = fieldValueSoft.? ~ (searchWord ~ sp.?).rep.string\n\np4.parse(&quot;title:The Wind Has Risen&quot;)\n\np4.parse(&quot;The Wind Has Risen&quot;)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">fieldValueSoft</span> <span class=\"pl-k\">=</span> alpha.rep.string.soft <span class=\"pl-k\">~</span> pchar(<span class=\"pl-s\">':'</span>)\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">p4</span> <span class=\"pl-k\">=</span> fieldValueSoft.<span class=\"pl-k\">?</span> <span class=\"pl-k\">~</span> (searchWord <span class=\"pl-k\">~</span> sp.<span class=\"pl-k\">?</span>).rep.string\n\np4.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>title:The Wind Has Risen<span class=\"pl-pds\">\"</span></span>)\n\np4.parse(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>The Wind Has Risen<span class=\"pl-pds\">\"</span></span>)</pre></div>\n<p dir=\"auto\">So when the <em>right side</em> returns an epsilon failure the <code>soft</code> method allows us to rewind parsed input and try to proceed it's parsing with next parsers (without changing the parser itself!).</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h1 class=\"heading-element\" dir=\"auto\">JSON parser example</h1><a id=\"user-content-json-parser-example\" class=\"anchor\" aria-label=\"Permalink: JSON parser example\" href=\"#json-parser-example\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Below is most of a json parser (the string unescaping is elided). This example can give you a feel\nfor what it is like to use this library.</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import cats.parse.strings.Json.delimited.{parser =&gt; jsonString}\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.<span class=\"pl-en\">strings</span>.<span class=\"pl-en\">Json</span>.<span class=\"pl-en\">delimited</span>.{<span class=\"pl-en\">parser</span> <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">jsonString</span>}</pre></div>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import cats.parse.{Parser0, Parser =&gt; P, Numbers}\nimport org.typelevel.jawn.ast._\n\nobject Json {\n  private[this] val whitespace: P[Unit] = P.charIn(&quot; \\t\\r\\n&quot;).void\n  private[this] val whitespaces0: Parser0[Unit] = whitespace.rep0.void\n\n  val parser: P[JValue] = P.recursive[JValue] { recurse =&gt;\n    val pnull = P.string(&quot;null&quot;).as(JNull)\n    val bool = P.string(&quot;true&quot;).as(JBool.True).orElse(P.string(&quot;false&quot;).as(JBool.False))\n    val str = jsonString.map(JString(_))\n    val num = Numbers.jsonNumber.map(JNum(_))\n\n    val listSep: P[Unit] =\n      P.char(',').soft.surroundedBy(whitespaces0).void\n\n    def rep[A](pa: P[A]): Parser0[List[A]] =\n      pa.repSep0(listSep).surroundedBy(whitespaces0)\n\n    val list = rep(recurse).with1\n      .between(P.char('['), P.char(']'))\n      .map { vs =&gt; JArray.fromSeq(vs) }\n\n    val kv: P[(String, JValue)] =\n      jsonString ~ (P.char(':').surroundedBy(whitespaces0) *&gt; recurse)\n\n    val obj = rep(kv).with1\n      .between(P.char('{'), P.char('}'))\n      .map { vs =&gt; JObject.fromSeq(vs) }\n\n    P.oneOf(str :: num :: list :: obj :: bool :: pnull :: Nil)\n  }\n\n  // any whitespace followed by json followed by whitespace followed by end\n  val parserFile: P[JValue] = whitespaces0.with1 *&gt; parser &lt;* (whitespaces0 ~ P.end)\n}\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">parse</span>.{<span class=\"pl-en\">Parser0</span>, <span class=\"pl-en\">Parser</span> <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">P</span>, <span class=\"pl-en\">Numbers</span>}\n<span class=\"pl-k\">import</span> <span class=\"pl-en\">org</span>.<span class=\"pl-en\">typelevel</span>.<span class=\"pl-en\">jawn</span>.<span class=\"pl-en\">ast</span>.<span class=\"pl-en\">_</span>\n\n<span class=\"pl-k\">object</span> <span class=\"pl-en\">Json</span> {\n  <span class=\"pl-k\">private</span>[<span class=\"pl-c1\">this</span>] <span class=\"pl-k\">val</span> <span class=\"pl-v\">whitespace</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">P</span>[<span class=\"pl-en\">Unit</span>] <span class=\"pl-k\">=</span> <span class=\"pl-en\">P</span>.charIn(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span> <span class=\"pl-cce\">\\t\\r\\n</span><span class=\"pl-pds\">\"</span></span>).void\n  <span class=\"pl-k\">private</span>[<span class=\"pl-c1\">this</span>] <span class=\"pl-k\">val</span> <span class=\"pl-v\">whitespaces0</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser0</span>[<span class=\"pl-en\">Unit</span>] <span class=\"pl-k\">=</span> whitespace.rep0.void\n\n  <span class=\"pl-k\">val</span> <span class=\"pl-v\">parser</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">P</span>[<span class=\"pl-en\">JValue</span>] <span class=\"pl-k\">=</span> <span class=\"pl-en\">P</span>.recursive[<span class=\"pl-en\">JValue</span>] { recurse <span class=\"pl-k\">=&gt;</span>\n    <span class=\"pl-k\">val</span> <span class=\"pl-v\">pnull</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">P</span>.string(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>null<span class=\"pl-pds\">\"</span></span>).as(<span class=\"pl-en\">JNull</span>)\n    <span class=\"pl-k\">val</span> <span class=\"pl-v\">bool</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">P</span>.string(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>true<span class=\"pl-pds\">\"</span></span>).as(<span class=\"pl-en\">JBool</span>.<span class=\"pl-en\">True</span>).orElse(<span class=\"pl-en\">P</span>.string(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>false<span class=\"pl-pds\">\"</span></span>).as(<span class=\"pl-en\">JBool</span>.<span class=\"pl-en\">False</span>))\n    <span class=\"pl-k\">val</span> <span class=\"pl-v\">str</span> <span class=\"pl-k\">=</span> jsonString.map(<span class=\"pl-en\">JString</span>(_))\n    <span class=\"pl-k\">val</span> <span class=\"pl-v\">num</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">Numbers</span>.jsonNumber.map(<span class=\"pl-en\">JNum</span>(_))\n\n    <span class=\"pl-k\">val</span> <span class=\"pl-v\">listSep</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">P</span>[<span class=\"pl-en\">Unit</span>] <span class=\"pl-k\">=</span>\n      <span class=\"pl-en\">P</span>.char(<span class=\"pl-s\">','</span>).soft.surroundedBy(whitespaces0).void\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">rep</span>[<span class=\"pl-en\">A</span>](<span class=\"pl-v\">pa</span>: <span class=\"pl-en\">P</span>[<span class=\"pl-en\">A</span>])<span class=\"pl-k\">:</span> <span class=\"pl-en\">Parser0</span>[<span class=\"pl-en\">List</span>[<span class=\"pl-en\">A</span>]] <span class=\"pl-k\">=</span>\n      pa.repSep0(listSep).surroundedBy(whitespaces0)\n\n    <span class=\"pl-k\">val</span> <span class=\"pl-v\">list</span> <span class=\"pl-k\">=</span> rep(recurse).with1\n      .between(<span class=\"pl-en\">P</span>.char(<span class=\"pl-s\">'['</span>), <span class=\"pl-en\">P</span>.char(<span class=\"pl-s\">']'</span>))\n      .map { vs <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">JArray</span>.fromSeq(vs) }\n\n    <span class=\"pl-k\">val</span> <span class=\"pl-v\">kv</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">P</span>[(<span class=\"pl-en\">String</span>, <span class=\"pl-en\">JValue</span>)] <span class=\"pl-k\">=</span>\n      jsonString <span class=\"pl-k\">~</span> (<span class=\"pl-en\">P</span>.char(<span class=\"pl-s\">':'</span>).surroundedBy(whitespaces0) <span class=\"pl-k\">*</span><span class=\"pl-k\">&gt;</span> recurse)\n\n    <span class=\"pl-k\">val</span> <span class=\"pl-v\">obj</span> <span class=\"pl-k\">=</span> rep(kv).with1\n      .between(<span class=\"pl-en\">P</span>.char(<span class=\"pl-s\">'{'</span>), <span class=\"pl-en\">P</span>.char(<span class=\"pl-s\">'}'</span>))\n      .map { vs <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">JObject</span>.fromSeq(vs) }\n\n    <span class=\"pl-en\">P</span>.oneOf(str <span class=\"pl-k\">::</span> num <span class=\"pl-k\">::</span> list <span class=\"pl-k\">::</span> obj <span class=\"pl-k\">::</span> bool <span class=\"pl-k\">::</span> pnull <span class=\"pl-k\">::</span> <span class=\"pl-en\">Nil</span>)\n  }\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> any whitespace followed by json followed by whitespace followed by end</span>\n  <span class=\"pl-k\">val</span> <span class=\"pl-v\">parserFile</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">P</span>[<span class=\"pl-en\">JValue</span>] <span class=\"pl-k\">=</span> whitespaces0.with1 <span class=\"pl-k\">*</span><span class=\"pl-k\">&gt;</span> parser <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">*</span> (whitespaces0 <span class=\"pl-k\">~</span> <span class=\"pl-en\">P</span>.end)\n}</pre></div>\n<div class=\"markdown-heading\" dir=\"auto\"><h1 class=\"heading-element\" dir=\"auto\">Performance</h1><a id=\"user-content-performance\" class=\"anchor\" aria-label=\"Permalink: Performance\" href=\"#performance\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">We have a benchmark suite that compares JSON parsing across several commonly used libraries. A\nrecent (2021/11/05) result is below:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"[info] Benchmark                         Mode  Cnt    Score    Error  Units\n[info] BarBench.catsParseParse           avgt    4   ≈ 10⁻⁴           ms/op\n[info] BarBench.fastparseParse           avgt    4   ≈ 10⁻⁴           ms/op\n[info] BarBench.jawnParse                avgt    4   ≈ 10⁻⁴           ms/op\n[info] BarBench.parboiled2Parse          avgt    4   ≈ 10⁻⁴           ms/op\n[info] BarBench.parsleyParseCold         avgt    4    0.064 ±  0.001  ms/op\n[info] Bla25Bench.catsParseParse         avgt    4   23.095 ±  0.174  ms/op\n[info] Bla25Bench.fastparseParse         avgt    4   15.622 ±  0.414  ms/op\n[info] Bla25Bench.jawnParse              avgt    4    7.501 ±  0.143  ms/op\n[info] Bla25Bench.parboiled2Parse        avgt    4   18.423 ±  6.094  ms/op\n[info] Bla25Bench.parsleyParseCold       avgt    4   30.752 ±  0.279  ms/op\n[info] CountriesBench.catsParseParse     avgt    4    7.169 ±  0.041  ms/op\n[info] CountriesBench.fastparseParse     avgt    4    5.023 ±  0.023  ms/op\n[info] CountriesBench.jawnParse          avgt    4    1.235 ±  0.011  ms/op\n[info] CountriesBench.parboiled2Parse    avgt    4    2.936 ±  0.008  ms/op\n[info] CountriesBench.parsleyParseCold   avgt    4   11.800 ±  0.162  ms/op\n[info] Qux2Bench.catsParseParse          avgt    4    7.031 ±  0.599  ms/op\n[info] Qux2Bench.fastparseParse          avgt    4    6.597 ±  0.031  ms/op\n[info] Qux2Bench.jawnParse               avgt    4    2.227 ±  0.014  ms/op\n[info] Qux2Bench.parboiled2Parse         avgt    4    5.514 ±  0.472  ms/op\n[info] Qux2Bench.parsleyParseCold        avgt    4   10.327 ±  0.293  ms/op\n[info] StringInBenchmarks.oneOfParse     avgt    4   88.105 ±  2.658  ns/op\n[info] StringInBenchmarks.stringInParse  avgt    4  129.246 ±  1.820  ns/op\n[info] Ugh10kBench.catsParseParse        avgt    4   53.679 ±  1.385  ms/op\n[info] Ugh10kBench.fastparseParse        avgt    4   45.165 ±  0.356  ms/op\n[info] Ugh10kBench.jawnParse             avgt    4   11.404 ±  0.068  ms/op\n[info] Ugh10kBench.parboiled2Parse       avgt    4   31.984 ±  0.748  ms/op\n[info] Ugh10kBench.parsleyParseCold      avgt    4   77.150 ±  1.093  ms/op\"><pre class=\"notranslate\"><code>[info] Benchmark                         Mode  Cnt    Score    Error  Units\n[info] BarBench.catsParseParse           avgt    4   ≈ 10⁻⁴           ms/op\n[info] BarBench.fastparseParse           avgt    4   ≈ 10⁻⁴           ms/op\n[info] BarBench.jawnParse                avgt    4   ≈ 10⁻⁴           ms/op\n[info] BarBench.parboiled2Parse          avgt    4   ≈ 10⁻⁴           ms/op\n[info] BarBench.parsleyParseCold         avgt    4    0.064 ±  0.001  ms/op\n[info] Bla25Bench.catsParseParse         avgt    4   23.095 ±  0.174  ms/op\n[info] Bla25Bench.fastparseParse         avgt    4   15.622 ±  0.414  ms/op\n[info] Bla25Bench.jawnParse              avgt    4    7.501 ±  0.143  ms/op\n[info] Bla25Bench.parboiled2Parse        avgt    4   18.423 ±  6.094  ms/op\n[info] Bla25Bench.parsleyParseCold       avgt    4   30.752 ±  0.279  ms/op\n[info] CountriesBench.catsParseParse     avgt    4    7.169 ±  0.041  ms/op\n[info] CountriesBench.fastparseParse     avgt    4    5.023 ±  0.023  ms/op\n[info] CountriesBench.jawnParse          avgt    4    1.235 ±  0.011  ms/op\n[info] CountriesBench.parboiled2Parse    avgt    4    2.936 ±  0.008  ms/op\n[info] CountriesBench.parsleyParseCold   avgt    4   11.800 ±  0.162  ms/op\n[info] Qux2Bench.catsParseParse          avgt    4    7.031 ±  0.599  ms/op\n[info] Qux2Bench.fastparseParse          avgt    4    6.597 ±  0.031  ms/op\n[info] Qux2Bench.jawnParse               avgt    4    2.227 ±  0.014  ms/op\n[info] Qux2Bench.parboiled2Parse         avgt    4    5.514 ±  0.472  ms/op\n[info] Qux2Bench.parsleyParseCold        avgt    4   10.327 ±  0.293  ms/op\n[info] StringInBenchmarks.oneOfParse     avgt    4   88.105 ±  2.658  ns/op\n[info] StringInBenchmarks.stringInParse  avgt    4  129.246 ±  1.820  ns/op\n[info] Ugh10kBench.catsParseParse        avgt    4   53.679 ±  1.385  ms/op\n[info] Ugh10kBench.fastparseParse        avgt    4   45.165 ±  0.356  ms/op\n[info] Ugh10kBench.jawnParse             avgt    4   11.404 ±  0.068  ms/op\n[info] Ugh10kBench.parboiled2Parse       avgt    4   31.984 ±  0.748  ms/op\n[info] Ugh10kBench.parsleyParseCold      avgt    4   77.150 ±  1.093  ms/op\n</code></pre></div>\n<p dir=\"auto\">Note that parboiled and fastparse both use macros that make them very difficult to port to Dotty.\nJawn is a specialized and optimized JSON parser, so that can be considered an upper bound on\nperformance.\nKeep in mind that parser performance depends both on the parsing library but also how the parser\nis written, but these results suggest that this library is already quite competitive.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h1 class=\"heading-element\" dir=\"auto\">Migrating from Fastparse</h1><a id=\"user-content-migrating-from-fastparse\" class=\"anchor\" aria-label=\"Permalink: Migrating from Fastparse\" href=\"#migrating-from-fastparse\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">You should find all the Fastparse methods you are used to. If not, feel free to open an issue.\nThere are a few things to keep in mind:</p>\n<ol dir=\"auto\">\n<li>In fastparse, you wrap a parser in <code>P(...)</code> to make the interior lazy. Following cats, to get a lazily constructed parser use <code>Parser.defer</code> or <code>cats.Defer[Parser].defer</code>.</li>\n<li>In fastparse the <code>~</code> operator does tuple concatenation. This can be nice, but also complex to see what the resulting type is. In cats-parse, <code>~</code> always returns a Tuple2 containing the parsed values from the left and right. To recover fastparse-like behavior, use cats syntax <code>(pa, pb, pc...).tupled</code>.</li>\n<li>In fastparse, backtracking is opt-out by using cuts. In cats-parse, backtracking is opt-in using <code>.backtrack</code>. Put another way, normal product operations in cats-parse are like <code>~/</code> in fastparse.</li>\n<li>In cats-parse, using <code>*&gt;</code>, <code>&lt;*</code>, and <code>.void</code> methods can be a significant optimization: if you don't need a result, communicate that to the library with those methods.</li>\n</ol>\n<div class=\"markdown-heading\" dir=\"auto\"><h1 class=\"heading-element\" dir=\"auto\">Getting and Giving Help</h1><a id=\"user-content-getting-and-giving-help\" class=\"anchor\" aria-label=\"Permalink: Getting and Giving Help\" href=\"#getting-and-giving-help\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">We welcome new contributors and new maintainers. Please feel free to open issues and PRs. If you have any\nproblem using the library, an issue is the best way to ask a question until we flush out more\ndocumentation.</p>\n</article></div>",
    "contributors" : [
      {
        "login" : "scala-steward",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/43047562?v=4",
        "url" : "https://github.com/scala-steward",
        "contributions" : 162
      },
      {
        "login" : "typelevel-steward[bot]",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/3731824?v=4",
        "url" : "https://github.com/apps/typelevel-steward",
        "contributions" : 150
      },
      {
        "login" : "johnynek",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/67958?v=4",
        "url" : "https://github.com/johnynek",
        "contributions" : 73
      },
      {
        "login" : "regadas",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/163899?v=4",
        "url" : "https://github.com/regadas",
        "contributions" : 39
      },
      {
        "login" : "mpilquist",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/118078?v=4",
        "url" : "https://github.com/mpilquist",
        "contributions" : 7
      },
      {
        "login" : "armanbilge",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/3119428?v=4",
        "url" : "https://github.com/armanbilge",
        "contributions" : 5
      },
      {
        "login" : "martijnhoekstra",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/882449?v=4",
        "url" : "https://github.com/martijnhoekstra",
        "contributions" : 5
      },
      {
        "login" : "stephenjudkins",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/8593?v=4",
        "url" : "https://github.com/stephenjudkins",
        "contributions" : 5
      },
      {
        "login" : "rossabaker",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/142698?v=4",
        "url" : "https://github.com/rossabaker",
        "contributions" : 4
      },
      {
        "login" : "Slakah",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/16853?v=4",
        "url" : "https://github.com/Slakah",
        "contributions" : 4
      },
      {
        "login" : "zmccoy",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/280974?v=4",
        "url" : "https://github.com/zmccoy",
        "contributions" : 2
      },
      {
        "login" : "non",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/218045?v=4",
        "url" : "https://github.com/non",
        "contributions" : 2
      },
      {
        "login" : "valencik",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/5440389?v=4",
        "url" : "https://github.com/valencik",
        "contributions" : 2
      },
      {
        "login" : "mio-19",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/57285379?v=4",
        "url" : "https://github.com/mio-19",
        "contributions" : 1
      },
      {
        "login" : "zsluedem",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/13496262?v=4",
        "url" : "https://github.com/zsluedem",
        "contributions" : 1
      },
      {
        "login" : "tmcheung",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/42575345?v=4",
        "url" : "https://github.com/tmcheung",
        "contributions" : 1
      },
      {
        "login" : "xuwei-k",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/389787?v=4",
        "url" : "https://github.com/xuwei-k",
        "contributions" : 1
      },
      {
        "login" : "vaivanov95",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/43709903?v=4",
        "url" : "https://github.com/vaivanov95",
        "contributions" : 1
      },
      {
        "login" : "vasilmkd",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/7115459?v=4",
        "url" : "https://github.com/vasilmkd",
        "contributions" : 1
      },
      {
        "login" : "lenguyenthanh",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/437967?v=4",
        "url" : "https://github.com/lenguyenthanh",
        "contributions" : 1
      },
      {
        "login" : "ghostdogpr",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/7413894?v=4",
        "url" : "https://github.com/ghostdogpr",
        "contributions" : 1
      },
      {
        "login" : "oguzhanunlu",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/4786472?v=4",
        "url" : "https://github.com/oguzhanunlu",
        "contributions" : 1
      },
      {
        "login" : "Odomontois",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/247558?v=4",
        "url" : "https://github.com/Odomontois",
        "contributions" : 1
      },
      {
        "login" : "m-combinator",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/6026368?v=4",
        "url" : "https://github.com/m-combinator",
        "contributions" : 1
      },
      {
        "login" : "morgen-peschke",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/6216438?v=4",
        "url" : "https://github.com/morgen-peschke",
        "contributions" : 1
      },
      {
        "login" : "satabin",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/2537737?v=4",
        "url" : "https://github.com/satabin",
        "contributions" : 1
      },
      {
        "login" : "larsrh",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/923079?v=4",
        "url" : "https://github.com/larsrh",
        "contributions" : 1
      },
      {
        "login" : "VlachJosef",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/5246747?v=4",
        "url" : "https://github.com/VlachJosef",
        "contributions" : 1
      },
      {
        "login" : "hugo-vrijswijk",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/10114577?v=4",
        "url" : "https://github.com/hugo-vrijswijk",
        "contributions" : 1
      },
      {
        "login" : "MasseGuillaume",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/921490?v=4",
        "url" : "https://github.com/MasseGuillaume",
        "contributions" : 1
      },
      {
        "login" : "DenisNovac",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/22966999?v=4",
        "url" : "https://github.com/DenisNovac",
        "contributions" : 1
      },
      {
        "login" : "colin-m-davis",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/63986022?v=4",
        "url" : "https://github.com/colin-m-davis",
        "contributions" : 1
      },
      {
        "login" : "ankitson",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/855649?v=4",
        "url" : "https://github.com/ankitson",
        "contributions" : 1
      },
      {
        "login" : "i10416",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/39330037?v=4",
        "url" : "https://github.com/i10416",
        "contributions" : 1
      }
    ],
    "commits" : 481,
    "topics" : [
    ],
    "contributingGuide" : null,
    "codeOfConduct" : null,
    "openIssues" : [
      {
        "number" : 607,
        "title" : "Not possible to provide own Show[Expectation] without Show[Error]",
        "url" : "https://github.com/typelevel/cats-parse/issues/607"
      },
      {
        "number" : 601,
        "title" : "version in documentation is wrong",
        "url" : "https://github.com/typelevel/cats-parse/issues/601"
      },
      {
        "number" : 558,
        "title" : "investigate scalacheck failure 20231113",
        "url" : "https://github.com/typelevel/cats-parse/issues/558"
      },
      {
        "number" : 508,
        "title" : "investigate scalacheck failure 20230625T112756",
        "url" : "https://github.com/typelevel/cats-parse/issues/508"
      },
      {
        "number" : 494,
        "title" : "set up github CI to run benchmarks on release",
        "url" : "https://github.com/typelevel/cats-parse/issues/494"
      },
      {
        "number" : 395,
        "title" : "flakey test: X cats.parse.ParserTest.a.flatMap(b) composes as expected parser00",
        "url" : "https://github.com/typelevel/cats-parse/issues/395"
      },
      {
        "number" : 391,
        "title" : "Remove isScalaJs/isScalaJvm on minor version update",
        "url" : "https://github.com/typelevel/cats-parse/issues/391"
      },
      {
        "number" : 379,
        "title" : "alternate design for voiding",
        "url" : "https://github.com/typelevel/cats-parse/issues/379"
      },
      {
        "number" : 344,
        "title" : "idea for safe repetition on Parser0",
        "url" : "https://github.com/typelevel/cats-parse/issues/344"
      },
      {
        "number" : 330,
        "title" : "Backtracking with context",
        "url" : "https://github.com/typelevel/cats-parse/issues/330"
      },
      {
        "number" : 285,
        "title" : "set up CI to use latest scala 3 but publish on oldest scala 3",
        "url" : "https://github.com/typelevel/cats-parse/issues/285"
      },
      {
        "number" : 281,
        "title" : "Non-string inputs?",
        "url" : "https://github.com/typelevel/cats-parse/issues/281"
      },
      {
        "number" : 235,
        "title" : "Tuple semigroupal operations on parsers result in the wider Parser0 type - workarounds?",
        "url" : "https://github.com/typelevel/cats-parse/issues/235"
      },
      {
        "number" : 205,
        "title" : "Why is Parser0#repSep not possible?",
        "url" : "https://github.com/typelevel/cats-parse/issues/205"
      },
      {
        "number" : 203,
        "title" : "Different way of combining Parser0 and Parser",
        "url" : "https://github.com/typelevel/cats-parse/issues/203"
      },
      {
        "number" : 185,
        "title" : "add ability to parse substrings",
        "url" : "https://github.com/typelevel/cats-parse/issues/185"
      },
      {
        "number" : 179,
        "title" : "Using cats-parse with Scala string interpolation",
        "url" : "https://github.com/typelevel/cats-parse/issues/179"
      },
      {
        "number" : 131,
        "title" : "It's hard to run targeted tests",
        "url" : "https://github.com/typelevel/cats-parse/issues/131"
      },
      {
        "number" : 18,
        "title" : "test cats laws",
        "url" : "https://github.com/typelevel/cats-parse/issues/18"
      },
      {
        "number" : 7,
        "title" : "set up a documentation site",
        "url" : "https://github.com/typelevel/cats-parse/issues/7"
      }
    ],
    "scalaPercentage" : 100,
    "license" : "MIT",
    "commitActivity" : [
    ]
  },
  "settings" : {
    "preferStableVersion" : true,
    "defaultArtifact" : null,
    "customScalaDoc" : null,
    "documentationLinks" : [
    ],
    "contributorsWanted" : false,
    "deprecatedArtifacts" : [
    ],
    "cliArtifacts" : [
    ],
    "category" : "parsing",
    "chatroom" : null
  }
}
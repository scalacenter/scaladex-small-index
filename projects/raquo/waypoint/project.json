{
  "organization" : "raquo",
  "repository" : "waypoint",
  "creationDate" : 1584309904000,
  "githubStatus" : {
    "Ok" : {
      "updateDate" : 1660791527338
    }
  },
  "githubInfo" : {
    "homepage" : "",
    "description" : "Efficient router for Laminar UI Library",
    "logo" : "https://avatars.githubusercontent.com/u/532656?v=4",
    "stars" : 55,
    "forks" : 9,
    "watchers" : 4,
    "issues" : 1,
    "creationDate" : 1584308905000,
    "readme" : "<div id=\"readme\" class=\"md\" data-path=\"README.md\"><article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><h1 dir=\"auto\"><a id=\"user-content-waypoint\" class=\"anchor\" aria-hidden=\"true\" href=\"#waypoint\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Waypoint</h1>\n<p dir=\"auto\"><a href=\"https://gitter.im/Laminar_/Lobby\" rel=\"nofollow\"><img src=\"https://camo.githubusercontent.com/0c55e0869bebcf250960f636fea95cd0a1ab3e785e202b7b80a476e313d34f8f/68747470733a2f2f6261646765732e6769747465722e696d2f4c616d696e61725f2f4c6f6262792e737667\" alt=\"Join the chat at https://gitter.im/Laminar_/Lobby\" data-canonical-src=\"https://badges.gitter.im/Laminar_/Lobby.svg\" style=\"max-width: 100%;\"></a>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/36003c8df11ac210871844c857a880b0f447a36fb28b42f2823143fbd9c390d7/68747470733a2f2f696d672e736869656c64732e696f2f6d6176656e2d63656e7472616c2f762f636f6d2e726171756f2f776179706f696e745f736a73315f322e31332e737667\"><img src=\"https://camo.githubusercontent.com/36003c8df11ac210871844c857a880b0f447a36fb28b42f2823143fbd9c390d7/68747470733a2f2f696d672e736869656c64732e696f2f6d6176656e2d63656e7472616c2f762f636f6d2e726171756f2f776179706f696e745f736a73315f322e31332e737667\" alt=\"Maven Central\" data-canonical-src=\"https://img.shields.io/maven-central/v/com.raquo/waypoint_sjs1_2.13.svg\" style=\"max-width: 100%;\"></a></p>\n<p dir=\"auto\">Waypoint is an efficient Router for <a href=\"https://github.com/raquo/Laminar\">Laminar</a> using <a href=\"https://github.com/sherpal\">@sherpal</a>'s <a href=\"https://github.com/sherpal/url-dsl\">URL DSL</a> library for URL matching and the browser's <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History\" rel=\"nofollow\">History API</a> for managing URL transitions.</p>\n<p dir=\"auto\">Unlike Laminar itself, Waypoint is quite opinionated, focusing on a specific approach to representing routes that I think works great. <a href=\"https://github.com/tulz-app/frontroute\">Frontroute</a> is another routing alternative.</p>\n<p dir=\"auto\">Waypoint docs are not as exhaustive as Laminar's, but we have examples, and Waypoint is very, very small, so this shouldn't be a big deal. Just make sure you understand how the browser's History API works.</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"&quot;com.raquo&quot; %%% &quot;waypoint&quot; % &quot;0.5.0&quot;   // Requires Airstream 0.14.0 &amp; URL DSL 0.4.0\"><pre class=\"notranslate\"><code>\"com.raquo\" %%% \"waypoint\" % \"0.5.0\"   // Requires Airstream 0.14.0 &amp; URL DSL 0.4.0\n</code></pre></div>\n<h2 dir=\"auto\"><a id=\"user-content-routing-basics\" class=\"anchor\" aria-hidden=\"true\" href=\"#routing-basics\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Routing Basics</h2>\n<p dir=\"auto\">Different libraries use different language to describe the routing problem. The following are high level concepts to get us on the same page (ha!), not specific Scala types.</p>\n<p dir=\"auto\">A <strong>URL</strong> is a well formed web address. The router deals only with URLs from the same origin (i.e. schema + domain + port) because the History API is unable to manage UI state across origins without a page reload.</p>\n<p dir=\"auto\">A <strong>View</strong> is the content that should be rendered based on current <strong>Page</strong>. Typically it's a Laminar <code>ReactiveElement</code>.</p>\n<p dir=\"auto\">A <strong>Page</strong> represents a specific UI State that a <strong>Route</strong> (and therefore a <strong>Router</strong>) can have. It is typically a case class with parameters matching a given Route, such as <code>UserPage(userId: Int)</code>, or simply <code>LoginPage</code>.</p>\n<p dir=\"auto\">A <strong>Pattern</strong> is a construct that can extract a tuple of data from <strong>URLs</strong> and compile a URL from a tuple of data. For example, <code>root / \"user\" / segment[Int] / endOfSegments</code>. In Waypoint, patterns are provided by the <a href=\"https://github.com/sherpal/url-dsl\">URL DSL</a> library.</p>\n<p dir=\"auto\">A <strong>Route</strong> is a class that defines how a class of <strong>Page</strong>s corresponds to a <strong>Pattern</strong>, and how to convert between the two. For example, <code>Route.static(LoginPage, root / \"login\" / endOfSegments)</code>. Routes may be partial, i.e. match only a subset of the Pages in the class.</p>\n<p dir=\"auto\">A <strong>Router</strong> is a class that provides methods to a) set the current <strong>Page</strong> and b) listen to changes in current <strong>Page</strong>. Because a router manages the browser's History API, you typically instantiate only one router per <code>dom.window</code>.</p>\n<h2 dir=\"auto\"><a id=\"user-content-rendering-views\" class=\"anchor\" aria-hidden=\"true\" href=\"#rendering-views\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Rendering Views</h2>\n<p dir=\"auto\">So how do <strong>Views</strong> fit into all of the above? We need to render certain views based on the current page reported by the router. Here's our setup:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"import com.raquo.laminar.api.L\nimport com.raquo.waypoint._\nimport upickle.default._\nimport org.scalajs.dom\n\n\nsealed trait Page\ncase class UserPage(userId: Int) extends Page\ncase object LoginPage extends Page\n\nimplicit val UserPageRW: ReadWriter[UserPage] = macroRW\nimplicit val rw: ReadWriter[Page] = macroRW\n\nval userRoute = Route(\n  encode = userPage =&gt; userPage.userId,\n  decode = arg =&gt; UserPage(userId = arg),\n  pattern = root / &quot;user&quot; / segment[Int] / endOfSegments\n)\nval loginRoute = Route.static(LoginPage, root / &quot;login&quot; / endOfSegments)\n\nval router = new Router[Page](\n  routes = List(userRoute, loginRoute),\n  getPageTitle = _.toString, // mock page title (displayed in the browser tab next to favicon)\n  serializePage = page =&gt; write(page)(rw), // serialize page data for storage in History API log\n  deserializePage = pageStr =&gt; read(pageStr)(rw) // deserialize the above\n)(\n  $popStateEvent = L.windowEvents.onPopState, // this is how Waypoint avoids an explicit dependency on Laminar\n  owner = L.unsafeWindowOwner // this router will live as long as the window\n)\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">com</span>.<span class=\"pl-en\">raquo</span>.<span class=\"pl-en\">laminar</span>.<span class=\"pl-en\">api</span>.<span class=\"pl-en\">L</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-en\">com</span>.<span class=\"pl-en\">raquo</span>.<span class=\"pl-en\">waypoint</span>.<span class=\"pl-en\">_</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-en\">upickle</span>.<span class=\"pl-en\">default</span>.<span class=\"pl-en\">_</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-en\">org</span>.<span class=\"pl-en\">scalajs</span>.<span class=\"pl-en\">dom</span>\n\n\n<span class=\"pl-k\">sealed</span> <span class=\"pl-k\">trait</span> <span class=\"pl-en\">Page</span>\n<span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">UserPage</span>(<span class=\"pl-v\">userId</span>: <span class=\"pl-en\">Int</span>) <span class=\"pl-k\">extends</span> <span class=\"pl-e\">Page</span>\n<span class=\"pl-k\">case</span> <span class=\"pl-k\">object</span> <span class=\"pl-en\">LoginPage</span> <span class=\"pl-k\">extends</span> <span class=\"pl-e\">Page</span>\n\n<span class=\"pl-k\">implicit</span> <span class=\"pl-k\">val</span> <span class=\"pl-smi\">UserPageRW</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">ReadWriter</span>[<span class=\"pl-en\">UserPage</span>] <span class=\"pl-k\">=</span> macroRW\n<span class=\"pl-k\">implicit</span> <span class=\"pl-k\">val</span> <span class=\"pl-smi\">rw</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">ReadWriter</span>[<span class=\"pl-en\">Page</span>] <span class=\"pl-k\">=</span> macroRW\n\n<span class=\"pl-k\">val</span> <span class=\"pl-smi\">userRoute</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">Route</span>(\n  encode <span class=\"pl-k\">=</span> userPage <span class=\"pl-k\">=&gt;</span> userPage.userId,\n  decode <span class=\"pl-k\">=</span> arg <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">UserPage</span>(userId <span class=\"pl-k\">=</span> arg),\n  pattern <span class=\"pl-k\">=</span> root <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>user<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> segment[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">/</span> endOfSegments\n)\n<span class=\"pl-k\">val</span> <span class=\"pl-smi\">loginRoute</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">Route</span>.static(<span class=\"pl-en\">LoginPage</span>, root <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>login<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> endOfSegments)\n\n<span class=\"pl-k\">val</span> <span class=\"pl-smi\">router</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-en\">Router</span>[<span class=\"pl-en\">Page</span>](\n  routes <span class=\"pl-k\">=</span> <span class=\"pl-en\">List</span>(userRoute, loginRoute),\n  getPageTitle <span class=\"pl-k\">=</span> _.toString, <span class=\"pl-c\"><span class=\"pl-c\">//</span> mock page title (displayed in the browser tab next to favicon)</span>\n  serializePage <span class=\"pl-k\">=</span> page <span class=\"pl-k\">=&gt;</span> write(page)(rw), <span class=\"pl-c\"><span class=\"pl-c\">//</span> serialize page data for storage in History API log</span>\n  deserializePage <span class=\"pl-k\">=</span> pageStr <span class=\"pl-k\">=&gt;</span> read(pageStr)(rw) <span class=\"pl-c\"><span class=\"pl-c\">//</span> deserialize the above</span>\n)(\n  $popStateEvent <span class=\"pl-k\">=</span> <span class=\"pl-en\">L</span>.windowEvents.onPopState, <span class=\"pl-c\"><span class=\"pl-c\">//</span> this is how Waypoint avoids an explicit dependency on Laminar</span>\n  owner <span class=\"pl-k\">=</span> <span class=\"pl-en\">L</span>.unsafeWindowOwner <span class=\"pl-c\"><span class=\"pl-c\">//</span> this router will live as long as the window</span>\n)</pre></div>\n<p dir=\"auto\">Now, the naive approach to make this routing logic render some HTML is available in Laminar itself:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"def renderPage(page: Page): Div = {\n  page match {\n    case UserPage(userId) =&gt; div(&quot;User page &quot; + userId)\n    case LoginPage =&gt; div(&quot;Login page.&quot;)\n  }\n}\n\nval app: Div = div(\n  h1(&quot;Routing App&quot;),\n  child &lt;-- router.$currentPage.map(renderPage)\n)\n\nrender(\n  dom.document.getElementById(&quot;app-container&quot;), // make sure you add such a container element to your HTML.\n  app\n)\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">renderPage</span>(<span class=\"pl-v\">page</span>: <span class=\"pl-en\">Page</span>)<span class=\"pl-k\">:</span> <span class=\"pl-en\">Div</span> <span class=\"pl-k\">=</span> {\n  page <span class=\"pl-k\">match</span> {\n    <span class=\"pl-k\">case</span> <span class=\"pl-en\">UserPage</span>(userId) <span class=\"pl-k\">=&gt;</span> div(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>User page <span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> userId)\n    <span class=\"pl-k\">case</span> <span class=\"pl-en\">LoginPage</span> <span class=\"pl-k\">=&gt;</span> div(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Login page.<span class=\"pl-pds\">\"</span></span>)\n  }\n}\n\n<span class=\"pl-k\">val</span> <span class=\"pl-smi\">app</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Div</span> <span class=\"pl-k\">=</span> div(\n  h1(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Routing App<span class=\"pl-pds\">\"</span></span>),\n  child <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> router.$currentPage.map(renderPage)\n)\n\nrender(\n  dom.document.getElementById(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>app-container<span class=\"pl-pds\">\"</span></span>), <span class=\"pl-c\"><span class=\"pl-c\">//</span> make sure you add such a container element to your HTML.</span>\n  app\n)</pre></div>\n<p dir=\"auto\">This works, you just need to call <code>router.pushState(page)</code> or <code>router.replaceState(page)</code> somewhere to trigger the URL changes, and the view will update to show which page was selected.</p>\n<p dir=\"auto\">However, as you know, this rendering is not efficient in Laminar by design. Every time <code>router.$currentPage</code> is updated, renderPage is called, creating a whole new element. Not a big deal at all in this toy example, but in the real world it would be re-creating your whole app's DOM tree on every URL change. That is simply unacceptable.</p>\n<p dir=\"auto\">You can improve the efficiency of this using Airstream's <a href=\"https://github.com/raquo/Laminar/blob/master/docs/Documentation.md#performant-children-rendering--split\"><code>split</code> operator</a> operator, but this will prove cumbersome if your app has many different Page types. Waypoint provides a convenient but somewhat opinionated helper to solve this problem:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"val splitter = SplitRender[Page, HtmlElement](router.$currentPage)\n  .collectSignal[UserPage] { $userPage =&gt; renderUserPage($userPage) }\n  .collectStatic(LoginPage) { div(&quot;Login page&quot;) }\n \ndef renderUserPage($userPage: Signal[UserPage]): Div = {\n  div(\n    &quot;User page &quot;,\n    child.text &lt;-- $userPage.map(user =&gt; user.userId)\n  )\n}\n \nval app: Div = div(\n  h1(&quot;Routing App&quot;),\n  child &lt;-- splitter.$view\n)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-smi\">splitter</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">SplitRender</span>[<span class=\"pl-en\">Page</span>, <span class=\"pl-en\">HtmlElement</span>](router.$currentPage)\n  .collectSignal[<span class=\"pl-en\">UserPage</span>] { $userPage <span class=\"pl-k\">=&gt;</span> renderUserPage($userPage) }\n  .collectStatic(<span class=\"pl-en\">LoginPage</span>) { div(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Login page<span class=\"pl-pds\">\"</span></span>) }\n \n<span class=\"pl-k\">def</span> <span class=\"pl-en\">renderUserPage</span>(<span class=\"pl-v\">$userPage</span>: <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">UserPage</span>])<span class=\"pl-k\">:</span> <span class=\"pl-en\">Div</span> <span class=\"pl-k\">=</span> {\n  div(\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>User page <span class=\"pl-pds\">\"</span></span>,\n    child.text <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> $userPage.map(user <span class=\"pl-k\">=&gt;</span> user.userId)\n  )\n}\n \n<span class=\"pl-k\">val</span> <span class=\"pl-smi\">app</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Div</span> <span class=\"pl-k\">=</span> div(\n  h1(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Routing App<span class=\"pl-pds\">\"</span></span>),\n  child <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> splitter.$view\n)</pre></div>\n<p dir=\"auto\">This is essentially a specialized version of the Airstream's <a href=\"https://github.com/raquo/Laminar/blob/master/docs/Documentation.md#performant-children-rendering--split\"><code>split</code> operator</a>. The big idea is the same: provide a helper that lets you provide an efficient <code>Signal[A] =&gt; HtmlElement</code> instead of the inefficient <code>Signal[A] =&gt; Signal[HtmlElement]</code>. The difference is that the split operator groups together models by key, <strong>which is a value</strong>, whereas SplitRender groups together models by <strong>subtype</strong> and refines them to a subtype much like a <code>$currentPage.collect { case p: UserPage =&gt; p }</code> would if <code>collect</code> method existed on Signals.</p>\n<p dir=\"auto\">You should read the linked <code>split</code> docs to understand the general splitting pattern, as I will only cover this specialized case very lightly.</p>\n<p dir=\"auto\">In the previous, \"naive\" example, we were creating a new div element every time we navigated to a new user page, even if we're switching from one user page to a different user's page. But in that latter case, the DOM structure is already there, it would be much more efficient to just update the data in the DOM to a different user's values.</p>\n<p dir=\"auto\">And this is exactly what <code>SplitRender.collectSignal</code> lets you do: it provides you a refined <code>Signal[UserPage]</code> instead of <code>Signal[Page]</code>, and it's trivial to build a single div that uses that <code>$userPage</code> signal like we do.</p>\n<h2 dir=\"auto\"><a id=\"user-content-page-hierarchy\" class=\"anchor\" aria-hidden=\"true\" href=\"#page-hierarchy\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Page Hierarchy</h2>\n<p dir=\"auto\">SplitRender's <code>collect</code> and <code>collectSignal</code> use Scala's <a href=\"https://medium.com/@sinisalouc/overcoming-type-erasure-in-scala-8f2422070d20\" rel=\"nofollow\">ClassTag</a> to refine the general <code>Page</code> type into more specialized <code>UserPage</code>. You need to understand the limitations of ClassTag: it is only able to differentiate top level types, so in general your page types should not have type params, or if they do, you should know the limitations on matching those types with ClassTag.</p>\n<p dir=\"auto\">To make the best use of SplitRender, you should make a base <code>Page</code> trait and have each of your pages as a distinct subclass. Static pages that carry no arguments can be <code>object</code>s, you can use SplitRender's <code>collectStatic</code> method to match them, it uses basic equality instead of ClassTag.</p>\n<p dir=\"auto\">As your application grows you will likely have more than one level to your Page hierarchy. For example, you could have:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"import com.raquo.waypoint._\n \nsealed trait Page\nsealed trait AppPage extends Page\nsealed case class UserPage(userId: Int) extends AppPage\nsealed case class NotePage(workspaceId: Int, noteId: Int) extends AppPage\ncase object LoginPage extends Page\n\n// ... route and router definitions omitted for brevity ...\n\nval pageSplitter = SplitRender[Page, HtmlElement](router.$currentPage)\n  .collectSignal[AppPage] { $appPage =&gt; renderAppPage($appPage) }\n  .collectStatic(LoginPage) { div(&quot;Login page&quot;) }\n \ndef renderAppPage($appPage: Signal[AppPage]): Div = {\n  val appPageSplitter = SplitRender[AppPage, HtmlElement]($appPage)\n    .collectSignal[UserPage] { $userPage =&gt; renderUserPage($userPage) }\n    .collectSignal[NotePage] { $notePage =&gt; renderNotePage($notePage) }\n  div(\n    h2(&quot;App header&quot;),\n    child &lt;-- appPageSplitter.$view\n  )\n}\n \ndef renderUserPage($userPage: Signal[UserPage]): Div = {\n  div(\n    &quot;User page &quot;,\n    child.text &lt;-- $userPage.map(user =&gt; user.userId)\n  )\n}\n \ndef renderNotePage($notePage: Signal[NotePage]): Div = {\n  div(\n    &quot;Note page. workspaceid: &quot;,\n    child.text &lt;-- $notePage.map(note =&gt; note.workspaceId),\n    &quot;, noteid: &quot;,\n    child.text &lt;-- $notePage.map(note =&gt; note.noteId)\n  )\n}\n \nval app: Div = div(\n  h1(&quot;Routing App&quot;),\n  child &lt;-- splitter.$view\n)\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">com</span>.<span class=\"pl-en\">raquo</span>.<span class=\"pl-en\">waypoint</span>.<span class=\"pl-en\">_</span>\n \n<span class=\"pl-k\">sealed</span> <span class=\"pl-k\">trait</span> <span class=\"pl-en\">Page</span>\n<span class=\"pl-k\">sealed</span> <span class=\"pl-k\">trait</span> <span class=\"pl-en\">AppPage</span> <span class=\"pl-k\">extends</span> <span class=\"pl-e\">Page</span>\n<span class=\"pl-k\">sealed</span> <span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">UserPage</span>(<span class=\"pl-v\">userId</span>: <span class=\"pl-en\">Int</span>) <span class=\"pl-k\">extends</span> <span class=\"pl-e\">AppPage</span>\n<span class=\"pl-k\">sealed</span> <span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">NotePage</span>(<span class=\"pl-v\">workspaceId</span>: <span class=\"pl-en\">Int</span>, <span class=\"pl-v\">noteId</span>: <span class=\"pl-en\">Int</span>) <span class=\"pl-k\">extends</span> <span class=\"pl-e\">AppPage</span>\n<span class=\"pl-k\">case</span> <span class=\"pl-k\">object</span> <span class=\"pl-en\">LoginPage</span> <span class=\"pl-k\">extends</span> <span class=\"pl-e\">Page</span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> ... route and router definitions omitted for brevity ...</span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-smi\">pageSplitter</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">SplitRender</span>[<span class=\"pl-en\">Page</span>, <span class=\"pl-en\">HtmlElement</span>](router.$currentPage)\n  .collectSignal[<span class=\"pl-en\">AppPage</span>] { $appPage <span class=\"pl-k\">=&gt;</span> renderAppPage($appPage) }\n  .collectStatic(<span class=\"pl-en\">LoginPage</span>) { div(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Login page<span class=\"pl-pds\">\"</span></span>) }\n \n<span class=\"pl-k\">def</span> <span class=\"pl-en\">renderAppPage</span>(<span class=\"pl-v\">$appPage</span>: <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">AppPage</span>])<span class=\"pl-k\">:</span> <span class=\"pl-en\">Div</span> <span class=\"pl-k\">=</span> {\n  <span class=\"pl-k\">val</span> <span class=\"pl-smi\">appPageSplitter</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">SplitRender</span>[<span class=\"pl-en\">AppPage</span>, <span class=\"pl-en\">HtmlElement</span>]($appPage)\n    .collectSignal[<span class=\"pl-en\">UserPage</span>] { $userPage <span class=\"pl-k\">=&gt;</span> renderUserPage($userPage) }\n    .collectSignal[<span class=\"pl-en\">NotePage</span>] { $notePage <span class=\"pl-k\">=&gt;</span> renderNotePage($notePage) }\n  div(\n    h2(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>App header<span class=\"pl-pds\">\"</span></span>),\n    child <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> appPageSplitter.$view\n  )\n}\n \n<span class=\"pl-k\">def</span> <span class=\"pl-en\">renderUserPage</span>(<span class=\"pl-v\">$userPage</span>: <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">UserPage</span>])<span class=\"pl-k\">:</span> <span class=\"pl-en\">Div</span> <span class=\"pl-k\">=</span> {\n  div(\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>User page <span class=\"pl-pds\">\"</span></span>,\n    child.text <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> $userPage.map(user <span class=\"pl-k\">=&gt;</span> user.userId)\n  )\n}\n \n<span class=\"pl-k\">def</span> <span class=\"pl-en\">renderNotePage</span>(<span class=\"pl-v\">$notePage</span>: <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">NotePage</span>])<span class=\"pl-k\">:</span> <span class=\"pl-en\">Div</span> <span class=\"pl-k\">=</span> {\n  div(\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Note page. workspaceid: <span class=\"pl-pds\">\"</span></span>,\n    child.text <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> $notePage.map(note <span class=\"pl-k\">=&gt;</span> note.workspaceId),\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>, noteid: <span class=\"pl-pds\">\"</span></span>,\n    child.text <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> $notePage.map(note <span class=\"pl-k\">=&gt;</span> note.noteId)\n  )\n}\n \n<span class=\"pl-k\">val</span> <span class=\"pl-smi\">app</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Div</span> <span class=\"pl-k\">=</span> div(\n  h1(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Routing App<span class=\"pl-pds\">\"</span></span>),\n  child <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> splitter.$view\n)</pre></div>\n<p dir=\"auto\">One reason for nesting splitters like this could be to avoid re-rendering a common App header. In this case it's just a simple <code>h2(\"App header\")</code> element but in real life it could be complex subtree with inputs that you don't want to re-create when you're switching pages. In this last setup, <code>h2(\"App header\")</code> will not be re-created as long as you navigate within AppPage pages. Without such nesting you would need to re-create the header when navigating from a UserPage to a NotePage (or vice versa) even though both should have the same header.</p>\n<p dir=\"auto\">SplitRender offers several methods: <code>collect</code>, <code>collectSignal</code> and <code>collectStatic</code>, use the ones that make more sense for your pages. Mixing them is fine of course.</p>\n<p dir=\"auto\">Note: SplitRender is a construct made only of reactive variables. It does not know anything about routing, what the current URL is, etc. You give it a signal of <code>A</code> and a way to refine that into <code>B</code>, and you get a signal of <code>B</code> with <code>$view</code>.</p>\n<h2 dir=\"auto\"><a id=\"user-content-using-waypoint\" class=\"anchor\" aria-hidden=\"true\" href=\"#using-waypoint\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Using Waypoint</h2>\n<p dir=\"auto\">URL patterns and the matching functionality are provided by the <a href=\"https://github.com/sherpal/url-dsl\">URL DSL</a> library. All the methods that you need are defined on the <code>com.raquo.waypoint</code> package object, so just import that:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"import com.raquo.waypoint._\n \n// this matches all routes under /hello\nroot / &quot;hello&quot;\n\n// this matches just /hello and /hello/ (plus whatever query params)\nroot / &quot;hello&quot; / endOfSegments\n\n// this matches urls like /user/123 into Int\nroot / &quot;user&quot; / segment[Int] / endOfSegments\n\n// this matches urls like /workspace/123/subsection/info into (Int, String)\nroot / &quot;workspace&quot; / segment[Int] / &quot;subsection&quot; / segment[String] / endOfSegments\n\n// this matches urls like:\n//   /workspace/123?query=hello\n//   /workspace/123?query=hello&amp;mode=1 \n// note the `.?` invocation on the `mode` param: this means it's optional, modelled as Option[Int]\n(root / &quot;workspace&quot; / segment[Int] / endOfSegments) ? (param[String](&quot;query&quot;) &amp; param[Int](&quot;mode&quot;).?)\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">com</span>.<span class=\"pl-en\">raquo</span>.<span class=\"pl-en\">waypoint</span>.<span class=\"pl-en\">_</span>\n \n<span class=\"pl-c\"><span class=\"pl-c\">//</span> this matches all routes under /hello</span>\nroot <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>hello<span class=\"pl-pds\">\"</span></span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> this matches just /hello and /hello/ (plus whatever query params)</span>\nroot <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>hello<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> endOfSegments\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> this matches urls like /user/123 into Int</span>\nroot <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>user<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> segment[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">/</span> endOfSegments\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> this matches urls like /workspace/123/subsection/info into (Int, String)</span>\nroot <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>workspace<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> segment[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>subsection<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> segment[<span class=\"pl-en\">String</span>] <span class=\"pl-k\">/</span> endOfSegments\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> this matches urls like:</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>   /workspace/123?query=hello</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>   /workspace/123?query=hello&amp;mode=1 </span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> note the `.?` invocation on the `mode` param: this means it's optional, modelled as Option[Int]</span>\n(root <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>workspace<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> segment[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">/</span> endOfSegments) <span class=\"pl-k\">?</span> (param[<span class=\"pl-en\">String</span>](<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>query<span class=\"pl-pds\">\"</span></span>) &amp; param[<span class=\"pl-en\">Int</span>](<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>mode<span class=\"pl-pds\">\"</span></span>).<span class=\"pl-k\">?</span>)</pre></div>\n<p dir=\"auto\">How to use such patterns to build routes:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"import com.raquo.waypoint._\nimport urldsl.vocabulary.UrlMatching\n\nRoute.static(LoginPage, root / &quot;login&quot; / endOfSegments)\n\nRoute[UserPage, Int](\n  encode = userPage =&gt; userPage.userId,\n  decode = arg =&gt; UserPage(userId = arg),\n  pattern = root / &quot;user&quot; / segment[Int] / endOfSegments\n)\n\nRoute[WorkspacePage, (Int, String)](\n  encode = workspacePage =&gt; (workspacePage.id, workspacePage.subsection),\n  decode = args =&gt; WorkspacePage(id = args._1, subsection = args._2),\n  pattern = root / &quot;workspace&quot; / segment[Int] / &quot;subsection&quot; / segment[Sting] / endOfSegments\n)\n\nRoute.withQuery[WorkspaceSearchPage, Int, (String, Int)](\n  encode = page =&gt; UrlMatching(path = page.id, params = (page.subsection, page.mode)),\n  decode = args =&gt; WorkspacePage(id = args.path, subsection = args.params._1, mode = args.params._2),\n  pattern = (root / &quot;workspace&quot; / segment[Int] / endOfSegments) ? (param[String](&quot;query&quot;) &amp; param[Int](&quot;mode&quot;))\n)\n\nRoute.onlyQuery[SearchPage, String](\n  encode = page =&gt; page.query,\n  decode = arg =&gt; SearchPage(query = arg),\n  pattern = (root / &quot;search&quot; / endOfSegments) ? (param[String](&quot;query&quot;))\n)\n\nRoute[BigLegalPage, FragmentPatternArgs[String, Unit, String]] = Route.withFragment(\n  encode = page =&gt; FragmentPatternArgs(path = page.page, query = (), fragment = page.section),\n  decode = args =&gt; BigLegalPage(page = args.path, section = args.fragment),\n  pattern = (root / &quot;legal&quot; / segment[String] / endOfSegments) withFragment fragment[String]\n)\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">com</span>.<span class=\"pl-en\">raquo</span>.<span class=\"pl-en\">waypoint</span>.<span class=\"pl-en\">_</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-en\">urldsl</span>.<span class=\"pl-en\">vocabulary</span>.<span class=\"pl-en\">UrlMatching</span>\n\n<span class=\"pl-en\">Route</span>.static(<span class=\"pl-en\">LoginPage</span>, root <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>login<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> endOfSegments)\n\n<span class=\"pl-en\">Route</span>[<span class=\"pl-en\">UserPage</span>, <span class=\"pl-en\">Int</span>](\n  encode <span class=\"pl-k\">=</span> userPage <span class=\"pl-k\">=&gt;</span> userPage.userId,\n  decode <span class=\"pl-k\">=</span> arg <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">UserPage</span>(userId <span class=\"pl-k\">=</span> arg),\n  pattern <span class=\"pl-k\">=</span> root <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>user<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> segment[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">/</span> endOfSegments\n)\n\n<span class=\"pl-en\">Route</span>[<span class=\"pl-en\">WorkspacePage</span>, (<span class=\"pl-en\">Int</span>, <span class=\"pl-en\">String</span>)](\n  encode <span class=\"pl-k\">=</span> workspacePage <span class=\"pl-k\">=&gt;</span> (workspacePage.id, workspacePage.subsection),\n  decode <span class=\"pl-k\">=</span> args <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">WorkspacePage</span>(id <span class=\"pl-k\">=</span> args._1, subsection <span class=\"pl-k\">=</span> args._2),\n  pattern <span class=\"pl-k\">=</span> root <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>workspace<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> segment[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>subsection<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> segment[<span class=\"pl-en\">Sting</span>] <span class=\"pl-k\">/</span> endOfSegments\n)\n\n<span class=\"pl-en\">Route</span>.withQuery[<span class=\"pl-en\">WorkspaceSearchPage</span>, <span class=\"pl-en\">Int</span>, (<span class=\"pl-en\">String</span>, <span class=\"pl-en\">Int</span>)](\n  encode <span class=\"pl-k\">=</span> page <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">UrlMatching</span>(path <span class=\"pl-k\">=</span> page.id, params <span class=\"pl-k\">=</span> (page.subsection, page.mode)),\n  decode <span class=\"pl-k\">=</span> args <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">WorkspacePage</span>(id <span class=\"pl-k\">=</span> args.path, subsection <span class=\"pl-k\">=</span> args.params._1, mode <span class=\"pl-k\">=</span> args.params._2),\n  pattern <span class=\"pl-k\">=</span> (root <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>workspace<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> segment[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">/</span> endOfSegments) <span class=\"pl-k\">?</span> (param[<span class=\"pl-en\">String</span>](<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>query<span class=\"pl-pds\">\"</span></span>) &amp; param[<span class=\"pl-en\">Int</span>](<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>mode<span class=\"pl-pds\">\"</span></span>))\n)\n\n<span class=\"pl-en\">Route</span>.onlyQuery[<span class=\"pl-en\">SearchPage</span>, <span class=\"pl-en\">String</span>](\n  encode <span class=\"pl-k\">=</span> page <span class=\"pl-k\">=&gt;</span> page.query,\n  decode <span class=\"pl-k\">=</span> arg <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">SearchPage</span>(query <span class=\"pl-k\">=</span> arg),\n  pattern <span class=\"pl-k\">=</span> (root <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>search<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> endOfSegments) <span class=\"pl-k\">?</span> (param[<span class=\"pl-en\">String</span>](<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>query<span class=\"pl-pds\">\"</span></span>))\n)\n\n<span class=\"pl-en\">Route</span>[<span class=\"pl-en\">BigLegalPage</span>, <span class=\"pl-en\">FragmentPatternArgs</span>[<span class=\"pl-en\">String</span>, <span class=\"pl-en\">Unit</span>, <span class=\"pl-en\">String</span>]] <span class=\"pl-k\">=</span> <span class=\"pl-en\">Route</span>.withFragment(\n  encode <span class=\"pl-k\">=</span> page <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">FragmentPatternArgs</span>(path <span class=\"pl-k\">=</span> page.page, query <span class=\"pl-k\">=</span> (), fragment <span class=\"pl-k\">=</span> page.section),\n  decode <span class=\"pl-k\">=</span> args <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">BigLegalPage</span>(page <span class=\"pl-k\">=</span> args.path, section <span class=\"pl-k\">=</span> args.fragment),\n  pattern <span class=\"pl-k\">=</span> (root <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>legal<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> segment[<span class=\"pl-en\">String</span>] <span class=\"pl-k\">/</span> endOfSegments) withFragment fragment[<span class=\"pl-en\">String</span>]\n)</pre></div>\n<p dir=\"auto\">Each of the above results in a <code>Route[Page, Args]</code> with the precise types. You can ask these routes to parse <code>argsFromPage</code>, get <code>relativeUrlForPage</code>, <code>pageForAbsoluteUrl</code>, or <code>pageForRelativeUrl</code>. But normally you would build a Router like we did in <a href=\"#rendering-views\">Rendering Views</a>, passing it a list of all the routes you created.</p>\n<p dir=\"auto\">Then you can change the document URL with <code>router.pushState(newPage)</code> and <code>router.replaceState(newPage)</code>, as well as get URLs for pages with <code>router.absoluteUrlForPage</code> and <code>router.relativeUrlForPage</code> (e.g. if you want to put that URL in a href attribute). You can even ask the router what Page, if any, matches a given url with <code>router.pageForAbsoluteUrl</code> or <code>router.pageForRelativeUrl</code>, or react to URL changes by listening to <code>router.$currentPage</code> signal (it's a StrictSignal so its current value is always available at <code>router.$currentPage.now()</code>).</p>\n<h2 dir=\"auto\"><a id=\"user-content-routing-extras\" class=\"anchor\" aria-hidden=\"true\" href=\"#routing-extras\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Routing Extras</h2>\n<h3 dir=\"auto\"><a id=\"user-content-partial-routes\" class=\"anchor\" aria-hidden=\"true\" href=\"#partial-routes\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Partial Routes</h3>\n<p dir=\"auto\">Waypoint's API design is centered around matching pages by ClassTag, but under the hood we just use partial functions. So, you can create routes like this too, and yes, they can actually be partial, i.e. cover only a subset of the page type. For example, here is a route that matches pages only for big numbers.</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Route.applyPF[DocsPage, Int](\n  matchEncode = { case DocsPage(NumPage(i)) if i &gt; 100 =&gt; i },\n  decode = { case arg if arg &gt; 100 =&gt; DocsPage(NumPage(arg)) },\n  pattern = root / &quot;docs&quot; / &quot;num&quot; / segment[Int] / endOfSegments\n)\"><pre><span class=\"pl-en\">Route</span>.applyPF[<span class=\"pl-en\">DocsPage</span>, <span class=\"pl-en\">Int</span>](\n  matchEncode <span class=\"pl-k\">=</span> { <span class=\"pl-k\">case</span> <span class=\"pl-en\">DocsPage</span>(<span class=\"pl-en\">NumPage</span>(i)) <span class=\"pl-k\">if</span> i <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">100</span> <span class=\"pl-k\">=&gt;</span> i },\n  decode <span class=\"pl-k\">=</span> { <span class=\"pl-k\">case</span> arg <span class=\"pl-k\">if</span> arg <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">100</span> <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">DocsPage</span>(<span class=\"pl-en\">NumPage</span>(arg)) },\n  pattern <span class=\"pl-k\">=</span> root <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>docs<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>num<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> segment[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">/</span> endOfSegments\n)</pre></div>\n<p dir=\"auto\">When using partial matchers you need to be careful that the \"partiality\" of <code>matchEncode</code> and <code>decode</code> is symmetric, otherwise you might end up with a route that can parse a page from a URL but can't encode that same page into a URL (or vice versa).</p>\n<h3 dir=\"auto\"><a id=\"user-content-contextroutebuilder\" class=\"anchor\" aria-hidden=\"true\" href=\"#contextroutebuilder\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ContextRouteBuilder</h3>\n<p dir=\"auto\">Imagine your web app has many routes with the same query params. For example, your Laminar web app might have a documentation section where every route is expected to have a \"lang\" query param to indicate the selected \"language\" and a \"version\" param to indicate the product version (unrealistic doc standards, I know).</p>\n<p dir=\"auto\">You could add these two params to every page type that needs them and to every route for those page types, but that could be annoying. So instead, you can create a ContextRouteBuilder which will let you specify the necessary types / conversions / patterns only once.</p>\n<p dir=\"auto\">To achieve this, ContextRouteBuilder introduces the concept of Bundle, which is basically a... bundle of (Page, Context), where Page is the usual Waypoint Page, and Context is a data structure that contains all the shared query params, such as \"language\" and \"version\" in our example.</p>\n<p dir=\"auto\">See example usage in tests, specifically ContextRouteBuilderSpec.</p>\n<h3 dir=\"auto\"><a id=\"user-content-base-path-and-fragment-routes\" class=\"anchor\" aria-hidden=\"true\" href=\"#base-path-and-fragment-routes\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Base Path and Fragment Routes</h3>\n<p dir=\"auto\">If you want your single page application navigation to work on fragments, i.e. use URLs like <code>example.com/#/foo/bar</code> instead of <code>example.com/foo/bar</code>, you can do this by providing <code>basePath = Route.fragmentBasePath</code> to your Route constructor.</p>\n<p dir=\"auto\">Typically you will want to do this for every one of your Routes, but the Waypoint API is flexible to allow only a subset of Routes to be fragment routes.</p>\n<p dir=\"auto\">Why would you want this? Using path segments like <code>/foo/bar</code> without fragment routes requires the cooperation of the web server. Not needing that is useful when:</p>\n<ul dir=\"auto\">\n<li>Developing locally without a web server, by looking at a <code>file://</code> URL (in this case, use <strong><code>Router.localFragmentBasePath</code></strong> instead of <code>Route.fragmentBasePath</code>)</li>\n<li>Using a simple static site host like Github pages that doesn't provide a catch-all feature</li>\n<li>Embedding live examples of router applications with <a href=\"https://github.com/scalameta/mdoc\">mdoc</a></li>\n</ul>\n<p dir=\"auto\">When hosting your static site you might not be able to have a server respond to any route you want, you might be limited to just one url per html file on viewing a <code>file://</code> URL in the browser without a web server</p>\n<p dir=\"auto\">As the name implies, aside from fragments, a Route's <code>basePath</code> can contain any path. It could be <code>/foo/bar/index.html#</code> or even just <code>/foo/bar</code>. If set, it must have a leading slash.</p>\n<p dir=\"auto\">For the record, <code>basePath</code> is included in the route's <code>relativeUrl</code> as far as Waypoint's public methods are concerned.</p>\n<p dir=\"auto\">Note that URL DSL offers a basic way to match the fragment string in the URL (everything after <code>#</code>) â€“ see one of the examples above. Waypoint's <code>basePath</code> feature is different in that it lets you use standard non-fragment matching of URL DSL segments, query params, etc. on the fragment string.</p>\n<h2 dir=\"auto\"><a id=\"user-content-error-handling\" class=\"anchor\" aria-hidden=\"true\" href=\"#error-handling\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Error Handling</h2>\n<h3 dir=\"auto\"><a id=\"user-content-failing-to-match-routes\" class=\"anchor\" aria-hidden=\"true\" href=\"#failing-to-match-routes\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Failing to Match Routes</h3>\n<p dir=\"auto\">If none of the routes match on initial page load, you can still render a page using <code>routeFallback</code> constructor param. The URL will not be updated, but <code>router.$currentPage</code> will emit the resulting page. If routeFallback throws, which is the default behaviour, <code>router.$currentPage</code> will be put into error state. If you want to throw for logging purposes, but don't want this to happen, return the current page and throw inside a setTimeout.</p>\n<p dir=\"auto\">Similarly, if during user's navigation we encounter a History API state record that <code>deserializePage</code> throws on, you can handle it using <code>deserializeFallback</code>. It throws too by default, with the same effect as <code>routeFallback</code>.</p>\n<p dir=\"auto\"><code>router.$currentPage</code> can also be in an errored state if the initial URL does not match the origin. Both of those are taken from <code>dom.window.location</code> by default so this shouldn't be an issue.</p>\n<h3 dir=\"auto\"><a id=\"user-content-rendering-error-pages\" class=\"anchor\" aria-hidden=\"true\" href=\"#rendering-error-pages\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Rendering Error Pages</h3>\n<p dir=\"auto\"><code>routeFallback</code> is useful to catch complete garbage URLs that match none of the routes, but you also want more refined control over invalid parameters.</p>\n<p dir=\"auto\">For example, imagine you're matching a route like <code>/user/&lt;userId&gt;</code>. When the matching happens you don't know whether a user with <code>&lt;userId&gt;</code> actually exists, you will only know that after an asynchronous delay. So, your <code>userRoute</code> should successfully match this path, rendering an element that makes an AJAX request for this user's info on mount. Some milliseconds later when the AJAX response comes in you can either proceed to render the user or trigger a failure if AJAX resulted in an error. More specifically:</p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">You could call <code>router.forcePage(NotFoundPage(title, comment))</code> to force the router to emit the provided page without updating the URL (although document title will be updated unless the page's title is not empty). This pattern is useful to show a full page error screen without redirecting the user to a different URL or messing with the navigation history.</p>\n</li>\n<li>\n<p dir=\"auto\">You could call <code>router.pushState</code> or <code>router.replaceState</code> to render a different page with a redirect. Sometimes this is required, but for UX purposes you should avoid redirecting users to useless URLs like <code>/404</code> because this prevents the user from manually fixing the URL in the address bar. A <code>pushState</code> redirect can also interfere with the user's ability to use the browser back button.</p>\n</li>\n</ul>\n<p dir=\"auto\">So, <code>router.forcePage</code> is often the preferred way.</p>\n<h2 dir=\"auto\"><a id=\"user-content-recipes\" class=\"anchor\" aria-hidden=\"true\" href=\"#recipes\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Recipes</h2>\n<h4 dir=\"auto\"><a id=\"user-content-pages-carrying-state-not-reflected-in-the-url\" class=\"anchor\" aria-hidden=\"true\" href=\"#pages-carrying-state-not-reflected-in-the-url\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Pages carrying state not reflected in the URL</h4>\n<p dir=\"auto\">Suppose you want to \"remember\" vertical scroll position on a certain page, so that when you navigate away from it and then come back, it's restored. Instead of maintaining complex global variables or cookies or whatever, just include this information in the Page.</p>\n<p dir=\"auto\">Pages are serialized into History API state records, so when the user uses browser back button to come back to a page that he's already been to, it's not just the old URL that's restored, it's the whole Page state. On the contrary, if the user reloads the page or clicks a link that causes a page load instead of the History API transition, the Page state will be parsed from the URL, and since the URL does not include scroll position in our case, that will need to be the default scroll position of zero.</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Route[NotePage, (Int, Int)](\n  encode = page =&gt; (page.libraryId, page.noteId), // scroll position is not written into the URL args\n  decode = args =&gt; NotePage(libraryId = args._1, noteId = args._2, scrollPosition = 0), // default scroll position that will be inferred from the URL\n  pattern = root / &quot;app&quot; / &quot;library&quot; / segment[Int] / &quot;note&quot; / segment[Int] / endOfSegments\n)\"><pre><span class=\"pl-en\">Route</span>[<span class=\"pl-en\">NotePage</span>, (<span class=\"pl-en\">Int</span>, <span class=\"pl-en\">Int</span>)](\n  encode <span class=\"pl-k\">=</span> page <span class=\"pl-k\">=&gt;</span> (page.libraryId, page.noteId), <span class=\"pl-c\"><span class=\"pl-c\">//</span> scroll position is not written into the URL args</span>\n  decode <span class=\"pl-k\">=</span> args <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">NotePage</span>(libraryId <span class=\"pl-k\">=</span> args._1, noteId <span class=\"pl-k\">=</span> args._2, scrollPosition <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>), <span class=\"pl-c\"><span class=\"pl-c\">//</span> default scroll position that will be inferred from the URL</span>\n  pattern <span class=\"pl-k\">=</span> root <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>app<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>library<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> segment[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">/</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>note<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">/</span> segment[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">/</span> endOfSegments\n)</pre></div>\n<p dir=\"auto\">Remember that your code needs to actually scroll to the desired scroll position when loading the page. You can probably just do this when switching from a different type of page to the type of page that remembers its scroll position. Treat scroll position as a sort of \"uncontrolled input\" in React terms, if that makes sense.</p>\n<p dir=\"auto\">Lastly, normally you fire <code>router.pushState</code> to update the current page. But in case of updating current scroll position, you should instead fire <code>router.replaceState</code>, otherwise you will litter your browser history with a bunch of useless scrolling records.</p>\n<h4 dir=\"auto\"><a id=\"user-content-configuring-your-web-server\" class=\"anchor\" aria-hidden=\"true\" href=\"#configuring-your-web-server\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Configuring your web server</h4>\n<p dir=\"auto\">Unless you're using <code>Route.fragmentBasePath</code> (see above) to put all your routes in the fragment of the URL, like <code>/#/foo/bar</code>, you need to ensure that your web server responds to all your Waypoint routes with the HTML file that will load your Scala.js bundle and thus the Waypoint application. Basically, if your frontend thinks that it's responsible for handling the route <code>example.com/foo/bar</code>, you better make sure that your backend will load that frontend if the user enters <code>example.com/foo/bar</code> in the address bar.</p>\n<p dir=\"auto\">The easiest way to accomplish this is to put all or most of your Waypoint routes behind a prefix like <code>/app</code>. You can use <code>basePath</code> for this, or just start all your routes at <code>val appRoot = root / \"app\"</code>. Then on the backend you will tell the server to match anything under <code>/app</code> to your frontend.</p>\n<p dir=\"auto\">You can keep a few pages like <code>/login</code> outside of the <code>app</code> world, but then you'll need to hardcode them in your backend routes as well.</p>\n<p dir=\"auto\">Using a catch-all route on the backend is an option too, but that is likely to interfere with 404 error behaviour, so it's not recommended without a prefix like <code>/app</code>.</p>\n<p dir=\"auto\">Note that you can put Waypoint's <code>Route</code> in <code>shared</code>, so if you were so inclined, you could write an integration with your web server framework to evaluate Waypoint's routes on the backend. See the implementation of <code>Router#pageForAbsoluteUrl</code>, it's pretty simple.</p>\n<h4 dir=\"auto\"><a id=\"user-content-responding-to-link-clicks\" class=\"anchor\" aria-hidden=\"true\" href=\"#responding-to-link-clicks\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Responding to link clicks</h4>\n<p dir=\"auto\">Normally when navigating on the internet, users click on <code>&lt;a href=\"url\"&gt;</code> links, and the browser navigates them to <code>url</code>. This results in the target page being loaded from scratch, which is fine for content sites but is slow and inefficient for interactive, single page application (SPA) sites.</p>\n<p dir=\"auto\">So when the user clicks a link in a single page application, you want to hijack that click â€“ prevent the default browser action, and instead use Waypoint to <code>pushState</code> the new page. This will update the URL but instead of loading a new page from the web server, <code>router.$currentPage</code> will emit a new page, and your application will respond to that without network overhead.</p>\n<p dir=\"auto\">In Laminar that can be achieved with a simple set of modifiers:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"a(\n  onClick.preventDefault --&gt; (_ =&gt; router.pushState(page)),\n  href := router.absoluteUrlForPage(page)\n)\"><pre>a(\n  onClick.preventDefault <span class=\"pl-k\">--</span><span class=\"pl-k\">&gt;</span> (_ <span class=\"pl-k\">=&gt;</span> router.pushState(page)),\n  href <span class=\"pl-k\">:</span><span class=\"pl-k\">=</span> router.absoluteUrlForPage(page)\n)</pre></div>\n<p dir=\"auto\">However, this is not good enough. For instance, what if the user ctrl-clicks, wanting to open the page in a new tab? Our code above will break the user's expectations, updating the content of the current page instead of opening a new tab. We need to be smarter. Long story short, we need something like this:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"def navigateTo(page: BasePage): Binder[HtmlElement] = Binder { el =&gt;\n\n  val isLinkElement = el.ref.isInstanceOf[dom.html.Anchor]\n\n  if (isLinkElement) {\n    el.amend(href(router.absoluteUrlForPage(page)))\n  }\n  \n  // If element is a link and user is holding a modifier while clicking:\n  //  - Do nothing, browser will open the URL in new tab / window / etc. depending on the modifier key\n  // Otherwise:\n  //  - Perform regular pushState transition\n  (onClick\n    .filter(ev =&gt; !(isLinkElement &amp;&amp; (ev.ctrlKey || ev.metaKey || ev.shiftKey || ev.altKey)))\n    .preventDefault\n    --&gt; (_ =&gt; router.pushState(page))\n  ).bind(el)\n}\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">navigateTo</span>(<span class=\"pl-v\">page</span>: <span class=\"pl-en\">BasePage</span>)<span class=\"pl-k\">:</span> <span class=\"pl-en\">Binder</span>[<span class=\"pl-en\">HtmlElement</span>] <span class=\"pl-k\">=</span> <span class=\"pl-en\">Binder</span> { el <span class=\"pl-k\">=&gt;</span>\n\n  <span class=\"pl-k\">val</span> <span class=\"pl-smi\">isLinkElement</span> <span class=\"pl-k\">=</span> el.ref.<span class=\"pl-c1\">isInstanceOf</span>[dom.html.<span class=\"pl-en\">Anchor</span>]\n\n  <span class=\"pl-k\">if</span> (isLinkElement) {\n    el.amend(href(router.absoluteUrlForPage(page)))\n  }\n  \n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> If element is a link and user is holding a modifier while clicking:</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>  - Do nothing, browser will open the URL in new tab / window / etc. depending on the modifier key</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> Otherwise:</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>  - Perform regular pushState transition</span>\n  (onClick\n    .filter(ev <span class=\"pl-k\">=&gt;</span> <span class=\"pl-k\">!</span>(isLinkElement <span class=\"pl-k\">&amp;&amp;</span> (ev.ctrlKey <span class=\"pl-k\">||</span> ev.metaKey <span class=\"pl-k\">||</span> ev.shiftKey <span class=\"pl-k\">||</span> ev.altKey)))\n    .preventDefault\n    <span class=\"pl-k\">--</span><span class=\"pl-k\">&gt;</span> (_ <span class=\"pl-k\">=&gt;</span> router.pushState(page))\n  ).bind(el)\n}</pre></div>\n<p dir=\"auto\">Then you can use this modifier on any link or other element safely:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"a(navigateTo(libraryPage), &quot;Library&quot;) // sets `href` and conditional `onClick`\nbutton(navigateTo(logoutPage), &quot;Log out&quot;) // sets unconditional `onClick` only\"><pre>a(navigateTo(libraryPage), <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Library<span class=\"pl-pds\">\"</span></span>) <span class=\"pl-c\"><span class=\"pl-c\">//</span> sets `href` and conditional `onClick`</span>\nbutton(navigateTo(logoutPage), <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Log out<span class=\"pl-pds\">\"</span></span>) <span class=\"pl-c\"><span class=\"pl-c\">//</span> sets unconditional `onClick` only</span></pre></div>\n<h4 dir=\"auto\"><a id=\"user-content-firefox-and-file-urls\" class=\"anchor\" aria-hidden=\"true\" href=\"#firefox-and-file-urls\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Firefox and file:// URLs</h4>\n<p dir=\"auto\">Chrome and Safari return <code>\"file://\"</code> as the <code>location.origin</code> of <code>file://</code> URLs, which is what Waypoint expects, whereas Firefox returns <code>\"null\"</code> (as a string).</p>\n<p dir=\"auto\">If a Waypoint error message pointed you to this section of the docs, that means you're giving Waypoint a <code>\"null\"</code> origin where a <code>protocol://</code> origin is expected, most likely because you're using Firefox with <code>file://</code> URLs (if you ever see this error message for any other reason, please let me know).</p>\n<p dir=\"auto\">To work around this, you should use something like this:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"def canonicalOrigin = if (dom.document.location.protocol == &quot;file:&quot;) &quot;file://&quot; else dom.document.location.origin.get\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">canonicalOrigin</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">if</span> (dom.document.location.protocol <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>file:<span class=\"pl-pds\">\"</span></span>) <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>file://<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">else</span> dom.document.location.origin.get</pre></div>\n<p dir=\"auto\">or just use <code>router.origin</code> which is derived from <code>dom.document.location</code> in the same manner (unless you overrode the Router's <code>origin</code> constructor param).</p>\n<p dir=\"auto\">Unfortunately I don't think I can fix this in Waypoint in a safe way (messing with URLs can be risky), but I also don't expect this to be a significant problem given the very limited scope of the problem (just the two public methods â€“ <code>pageForAbsoluteUrl</code> and <code>pageForRelativeUrl</code>) and the easy workaround.</p>\n<h3 dir=\"auto\"><a id=\"user-content-canonicalizing-the-urls\" class=\"anchor\" aria-hidden=\"true\" href=\"#canonicalizing-the-urls\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Canonicalizing the URLs</h3>\n<p dir=\"auto\">When initializing the router on page load, we parse the initial URL and emit the corresponding Page. Note that unlike <code>pushState(page)</code> or <code>replaceState(page)</code>, we do not update the URL to the initial page's canonical URL, the original URL stays. This is helpful because the URL might contain query params that you don't want to include in your pages but also don't want to remove.</p>\n<p dir=\"auto\">However, as soon as you navigate to a different page by means of <code>pushState(page)</code> or <code>replaceState(page)</code>, the URL will be updated to the canonical URL of the next page, with any extraneous query params removed.</p>\n<p dir=\"auto\">If you want the initial URL canonicalized (as was done automatically prior to Waypoint 0.4.0), call <code>router.replaceState(router.$currentPage.now())</code> on page load.</p>\n<p dir=\"auto\">If you need to manage large numbers of common query params, consider using <a href=\"#contextroutebuilder\">ContextRouteBuilder</a></p>\n<h2 dir=\"auto\"><a id=\"user-content-waypoint-without-laminar\" class=\"anchor\" aria-hidden=\"true\" href=\"#waypoint-without-laminar\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Waypoint Without Laminar</h2>\n<p dir=\"auto\">Perhaps ironically, Waypoint does not actually depend on Laminar, only on Airstream.</p>\n<p dir=\"auto\">All you need to use Waypoint without Laminar is provide a stream of <code>dom.OnPopState</code> events, which is very easy, just make one using Airstream's <code>DomEventStream</code>.</p>\n<h2 dir=\"auto\"><a id=\"user-content-author\" class=\"anchor\" aria-hidden=\"true\" href=\"#author\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Author</h2>\n<p dir=\"auto\">Nikita Gazarov â€“ <a href=\"https://twitter.com/raquo\" rel=\"nofollow\">@raquo</a></p>\n<h2 dir=\"auto\"><a id=\"user-content-license--credits\" class=\"anchor\" aria-hidden=\"true\" href=\"#license--credits\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>License &amp; Credits</h2>\n<p dir=\"auto\">Waypoint is provided under the <a href=\"https://github.com/raquo/Waypoint/blob/master/LICENSE.md\">MIT license</a>.</p>\n<p dir=\"auto\">Waypoint uses <a href=\"https://github.com/sherpal/url-dsl\">URL DSL</a> for URL matching, also provided under the MIT license.</p>\n</article></div>",
    "contributors" : [
      {
        "login" : "raquo",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/532656?v=4",
        "url" : "https://github.com/raquo",
        "contributions" : 53
      },
      {
        "login" : "ngbinh",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/211327?v=4",
        "url" : "https://github.com/ngbinh",
        "contributions" : 3
      },
      {
        "login" : "lolgab",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/5793054?v=4",
        "url" : "https://github.com/lolgab",
        "contributions" : 1
      },
      {
        "login" : "nightscape",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/35170?v=4",
        "url" : "https://github.com/nightscape",
        "contributions" : 1
      },
      {
        "login" : "pbuszka",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/10343461?v=4",
        "url" : "https://github.com/pbuszka",
        "contributions" : 1
      },
      {
        "login" : "peterlopen",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/19715361?v=4",
        "url" : "https://github.com/peterlopen",
        "contributions" : 1
      }
    ],
    "commits" : 60,
    "topics" : [
      "router",
      "scalajs"
    ],
    "contributingGuide" : null,
    "codeOfConduct" : null,
    "chatroom" : null,
    "openIssues" : [
      {
        "number" : 11,
        "title" : "Link in documentation doesn't work",
        "url" : "https://github.com/raquo/Waypoint/issues/11"
      }
    ],
    "scalaPercentage" : 100,
    "license" : "MIT",
    "commitActivity" : [
      {
        "total" : 0,
        "week" : 1629590400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1630195200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1630800000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1631404800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1632009600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1632614400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1633219200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1633824000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1634428800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1635033600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1635638400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 3,
        "week" : 1636243200000,
        "days" : [
          3,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1636848000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1637452800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1638057600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1638662400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1639267200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1639872000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1640476800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1641081600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1641686400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1642291200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1642896000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1643500800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1644105600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1644710400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1645315200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1645920000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1646524800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1647129600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1647734400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1648339200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1648944000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1649548800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1650153600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1650758400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1651363200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1651968000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1652572800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1653177600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1653782400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1654387200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1654992000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1655596800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1656201600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1656806400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1657411200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1658016000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1658620800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1659225600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1659830400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1660435200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      }
    ]
  },
  "settings" : {
    "defaultStableVersion" : true,
    "defaultArtifact" : null,
    "strictVersions" : false,
    "customScalaDoc" : null,
    "documentationLinks" : [
    ],
    "deprecated" : false,
    "contributorsWanted" : false,
    "artifactDeprecations" : [
    ],
    "cliArtifacts" : [
    ],
    "category" : "urls-and-routing",
    "beginnerIssuesLabel" : null
  }
}
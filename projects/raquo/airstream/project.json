{
  "organization" : "raquo",
  "repository" : "airstream",
  "creationDate" : 1523660731000,
  "githubStatus" : {
    "Ok" : {
      "updateDate" : 1723548746391
    }
  },
  "githubInfo" : {
    "homepage" : "",
    "description" : "State propagation and event streams with mandatory ownership and no glitches",
    "logo" : "https://avatars.githubusercontent.com/u/532656?v=4",
    "stars" : 241,
    "forks" : 27,
    "watchers" : 14,
    "issues" : 19,
    "creationDate" : 1523660137000,
    "readme" : "<div id=\"readme\" class=\"md\" data-path=\"README.md\"><article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><div class=\"markdown-heading\" dir=\"auto\"><h1 class=\"heading-element\" dir=\"auto\">Airstream</h1><a id=\"user-content-airstream\" class=\"anchor\" aria-label=\"Permalink: Airstream\" href=\"#airstream\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><a href=\"https://github.com/raquo/Airstream/actions/workflows/test.yml\"><img src=\"https://github.com/raquo/Airstream/actions/workflows/test.yml/badge.svg\" alt=\"Build status\" style=\"max-width: 100%;\"></a>\n<a href=\"https://discord.gg/JTrUxhq7sj\" rel=\"nofollow\"><img src=\"https://camo.githubusercontent.com/8f73484a59b2411bcabee4c78c32ba84466d0c9100fca33a328da66eae9bd82b/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636861742d6f6e253230646973636f72642d3732383964612e737667\" alt=\"Chat on https://discord.gg/JTrUxhq7sj\" data-canonical-src=\"https://img.shields.io/badge/chat-on%20discord-7289da.svg\" style=\"max-width: 100%;\"></a>\n<a href=\"https://search.maven.org/artifact/com.raquo/airstream_sjs1_3\" rel=\"nofollow\"><img src=\"https://camo.githubusercontent.com/e3587b4ce51a769ba93ad4b7909ac5a2584725755ee7a47fa3d52e03adbc1cf1/68747470733a2f2f696d672e736869656c64732e696f2f6d6176656e2d63656e7472616c2f762f636f6d2e726171756f2f61697273747265616d5f736a73315f332e737667\" alt=\"Maven Central\" data-canonical-src=\"https://img.shields.io/maven-central/v/com.raquo/airstream_sjs1_3.svg\" style=\"max-width: 100%;\"></a></p>\n<p dir=\"auto\">Airstream is a small state propagation and streaming library for Scala.js. Primary differences from other solutions:</p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\"><strong>Mandatory <a href=\"#ownership\">ownership</a> of leaky resources</strong> – it is impossible to create a subscription without specifying when it shall be destroyed. This helps prevent memory leaks and unexpected behaviour.</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>No <a href=\"#frp-glitches\">FRP glitches</a></strong> – neither observables themselves nor their observers will ever see inconsistent state within a transaction, at no runtime cost.</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>One integrated system for two core types of observables</strong></p>\n<ul dir=\"auto\">\n<li>EventStream for events (lazy, no current value)</li>\n<li>Signal for state (lazy, has current value, only state-safe operators)</li>\n<li>Seamless interop between the two types</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><strong>Small size, simple implementation</strong> – easy to understand, easy to create custom observables. Does not bloat your Scala.js bundle size.</p>\n</li>\n</ul>\n<p dir=\"auto\">Airstream has a very generic design, but is primarily intended to serve as a reactive layer for unidirectional dataflow architecture in UI components. As such, it is not burdened by features that cause more problems than they solve in frontend development, such as backpressure and typed effects.</p>\n<p dir=\"auto\">I created Airstream because I found existing solutions were not suitable for building reactive UI components. My original need for Airstream was to replace the previous reactive layer of <a href=\"https://laminar.dev\" rel=\"nofollow\">Laminar</a>, but I'll be happy to see it used by other reactive UI libraries as well. Another piece of Laminar you can reuse is <a href=\"https://github.com/raquo/scala-dom-types\">Scala DOM Types</a>.</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"&quot;com.raquo&quot; %%% &quot;airstream&quot; % &quot;&lt;version&gt;&quot;  // Requires Scala.js 1.16.0+\"><pre class=\"notranslate\"><code>\"com.raquo\" %%% \"airstream\" % \"&lt;version&gt;\"  // Requires Scala.js 1.16.0+\n</code></pre></div>\n<div class=\"markdown-heading\" dir=\"auto\"><h2 class=\"heading-element\" dir=\"auto\">Table of Contents</h2><a id=\"user-content-table-of-contents\" class=\"anchor\" aria-label=\"Permalink: Table of Contents\" href=\"#table-of-contents\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<ul dir=\"auto\">\n<li><a href=\"#community\">Community</a></li>\n<li><a href=\"#documentation\">Documentation</a>\n<ul dir=\"auto\">\n<li><a href=\"#eventstream\">EventStream</a></li>\n<li><a href=\"#laziness\">Laziness</a>\n<ul dir=\"auto\">\n<li><a href=\"#starting-observables\">Starting Observables</a></li>\n<li><a href=\"#stopping-observables\">Stopping Observables</a></li>\n<li><a href=\"#memory-management-implications\">Memory Management Implications</a></li>\n</ul>\n</li>\n<li><a href=\"#signal\">Signal</a>\n<ul dir=\"auto\">\n<li><a href=\"#getting-signals-current-value\">Getting Signal's current value</a></li>\n</ul>\n</li>\n<li><a href=\"#relationship-between-eventstream-and-signal\">Relationship between EventStream and Signal</a></li>\n<li><a href=\"#observer\">Observer</a></li>\n<li><a href=\"#ownership\">Ownership</a>\n<ul dir=\"auto\">\n<li><a href=\"#ownership--memory-management\">Ownership &amp; Memory Management</a></li>\n<li><a href=\"#onetimeowner\">OneTimeOwner</a></li>\n<li><a href=\"#manualowner\">ManualOwner</a></li>\n<li><a href=\"#dynamic-ownership\">Dynamic Ownership</a></li>\n</ul>\n</li>\n<li><a href=\"#sources-of-events\">Sources of Events</a>\n<ul dir=\"auto\">\n<li><a href=\"#creating-observables-from-futures\">Creating Observables from Futures and Promises</a></li>\n<li><a href=\"#eventstreamfromseq\">EventStream.fromSeq</a></li>\n<li><a href=\"#eventstreamperiodic\">EventStream.periodic</a></li>\n<li><a href=\"#eventstreamempty\">EventStream.empty</a></li>\n<li><a href=\"#eventstreamwithcallback-and-withobserver\">EventStream.withCallback and withObserver</a></li>\n<li><a href=\"#eventbus\">EventBus</a></li>\n<li><a href=\"#var\">Var</a></li>\n<li><a href=\"#val\">Val</a></li>\n<li><a href=\"#fetchstream\">FetchStream</a></li>\n<li><a href=\"#ajax\">Ajax</a></li>\n<li><a href=\"#websockets\">Websockets</a></li>\n<li><a href=\"#dom-events\">DOM Events</a></li>\n<li><a href=\"#custom-event-sources\">Custom Event Sources</a></li>\n<li><a href=\"#extending-observables\">Extending Observables</a></li>\n</ul>\n</li>\n<li><a href=\"#sources--sinks\">Sources &amp; Sinks</a></li>\n<li><a href=\"#frp-glitches\">FRP Glitches</a>\n<ul dir=\"auto\">\n<li><a href=\"#other-libraries\">Other Libraries</a></li>\n<li><a href=\"#topological-rank\">Topological Rank</a></li>\n<li><a href=\"#transactions\">Transactions</a></li>\n<li><a href=\"#avoiding-glitches-when-merging\">Avoiding Glitches When Merging</a></li>\n<li><a href=\"#scheduling-of-transactions\">Scheduling of Transactions</a></li>\n</ul>\n</li>\n<li><a href=\"#operators\">Operators</a>\n<ul dir=\"auto\">\n<li><a href=\"#distinction-operators\">Distinction Operators</a></li>\n<li><a href=\"#n-arity-operators\">N-arity Operators</a></li>\n<li><a href=\"#compose-changes\">Compose Changes</a></li>\n<li><a href=\"#sync-delay\">Sync Delay</a></li>\n<li><a href=\"#splitting-observables\">Splitting Observables</a></li>\n<li><a href=\"#splitting-vars\">Splitting Vars</a></li>\n<li><a href=\"#async-status-operators\">Async Status Operators</a></li>\n<li><a href=\"#specialized-type-operators\">Specialized Type Operators</a> for Option-s, Either-s, Try-s, etc.</li>\n<li><a href=\"#flattening-observables\">Flattening Observables</a></li>\n<li><a href=\"#other-notable-operators\">Other Notable Operators</a></li>\n</ul>\n</li>\n<li><a href=\"#operators-vs-transactions\">Operators vs Transactions</a>\n<ul dir=\"auto\">\n<li><a href=\"#flowy-operators\">Flowy Operators</a></li>\n<li><a href=\"#async-operators\">Async Operators</a></li>\n<li><a href=\"#loopy-operators\">Loopy Operators</a></li>\n</ul>\n</li>\n<li><a href=\"#restarting-observables\">Restarting Observables</a>\n<ul dir=\"auto\">\n<li><a href=\"#signals-re-syncing-on-restart\">Signals Re-Syncing on Restart</a></li>\n<li><a href=\"#restarting-streams\">Restarting Streams</a></li>\n<li><a href=\"#restarting-streams-that-depend-on-signals-signalchanges\">Restarting Streams That Depend on Signals (signal.changes)</a></li>\n<li><a href=\"#restarting-signals-that-depend-on-streams\">Restarting Signals That Depend on Streams</a></li>\n<li><a href=\"#stopping-is-actually-pausing\">Stopping is Actually Pausing</a></li>\n<li><a href=\"#signals-that-keep-updating-when-stopped\">Signals That Keep Updating When Stopped</a></li>\n</ul>\n</li>\n<li><a href=\"#debugging\">Debugging</a></li>\n<li><a href=\"#error-handling\">Error Handling</a></li>\n</ul>\n</li>\n<li><a href=\"#limitations\">Limitations</a></li>\n<li><a href=\"#my-related-projects\">My Related Projects</a></li>\n</ul>\n<div class=\"markdown-heading\" dir=\"auto\"><h2 class=\"heading-element\" dir=\"auto\">Community</h2><a id=\"user-content-community\" class=\"anchor\" aria-label=\"Permalink: Community\" href=\"#community\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<ul dir=\"auto\">\n<li><a href=\"https://discord.gg/JTrUxhq7sj\" rel=\"nofollow\">Discord</a> for chat and random questions (Airstream shares this server with <a href=\"https://laminar.dev\" rel=\"nofollow\">Laminar</a>)</li>\n<li><a href=\"https://github.com/raquo/Airstream/discussions\">Github discussions</a> for more in-depth discussions</li>\n<li><a href=\"https://github.com/raquo/Airstream/issues\">Github issues</a> for bugs, feature requests</li>\n</ul>\n<div class=\"markdown-heading\" dir=\"auto\"><h2 class=\"heading-element\" dir=\"auto\">Documentation</h2><a id=\"user-content-documentation\" class=\"anchor\" aria-label=\"Permalink: Documentation\" href=\"#documentation\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><a href=\"https://javadoc.io/doc/com.raquo/airstream_sjs1_3/latest/com/raquo/airstream/index.html\" rel=\"nofollow\">API doc</a></p>\n<p dir=\"auto\">This documentation explains not only the functionality that <em>Airstream</em> offers, but also how it works, and the design tradeoffs involved. Nevertheless, if you need a primer on reactive programming using streams, consider <a href=\"https://gist.github.com/staltz/868e7e9bc2a7b8c1f754\">this guide</a> by André Staltz or its <a href=\"https://egghead.io/courses/introduction-to-reactive-programming\" rel=\"nofollow\">video adaptation</a>.</p>\n<p dir=\"auto\">This documentation is intended to be read top to bottom, sections further down the line assume knowledge of concepts and behaviours introduced in earlier sections.</p>\n<p dir=\"auto\">For examples of Airstream usage, see <a href=\"https://demo.laminar.dev\" rel=\"nofollow\">Laminar Demo</a>, <a href=\"https://github.com/raquo/Laminar\">Laminar</a> source code, as well as Laminar's and Airstream's test suites.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">EventStream</h3><a id=\"user-content-eventstream\" class=\"anchor\" aria-label=\"Permalink: EventStream\" href=\"#eventstream\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">EventStream is a reactive variable that represents a stream of discrete events.</p>\n<p dir=\"auto\">EventStream has no concept of \"current value\". It is a stream of discrete events, and there is no such thing as a \"current event\".</p>\n<p dir=\"auto\">EventStream is a <strong>lazy</strong> observable. That means that it will not receive or process events unless it has at least one Observer listening to it (more on this below).</p>\n<p dir=\"auto\">Generally, when you add an Observer to a stream, it starts to send events to the observer from that point on.</p>\n<p dir=\"auto\">The result of calling <code>observable.addObserver(observer)(owner)</code> or <code>observable.foreach(onNext)(owner)</code> is a Subscription. To remove the observer manually, you can call <code>subscription.kill()</code>, but usually it's the <code>owner</code>'s job to do that. Hold that thought for now, read about owners later in the <a href=\"#ownership\">Ownership</a> section.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">Laziness</h3><a id=\"user-content-laziness\" class=\"anchor\" aria-label=\"Permalink: Laziness\" href=\"#laziness\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Before exploring Signals, the other kind of Observable, let's outline how exactly laziness works in Airstream. All Airstream Observables are lazy, but we will use EventStream-s here to make our explanation less abstract.</p>\n<p dir=\"auto\">Every Observable has zero or more observers – both \"external\" observers that you add manually using <code>addObserver</code> or <code>foreach</code> methods, and InternalObserver-s representing dependant observables. More on those soon.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Starting Observables</h4><a id=\"user-content-starting-observables\" class=\"anchor\" aria-label=\"Permalink: Starting Observables\" href=\"#starting-observables\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">When a stream acquires its first observer (does not matter if external or internal), it is said to be <strong>started</strong>. So when you call <code>addObserver</code> on a stream for the first time, you <strong>start</strong> the stream. Airstream will then call the <code>stream.onStart</code> method, which must ensure that this stream wakes up and starts working. Someone started observing (caring about the output of) this stream – and so the stream must ensure that the events start coming in.</p>\n<p dir=\"auto\">Usually the stream accomplishes that by adding an InternalObserver to the parent (upstream) stream – the stream on which this one depends. For example, let's consider this scenario:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val foo: EventStream[Foo] = ???\nval bar: EventStream[Bar] = foo.map(fooToBar)\nval baz: EventStream[Baz] = bar.map(barToBaz)\nval qux: EventStream[Qux] = baz.map(bazToQux)\nval rap: EventStream[Rap] = qux.map(quxToRap)\n\nbaz.addObserver(bazObserver)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">foo</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Foo</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">bar</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Bar</span>] <span class=\"pl-k\">=</span> foo.map(fooToBar)\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">baz</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Baz</span>] <span class=\"pl-k\">=</span> bar.map(barToBaz)\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">qux</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Qux</span>] <span class=\"pl-k\">=</span> baz.map(bazToQux)\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">rap</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Rap</span>] <span class=\"pl-k\">=</span> qux.map(quxToRap)\n\nbaz.addObserver(bazObserver)</pre></div>\n<p dir=\"auto\">Until <code>baz.addObserver(bazObserver)</code> was called, these streams would not be receiving or emitting any events because they have no observers, internal or external. After <code>baz.addObserver</code> is called, an external observer <code>bazObserver</code> is added to <code>baz</code>, starting it. Then, <code>baz.onStart</code> is called, adding <code>baz</code> as an InternalObserver to <code>bar</code>. <code>baz</code> will now receive and process any events emitted by <code>bar</code>.</p>\n<p dir=\"auto\">But this means that <code>bar</code> just got its first observer – even if an internal one, it still matters – someone started caring, even if indirectly. So its <code>onStart</code> method is called, and it adds <code>bar</code> as the first InternalObserver to <code>foo</code>. Now, <code>foo</code> is started as well, and its <code>onStart</code> method does <em>something</em> to ensure that <code>foo</code> will now start sending out events. We don't actually know what <code>foo</code>'s <code>onStart</code> method does because we didn't define <code>foo</code>'s implementation. For example, it could be adding a DOM listener to a DOM element.</p>\n<p dir=\"auto\">Now we see how adding an observer resulted in a chain of activations of all upstream streams that were required, directly or indirectly, to get the events out of the stream we actually wanted to observe. The <code>onStart</code> method ensured – recursively – that the observed stream is now running.</p>\n<p dir=\"auto\">Adding another observer to the now already running streams – <code>foo</code> or <code>bar</code> or <code>baz</code> – would not need to cause such a chain reaction because the stream to which it is being added already has observers (internal or external).</p>\n<p dir=\"auto\">Lastly, notice that the <code>qux</code> and <code>rap</code> streams are untouched by all this. No one cares for their output yet, so those streams will not receive any events, and neither <code>bazToQux</code> nor <code>quxToRap</code> will ever run (well, not until we add observers that need them to run, directly or indirectly).</p>\n<p dir=\"auto\">On a lower level, how exactly is it that <code>qux</code> will not run? Put simply, it needs to be getting events from <code>baz</code> to process them and produce its own events, but it's getting nothing from <code>baz</code> simply because at this point <code>baz</code> does not know that <code>qux</code> exists. <code>baz</code> sends out its events to all of its observers, but so far nothing added <code>qux</code> as an observer to <code>baz</code>.</p>\n<p dir=\"auto\">For extra clarity, while the stream <code>rap</code> does depend on <code>qux</code>, <code>rap</code> itself has no observers, so it is <strong>stopped</strong>. Nothing started it yet, and so nothing triggered its <code>onStart</code> method which would have added <code>rap</code> as an InternalObserver to <code>qux</code>, starting <code>qux</code> recursively as described above.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Stopping Observables</h4><a id=\"user-content-stopping-observables\" class=\"anchor\" aria-label=\"Permalink: Stopping Observables\" href=\"#stopping-observables\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Just like Observers can be added to streams, they can also be removed, e.g. with <code>subscription.kill()</code>. When you remove the last observer (internal or external) from a stream, the stream is said to be <strong>stopped</strong>. The same domino effect as when starting streams applies, except the <code>onStop</code> method recursively undoes everything that was done by <code>onStart</code> – instead of adding an InternalObserver to parent stream, we remove it, and if that causes the grand-parent stream to be stopped, we call its <code>onStop</code> method, and the chain continues upstream.</p>\n<p dir=\"auto\">When the dust settles, streams that are now without observers (internal or external) will be stopped, and those that still have observers will otherwise be untouched, except they will stop referencing the now-stopped observables in their lists of internal observers.</p>\n<p dir=\"auto\">Very often, an observable is started, used for a while, then stopped, and is discarded afterwards, never to be used again. However, Airstream does support restarting previously stopped observables, and Laminar has good use cases for that. <a href=\"#restarating-observabels\">Restarting Observables</a> is an advanced topic that you can read about after you get a good understanding of other Airstream concepts like transactions.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Memory Management Implications</h4><a id=\"user-content-memory-management-implications\" class=\"anchor\" aria-label=\"Permalink: Memory Management Implications\" href=\"#memory-management-implications\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Every observable that depends on another – parent, or upstream observable, – always has a reference to that parent, regardless of whether it's started or stopped.</p>\n<p dir=\"auto\">However, the parent/upstream observable has no references to its child/downstream observable(s) until the child observable is started. Only then does the parent obtain a reference to the child, adding it to the list of its internal observers.</p>\n<p dir=\"auto\">This has straightforward memory management implications: nothing in Airstream is keeping references to <em>stopped</em> observables. So, if you don't have any of your own references to a stopped Observable, it will be garbage collected, as expected.</p>\n<p dir=\"auto\">However, a <em>started</em> observable has additional references to it from:</p>\n<ol dir=\"auto\">\n<li>The parent/upstream observable on which this observable depends (via the parent's list of internal observers)</li>\n<li>The Subscription objects created by <code>addObserver</code> or <code>foreach</code> calls on this observable, if this observable has external observers. Those subscriptions are in turn referenced by their Owner-s (more on those later)</li>\n</ol>\n<p dir=\"auto\">Remember that if a given observable is started, its parent is also guaranteed to be started, and so on. This creates a potentially long chain of observables that typically terminate with external observers on the downstream end, and some kind of event producer on the upstream end. All of these reference each other, directly or indirectly, and so will not be garbage collected unless there are no more references in your program to <em>any</em> observable or observer in this whole graph.</p>\n<p dir=\"auto\">Now imagine that in the chain of activated observables mentioned above the most downstream observable is related to a UI component that has since then been destroyed. You would want that now-irrelevant observable to be stopped in order for it to be garbage collected, since it's not needed anymore, but it will continue to run for as long as it has its observer. And if you forgot to remove that observer when you destroyed the UI component it related to, you got yourself a memory leak.</p>\n<p dir=\"auto\">This is a common memory management pattern for almost all streaming libraries out there, so this should come as no surprise to anyone familiar with event streams.</p>\n<p dir=\"auto\">Some reactive UI libraries such as Outwatch give you a way to bind the lifecycle of subscriptions to the lifecycle of corresponding UI components, and that automatically kills the subscription (removes the observer) when the UI component it relates to is destroyed. However, the underlying streaming libraries that such UI libraries use have no concept of such binding, and so in those libraries you can manually call <code>stream.addObserver</code> and create a subscription that will not be automatically killed when the UI component that it conceptually relates to is unmounted.</p>\n<p dir=\"auto\">What makes Airstream special is a built-in concept of ownership. When creating a leaky resource, e.g. when calling <code>addObserver</code>, you <em>have to</em> also provide a reference to an Owner who will eventually kill the subscription. For example, that owner could be a UI component to which the subscription relates, and it could automatically kill all subscriptions that it owns when it is destroyed, allowing the now-irrelevant observables to be stopped and garbage collected. This is essentially how <a href=\"https://github.com/raquo/Laminar\">Laminar</a>'s <code>ReactiveElement</code> works. For more details, see the <a href=\"#ownership\">Ownership</a> section.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">Signal</h3><a id=\"user-content-signal\" class=\"anchor\" aria-label=\"Permalink: Signal\" href=\"#signal\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Signal is a reactive variable that represents a time-varying value, or an accumulated value. In other words, \"state\".</p>\n<p dir=\"auto\">Similar to EventStream, Signal is <strong>lazy</strong>, so everything in the <a href=\"#laziness\">Laziness</a> section applies to Signals as well.</p>\n<p dir=\"auto\">Unlike EventStream, a Signal always has a current value. For instance, you could create a Signal by calling <code>val signal = eventStream.startWith(initialValue)</code>. In that example, <code>signal</code>'s current value would first equal to <code>initialValue</code>, and then any time <code>eventStream</code> emits a value, <code>signal</code>'s current value would be updated to the emitted value, and then <code>signal</code> would emit this new current value.</p>\n<p dir=\"auto\">However, all of that would only happen if <code>signal</code> had one or more observers (because of <a href=\"#laziness\">Laziness</a>). If <code>signal</code> had no observers, its current value would be stuck at the last current value it saved while it had observers, or at <code>initialValue</code> if it <em>never</em> had observers.</p>\n<p dir=\"auto\">When adding an Observer to a Signal, the observer will immediately receive the signal's current value, as well as any future values. If you don't want the observer to receive the current value, observe the stream <code>signal.changes</code> instead.</p>\n<p dir=\"auto\">Note: Signal's initial value is evaluated lazily. For example:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val fooStream: EventStream[Foo] = ???\nval fooSignal: Signal[Foo] = fooStream.startWith(myFoo)\nval barSignal: Signal[Bar] = fooSignal.map(fooToBar)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">fooStream</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Foo</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">fooSignal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">Foo</span>] <span class=\"pl-k\">=</span> fooStream.startWith(myFoo)\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">barSignal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">Bar</span>] <span class=\"pl-k\">=</span> fooSignal.map(fooToBar)</pre></div>\n<p dir=\"auto\">In this example, <code>barSignal</code>'s initial value would be equal to <code>fooToBar(myFoo)</code>, but that expression will not be evaluated until it is needed (i.e. until <code>barSignal</code> acquires an observer). And once evaluated, it will not be re-evaluated again.</p>\n<p dir=\"auto\">Similarly, <code>myFoo</code> expression will <em>not</em> be evaluated immediately as it is passed by name. It will only be evaluated if and when it is needed (e.g. to pass it down to an observer of <code>barSignal</code>).</p>\n<hr>\n<p dir=\"auto\">Note: before Airstream 15, Signal only fired an event when its next value was different from its current value. The comparison was made using Scala's <code>==</code> operator. If you see references to \"signals' <code>==</code> checks\" in past issues / discussions, this is what they're talking about. In v15.0.0, this built-in auto-distinction filter is eliminated (see <a href=\"https://laminar.dev/blog/2023/03/22/laminar-v15.0.0#no-more-automatic--checks-in-signals\" rel=\"nofollow\">blog post</a>), and you need to explicitly use one of the <a href=\"#distinction-operators\">distinction operators</a> to achieve such behaviour.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Getting Signal's current value</h4><a id=\"user-content-getting-signals-current-value\" class=\"anchor\" aria-label=\"Permalink: Getting Signal's current value\" href=\"#getting-signals-current-value\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">See relevant RFC: <a href=\"https://github.com/raquo/Laminar/issues/130\" data-hovercard-type=\"issue\" data-hovercard-url=\"/raquo/Laminar/issues/130/hovercard\">signal.peekNow()</a></p>\n<p dir=\"auto\">Signal's laziness means that its current value might get stale / inconsistent in the absence of observers. Airstream therefore does not allow you to access a Signal's current value <em>without proving that it has observers</em>.</p>\n<p dir=\"auto\">You can use <code>stream.withCurrentValueOf(signal).mapN((lastStreamEvent, signalCurrentValue) =&gt; ???)</code> to access <code>signal</code>'s current value. The resulting stream will still be lazy, but this way the processing of <code>currentValue</code> is just as lazy as <code>currentValue</code> itself, so there is no risk of looking at a stale <code>currentValue</code>.</p>\n<p dir=\"auto\">If you don't need lastStreamEvent, use <code>stream.sample(signal).map(signalCurrentValue =&gt; ???)</code> instead. Note: both of these output streams will emit only when <code>stream</code> emits, as documented in the code. If you want updates from signal to also trigger an event, look into the <code>combineWith</code> operator.</p>\n<p dir=\"auto\">Note: <code>withCurrentValueOf</code> and <code>sample</code> operators are also available on signals, not just streams.</p>\n<p dir=\"auto\">If you want to get a Signal's current value without the complications of sampling, or even if you just want to make sure that a Signal is started, just call <code>observe</code> on it. That will add a noop observer to the signal, and return an <code>OwnedSignal</code> instance which being a <code>StrictSignal</code>, does expose <code>now()</code> and <code>tryNow()</code> methods that safely provide you with its current value. However, you will need to provide an <code>Owner</code> to do that. More on those later.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">Relationship between EventStream and Signal</h3><a id=\"user-content-relationship-between-eventstream-and-signal\" class=\"anchor\" aria-label=\"Permalink: Relationship between EventStream and Signal\" href=\"#relationship-between-eventstream-and-signal\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Signals and EventStreams are distinct concepts with different use cases as described above, but both are Observables.</p>\n<p dir=\"auto\">You can <code>scanLeft(initialValue)(fn)</code> an EventStream into a Signal, or make a Signal directly with <code>stream.startWith(initialValue)</code>, or <code>stream.startWithNone</code> (which creates a \"weak\" signal, one that initially starts out with <code>None</code>, and has events wrapped in <code>Some</code>).</p>\n<p dir=\"auto\">You can get an EventStream of changes from a Signal – <code>signal.changes</code> – this stream will re-emit whatever the parent signal emits (subject to laziness of the stream), minus the Signal's initial value.</p>\n<p dir=\"auto\">If you have an observable, you can refine it to a Signal with <code>Observable#toWeakSignal</code> or <code>Observable#toSignalIfStream(ifStream = streamToSignal)</code>, and to a Stream with <code>Observable#toStreamIfSignal(ifSignal = signalToStream)</code>. For example, if you want to convert <code>Observable[String]</code> into <code>Signal[String]</code> with empty string as initial value in case this Observable is a stream, use <code>observable.toSignalIfStream(_.startWith(\"\"))</code>.</p>\n<p dir=\"auto\">See also: <a href=\"#sources--sinks\">Sources &amp; Sinks</a></p>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">Observer</h3><a id=\"user-content-observer\" class=\"anchor\" aria-label=\"Permalink: Observer\" href=\"#observer\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><code>Observer[A]</code> is a modest wrapper around an <code>onNext: A =&gt; Unit</code> callback that represents an <em>external</em> observer (see sections above for the distinction with InternalObserver-s). Observers have no knowledge of which observables, if any, they're observing, they have no power to choose whether they want to observe a given observable, etc.</p>\n<p dir=\"auto\">Observers are intended to contain side effects, and to trigger evaluation of observables by their presence (remember, all Observables are lazy).</p>\n<p dir=\"auto\">You usually create observers with <code>Observer.apply</code> or <code>myObservable.foreach</code>. There are a few more methods on Observer that support <a href=\"#error-handling\">error handling</a>.</p>\n<p dir=\"auto\">Observers have a few convenience methods:</p>\n<p dir=\"auto\"><code>def contramap[B](project: B =&gt; A): Observer[B]</code> – This is useful for separation of concerns. For example your Ajax service might expose an <code>Observer[Request]</code>, but you don't want a simple <code>UserProfile</code> component to know about your Ajax implementation details (<code>Request</code>), so you can instead provide it with <code>requestObserver.contramap(makeUpdateRequest)</code> which is a <code>Observer[User]</code>.</p>\n<p dir=\"auto\"><code>def filter(passes: A =&gt; Boolean): Observer[A]</code> – useful if you have an <code>Observable</code> that you need to observe while filtering out some events (there is no <code>Observable.filter</code> method, only <code>EventStream.filter</code>).</p>\n<p dir=\"auto\"><code>def contramapSome</code> is just an easy way to get <code>Observer[A]</code> from <code>Observer[Option[A]]</code></p>\n<p dir=\"auto\"><code>def contracollect[B](pf: PartialFunction[B, A]): Observer[B]</code> – when you want to both <code>contramap</code> and <code>filter</code> at once.</p>\n<p dir=\"auto\"><code>def contracollectOpt[B](project: B =&gt; Option[A]): Observer[B]</code> – like <code>contracollect</code> but designed for APIs that return Options, such as <code>NonEmptyList.fromList</code>.</p>\n<p dir=\"auto\"><code>delay(ms: Int)</code> – creates an observer that calls the original observer after the specified delay (for both events and errors)</p>\n<p dir=\"auto\"><code>Observer.combine[A](observers: Observer[A])</code> creates an observer that triggers all of the observers provided to it. Unlike <code>Observer[A](nextValue =&gt; observers.foreach(_.onNext(nextValue)))</code>, the combined observer will also trigger its child observers in case of <code>.onError</code> (more about that in <a href=\"#error-handling\">Error Handling</a>).</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">Ownership</h3><a id=\"user-content-ownership\" class=\"anchor\" aria-label=\"Permalink: Ownership\" href=\"#ownership\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Alright, this is it. By now you've read enough to have many questions about how ownership works. This assumes you've read all the docs above, but to recap the core problem that ownership solves:</p>\n<ul dir=\"auto\">\n<li>Adding an <code>Observer</code> to the lazily evaluated <code>Observable</code> is a leaky operation. That is, these resources will not be garbage collected even if the observable and the observer are both unreachable to <em>user</em> code. This is because the observable's parent observables will keep an internal reference to it for as long as it has observers.</li>\n<li>Therefore, without Ownership you would have needed to remember to remove the observers that you added when the observers are no longer needed.</li>\n<li>But doing that manually is insane, you will eventually forget and cause memory leaks and undesired behaviour. You should not need to take out your own garbage in a garbage collected language.</li>\n</ul>\n<p dir=\"auto\">If any of the above does not make sense, the rest of this section might be confusing. Make sure you at least understand the entirety of the <a href=\"#laziness\">Laziness</a> section before proceeding.</p>\n<p dir=\"auto\">Without further ado:</p>\n<p dir=\"auto\"><strong>Subscription</strong> is a resource that must be killed in order to release memory or prevent some other leak. You can get it by calling <code>observable.addObserver(observer)</code>, <code>writeBus.addSource(stream)</code>, or other similar methods that all take an implicit <code>owner</code> param.</p>\n<p dir=\"auto\">Every Subscription has an <strong>Owner</strong>. An Owner is an object that keeps track of its subscriptions and knows when to kill them, and kills them <em>when it's time</em> (determined at its sole discretion). Airstream does not offer any concrete Owner classes (aside from the very basic <code>ManualOwner</code>), just the base trait. Unless you use <a href=\"#dynamic-ownership\">Dynamic Ownership</a>, you need to instantiate (and thus implement) your own Owner-s.</p>\n<p dir=\"auto\">For example, until v0.8, my reactive UI library <a href=\"https://github.com/raquo/Laminar\">Laminar</a>'s <code>ReactiveElement</code> (a wrapper class for managing a JS DOM Element) used to implement <code>Owner</code>. When a <code>ReactiveElement</code> was discarded (unmounted from the DOM), it would kill all of its <code>subscriptions</code>, i.e. all the Subscriptions that were bound to its lifetime. That would remove the observers that those subscriptions installed on the observables, stopping them if they have no other observers. Note: Laminar switched to <a href=\"#dynamic-ownership\">Dynamic Ownership</a> in v0.8 (more on that later).</p>\n<p dir=\"auto\">When creating a Subscription, you can perform whatever leaky operations you wanted, and just provide the <code>cleanup</code> method to perform any required cleanup.</p>\n<p dir=\"auto\">Subscriptions are bound to a specific Owner upon the creation of the Subscription, and this link stays unchanged for the lifetime of the Subscription.</p>\n<p dir=\"auto\">Subscriptions are normally killed <em>by their Owner</em>, but you can also <code>.kill()</code> the subscription manually. The Owner will be notified about this via <code>owner.onKilledExternally(subscription)</code> so that it can drop the reference to the killed <code>subscription</code> from its list.</p>\n<p dir=\"auto\">Killing the same Subscription more than once throws an exception, don't do it.</p>\n<p dir=\"auto\">Built-in Owner carefully tracks a list of its subscriptions, making sure to call the right hooks, and create and dispose the right references for memory management. If you extend Owner and change that logic, memory management of that owner and its subscriptions is on you. Generally you shouldn't need to mess with any of that logic though, just make sure to call <code>killSubscriptions</code> when it's time.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Ownership &amp; Memory Management</h4><a id=\"user-content-ownership--memory-management\" class=\"anchor\" aria-label=\"Permalink: Ownership &amp; Memory Management\" href=\"#ownership--memory-management\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">In broad terms, ownership solves memory leaks by tying the lifecycle of Subscriptions which would be otherwise hard to track manually to the lifecycle of an Owner which is expected to be tracked automatically by a UI library like Laminar.</p>\n<p dir=\"auto\">In practice, Airstream's memory management has no magic to it. It uses Javascript's standard garbage collection, same as the rest of your Scala.js code. You just need to understand what references what, and the documentation here explains it.</p>\n<p dir=\"auto\">For example, a Subscription created by <code>observable.addObserver</code> method keeps references to both the Observable and the Observer (via the function passed as its <code>cleanup</code> param). That means that if you're keeping a reference to a Subscription, you're also keeping those references. Given that the Subscription has a <code>kill</code> method that lets you remove the observer from the observable, the presence of these references should be obvious. So like I said – no magic, you just need to internalize the basic ideas of lazy observables, just like you've already internalized the basic ideas of classes and functions.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">OneTimeOwner</h4><a id=\"user-content-onetimeowner\" class=\"anchor\" aria-label=\"Permalink: OneTimeOwner\" href=\"#onetimeowner\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">The basic <code>Owner</code> trait provides a high degree of flexibility, and therefore lacks some behaviour that you might expect in Owners.</p>\n<p dir=\"auto\">For example, you can kill an <code>Owner</code> multiple times. Every time you do, its subscriptions will be killed, and the list of subscriptions cleared, but the <code>Owner</code> will remain usable after that, letting you add more subscriptions and kill them again later.</p>\n<p dir=\"auto\">If you want an Owner that can only be killed once, and does not let you add subscriptions to it after it was killed, use the <code>OneTimeOwner</code> class instead. DynamicOwner below uses OneTimeOwner, and that is how Laminar provides element Owners that can not be used after the element is unmounted and its owner is killed.</p>\n<p dir=\"auto\">If you try to create a subscription that uses a OneTimeOwner, the subscription will be killed immediately, and <code>OneTimeOwner</code>'s <code>onAccessAfterKilled</code> callback will be fired. You can throw in that callback, then subscription initialization will throw too.</p>\n<p dir=\"auto\">Note that the subscription itself does not contain any activation logic (i.e. what needs to happen when subscription is activated), that user-provided logic is external to subscription initialization, and is typically run <strong>before</strong> the subscription is initialized, so before <code>OneTimeOwner</code> can prevent that from happening. So when try to use a dead OneTimeOwner, instead of completely ignoring the effective payload of the subscription, unless you take special measures, it will still execute, but the subscription will be cancelled and cleaned up immediately. But if the subscription's payload was to e.g. make a network request, you can't put that back in the bottle.</p>\n<p dir=\"auto\">Bottom line, you should not be deliberately sending events to dead <code>OneTimeOwner</code>-s. They just fix what otherwise could be a memory leak, not completely prevent your code from running. They report the error so that you can fix your code that's doing this.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">ManualOwner</h4><a id=\"user-content-manualowner\" class=\"anchor\" aria-label=\"Permalink: ManualOwner\" href=\"#manualowner\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">The basic <code>Owner</code> trait also doesn't allow external code to kill it, because some owners are supposed to manage themselves. All you need to overcome that is expose the <code>killSubscriptions</code> method to the public, or just use the <code>ManualOwner</code> class that does this.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Dynamic Ownership</h4><a id=\"user-content-dynamic-ownership\" class=\"anchor\" aria-label=\"Permalink: Dynamic Ownership\" href=\"#dynamic-ownership\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Dynamic Ownership is not a replacement for standard Ownership described above. Rather, it is a self-contained feature built on top of regular Ownership. No APIs in Airstream itself require Dynamic Ownership, it is intended to be consumed by the user or by other libraries depending on Airstream.</p>\n<p dir=\"auto\">The premise of Dynamic Ownership is similar to that of regular ownership: you can create <code>DynamicSubscription</code>-s owned by <code>DynamicOwner</code>-s. Here is what's different:</p>\n<p dir=\"auto\">Regular <code>Subscription</code>-s can never recover from being <code>kill()</code>-ed, whereas <code>DynamicSubscription</code>-s can be activated and deactivated, and then activated again, and so on, as many times as their <code>DynamicOwner</code> wants. For example:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val stream: EventStream[Int] = ???\nval observer: Observer[Int] = ???\n \nval dynOwner = new DynamicOwner\n \nval dynSub = DynamicSubscription.unsafe(\n  dynOwner,\n  activate = (owner: Owner) =&gt; stream.addObserver(observer)(owner)\n)\n \n// Run dynSub's activate method and save the resulting non-dynamic Subscription\ndynOwner.activate()\n \n// Kill the regular Subscription that we saved \ndynOwner.deactivate()\n \n// Run dynSub's activate method again, obtaining a new Subscription\ndynOwner.activate()\n \n// Kill the new Subscription that we saved \ndynOwner.deactivate()\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">stream</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">observer</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Observer</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n \n<span class=\"pl-k\">val</span> <span class=\"pl-v\">dynOwner</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-en\">DynamicOwner</span>\n \n<span class=\"pl-k\">val</span> <span class=\"pl-v\">dynSub</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">DynamicSubscription</span>.unsafe(\n  dynOwner,\n  activate <span class=\"pl-k\">=</span> (<span class=\"pl-v\">owner</span>: <span class=\"pl-en\">Owner</span>) <span class=\"pl-k\">=&gt;</span> stream.addObserver(observer)(owner)\n)\n \n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Run dynSub's activate method and save the resulting non-dynamic Subscription</span>\ndynOwner.activate()\n \n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Kill the regular Subscription that we saved </span>\ndynOwner.deactivate()\n \n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Run dynSub's activate method again, obtaining a new Subscription</span>\ndynOwner.activate()\n \n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Kill the new Subscription that we saved </span>\ndynOwner.deactivate()</pre></div>\n<p dir=\"auto\">Every time a <code>DynamicOwner</code> is <code>activate()</code>-d, it creates a new <code>OneTimeOwner</code>, and uses it to <code>activate</code> every <code>DynamicSubscription</code> that it owns. It saves the resulting non-dynamic <code>Subscription</code>, which the <code>DynamicOwner</code> later <code>kills()</code> when it's <code>deactivate()</code>-d.</p>\n<p dir=\"auto\">Now you can see how this integrates with regular ownership. Anything that requires a non-dynamic <code>Owner</code> produces a <code>Subscription</code>. So to create a <code>DynamicSubscription</code> you need to provide an <code>activate</code> method that does this. That could be a call to <code>addObserver</code>, <code>addSource</code>, etc.</p>\n<p dir=\"auto\">As a result, we have a dynamic owner that can add or remove <code>observer</code> from <code>stream</code> at any time. In Laminar starting with v0.8 every ReactiveElement has a <code>DynamicOwner</code>. When the element is mounted, that owner is activated, activating all dynamic subscriptions using a newly created non-dynamic owner. Then when the element is later unmounted, those subscriptions are deactivated, removing observers from observables, sources from event buses, etc.</p>\n<p dir=\"auto\">Previously in Laminar v0.7 every ReactiveElement used to extend the non-dynamic <code>Owner</code>, so once it was unmounted, all the subscriptions were killed forever, so if the user re-mounted that element, its subscriptions would not have come back to life. But now that Laminar uses Dynamic Ownership, you can re-mount previously unmounted elements, and their dynamic subscriptions will spring back to life.</p>\n<p dir=\"auto\">Note that a <code>DynamicSubscription</code> is not automatically activated upon creation. Its DynamicOwner controls its activation and deactivation. You can still permanently <code>kill()</code> a DynamicSubscription manually – it will be deactivated if it's currently active, and removed from its DynamicOwner.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Dynamic Ownership &amp; Memory Management</h5><a id=\"user-content-dynamic-ownership--memory-management\" class=\"anchor\" aria-label=\"Permalink: Dynamic Ownership &amp; Memory Management\" href=\"#dynamic-ownership--memory-management\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">I created Dynamic Ownership specifically to solve this long-standing Laminar <a href=\"https://github.com/raquo/Laminar/issues/33\" data-hovercard-type=\"issue\" data-hovercard-url=\"/raquo/Laminar/issues/33/hovercard\">memory management issue</a>: if a non-dynamic Subscription is created when ReactiveElement is initialized, and is killed when that element is unmounted, what happens to elements that get initialized but are never mounted into the DOM? That's right, their subscriptions are never killed (because they are technically never unmounted) and so they are essentially never garbage collected.</p>\n<p dir=\"auto\">Laminar v0.8 had to fix this by creating <code>Subscription</code>-s every time the element is mounted, and killing them when the element was unmounted. Long story short, Dynamic Ownership is exactly this, slightly generalized for wider use.</p>\n<p dir=\"auto\">There is really nothing special in Dynamic Ownership memory management. It's just a helper to create and destroy subscriptions repeatedly. In practice DynamicSubscription's activate method generally contains the same references that <code>Subscription</code>'s cleanup method would, so it's all the same considerations as before.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Transferable Subscription</h5><a id=\"user-content-transferable-subscription\" class=\"anchor\" aria-label=\"Permalink: Transferable Subscription\" href=\"#transferable-subscription\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">What, a helper for subscription helpers? Yes, indeed. This one behaves like a <code>DynamicSubscription</code> that lets you transfer it from one active <code>DynamicOwner</code> to another active <code>DynamicOwner</code> without deactivating and re-activating the subscription.</p>\n<p dir=\"auto\">The API is simple:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"class TransferableSubscription(\n  activate: () =&gt; Unit,\n  deactivate: () =&gt; Unit\n) { \n  def setOwner(nextOwner: DynamicOwner): Unit\n  def clearOwner(): Unit\n}\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">TransferableSubscription</span>(\n  <span class=\"pl-v\">activate</span>: () <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">Unit</span>,\n  <span class=\"pl-v\">deactivate</span>: () <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">Unit</span>\n) { \n  <span class=\"pl-k\">def</span> <span class=\"pl-en\">setOwner</span>(<span class=\"pl-v\">nextOwner</span>: <span class=\"pl-en\">DynamicOwner</span>)<span class=\"pl-k\">:</span> <span class=\"pl-en\">Unit</span>\n  <span class=\"pl-k\">def</span> <span class=\"pl-en\">clearOwner</span>()<span class=\"pl-k\">:</span> <span class=\"pl-en\">Unit</span>\n}</pre></div>\n<p dir=\"auto\">Note that you don't get access to <code>Owner</code> in <code>activate</code>. This is the tradeoff required to achieve this flexibility safely. <code>TransferableSubscription</code> is useful in very specific cases when you only care about continuity of active ownership, such as when moving an element from one mounted parent to another mounted parent in Laminar (you wouldn't expect Unmount / Mount events to fire in this case).</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">Sources of Events</h3><a id=\"user-content-sources-of-events\" class=\"anchor\" aria-label=\"Permalink: Sources of Events\" href=\"#sources-of-events\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">We now understand how events propagate through streams and signals, but the events in Airstream have to <em>originate</em> somewhere, right?</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Creating Observables from Futures</h4><a id=\"user-content-creating-observables-from-futures\" class=\"anchor\" aria-label=\"Permalink: Creating Observables from Futures\" href=\"#creating-observables-from-futures\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><code>EventStream.fromFuture[A]</code> creates a stream that emits the value that the future completes with, when that happens.</p>\n<ul dir=\"auto\">\n<li>The event is emitted asynchronously relative to the future's completion</li>\n<li>Creating a stream from an already completed future results in a stream that emits the future's value when it starts.</li>\n</ul>\n<p dir=\"auto\"><code>Signal.fromFuture[A]</code> creates a Signal of <code>Option[A]</code> that emits the value that the future completes with, wrapped in <code>Some()</code>.</p>\n<ul dir=\"auto\">\n<li>The initial value of this signal is always equal to <code>None</code> – even if the future has already completed when the initial value was evaluated. In that case, the initial <code>None</code> will be quickly (but asynchronously) followed by <code>Some(resolvedValue)</code>.</li>\n<li>If the Signal was created from a not yet completed future, the completion event is emitted asynchronously relative to when the future completes, because that is how <code>future.onComplete</code> works.</li>\n<li>Being a <code>StrictSignal</code>, this signal exposes <code>now</code> and <code>tryNow</code> methods that provide its current value. However, note that there is a short asynchronous delay between the completion of the Future and this signal's current value updating, as explained above.</li>\n</ul>\n<p dir=\"auto\"><code>Signal.fromFuture(future, initialValue)</code> is a variation of this method that returns a <code>Signal[A]</code> instead of <code>Signal[Option[A]]</code>. Otherwise, it behaves just as described above, with the initial <code>None</code> replaced by <code>initialValue</code>.</p>\n<p dir=\"auto\">Note that all observables created from futures fire their events in a new transaction because they don't have a parent observable to be synchronous with.</p>\n<p dir=\"auto\">If you have an <code>Observable[Future[A]]</code>, you can flatten it into <code>Observable[A]</code> in a few ways, see <a href=\"#flattening-observables\">Flattening Observables</a>.</p>\n<p dir=\"auto\">A failed future results in an error (see <a href=\"#error-handling\">Error Handling</a>).</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Creating Observables from other Streaming APIs</h4><a id=\"user-content-creating-observables-from-other-streaming-apis\" class=\"anchor\" aria-label=\"Permalink: Creating Observables from other Streaming APIs\" href=\"#creating-observables-from-other-streaming-apis\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><code>EventStream.fromPublisher[A]</code> creates a stream that subscribes to a <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/Flow.Publisher.html\" rel=\"nofollow\">Flow.Publisher</a>, and emits the values that it produces.</p>\n<p dir=\"auto\"><code>Flow.Publisher</code> is a Java <a href=\"http://www.reactive-streams.org/\" rel=\"nofollow\">Reactive Streams</a> interface that is useful for interoperating between streaming APIs. For example, you can transform an <a href=\"https://fs2.io/\" rel=\"nofollow\">FS2</a> <code>Stream[IO, A]</code> into an Airstream <code>EventStream[A]</code>.</p>\n<p dir=\"auto\">The resulting <code>EventStream</code> creates a new <code>Flow.Subscriber</code> and subscribes it to the publisher every time the <code>EventStream</code> is <a href=\"https://github.com/raquo/Airstream#starting-observables\">started</a>, and cancels the subscription when the stream is stopped.</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import cats.effect.unsafe.implicits._ // imports implicit IORuntime\nEventStream.fromPublisher(fs2Stream.unsafeToPublisher())\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-en\">cats</span>.<span class=\"pl-en\">effect</span>.<span class=\"pl-en\">unsafe</span>.<span class=\"pl-en\">implicits</span>.<span class=\"pl-en\">_</span> <span class=\"pl-c\"><span class=\"pl-c\">//</span> imports implicit IORuntime</span>\n<span class=\"pl-en\">EventStream</span>.fromPublisher(fs2Stream.unsafeToPublisher())</pre></div>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\"><code>EventStream.fromJsPromise</code> and <code>Signal.fromJsPromise</code></h4><a id=\"user-content-eventstreamfromjspromise-and-signalfromjspromise\" class=\"anchor\" aria-label=\"Permalink: EventStream.fromJsPromise and Signal.fromJsPromise\" href=\"#eventstreamfromjspromise-and-signalfromjspromise\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Behave the same as <code>fromFuture</code> above, but accept <code>js.Promise</code> instead. Useful for integration with JS libraries and APIs.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\"><code>EventStream.fromSeq</code></h4><a id=\"user-content-eventstreamfromseq\" class=\"anchor\" aria-label=\"Permalink: EventStream.fromSeq\" href=\"#eventstreamfromseq\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"object EventStream {\n  def fromSeq[A](events: Seq[A]): EventStream[A] = ...\n  ...\n}\"><pre><span class=\"pl-k\">object</span> <span class=\"pl-en\">EventStream</span> {\n  <span class=\"pl-k\">def</span> <span class=\"pl-en\">fromSeq</span>[<span class=\"pl-en\">A</span>](<span class=\"pl-v\">events</span>: <span class=\"pl-en\">Seq</span>[<span class=\"pl-en\">A</span>])<span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">A</span>] <span class=\"pl-k\">=</span> ...\n  ...\n}</pre></div>\n<p dir=\"auto\">This method creates an event stream that synchronously emits events from the provided sequence to any newly added observer.</p>\n<p dir=\"auto\">Each event is emitted in a separate transaction, meaning that the propagation of the previous event will fully complete before the propagation of the new event starts.</p>\n<p dir=\"auto\"><strong>Note:</strong> you should avoid using this factory, at least with multiple events. You generally shouldn't need to emit more than one event at the same time like this stream does. If you do, I think your model is likely abusing the concept of \"event\". This method is provided as a kludge until I can make a more confident determination.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\"><code>EventStream.fromValue</code></h4><a id=\"user-content-eventstreamfromvalue\" class=\"anchor\" aria-label=\"Permalink: EventStream.fromValue\" href=\"#eventstreamfromvalue\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Like <code>EventStream.fromSeq</code> (see right above), but only allows for a single event.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\"><code>EventStream.fromTry</code></h4><a id=\"user-content-eventstreamfromtry\" class=\"anchor\" aria-label=\"Permalink: EventStream.fromTry\" href=\"#eventstreamfromtry\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Like <code>EventStream.fromValue</code> (see right above), but also allows an error.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\"><code>EventStream.delay(ms)</code></h4><a id=\"user-content-eventstreamdelayms\" class=\"anchor\" aria-label=\"Permalink: EventStream.delay(ms)\" href=\"#eventstreamdelayms\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Fires a <code>Unit</code>, or another value, if provided, <code>ms</code> milliseconds after the stream is started.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\"><code>EventStream.periodic</code></h4><a id=\"user-content-eventstreamperiodic\" class=\"anchor\" aria-label=\"Permalink: EventStream.periodic\" href=\"#eventstreamperiodic\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">An event stream that emits events at an interval. <code>EventStream.periodic</code> emits the index of the event, starting with <code>0</code> for the initial event that's emitted without delay. If you want to skip the initial event, use <code>.drop(1)</code>. The <code>resetOnStop</code> option (<code>false</code> by default) determines whether the index will be reset to <code>0</code> when the stream is stopped due to lack of observers. You can also reset the stream to any index manually by calling <code>resetTo(value)</code> on it. This will immediately emit this new index.</p>\n<p dir=\"auto\">The underlying <code>PeriodicStream</code> class offers more functionality, including the ability to emit values other than index, set a custom interval for every subsequent event, and stop the stream while it still has observers.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\"><code>EventStream.empty</code></h4><a id=\"user-content-eventstreamempty\" class=\"anchor\" aria-label=\"Permalink: EventStream.empty\" href=\"#eventstreamempty\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">A stream that never emits any events.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\"><code>EventStream.withCallback</code> and <code>withObserver</code></h4><a id=\"user-content-eventstreamwithcallback-and-withobserver\" class=\"anchor\" aria-label=\"Permalink: EventStream.withCallback and withObserver\" href=\"#eventstreamwithcallback-and-withobserver\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><code>EventStream.withCallback[A]</code> creates and returns a tuple of a stream and an <code>A =&gt; Unit</code> callback that, when called, passes the callback's parameter to that stream. Of course, as streams are lazy, the stream will only emit if it has observers.</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val (stream, callback) = EventStream.withCallback[Int]\ncallback(1) // nothing happens because stream has no observers\nstream.foreach(println)\ncallback(2) // `2` will be printed  \"><pre><span class=\"pl-k\">val</span> (stream, callback) <span class=\"pl-k\">=</span> <span class=\"pl-en\">EventStream</span>.withCallback[<span class=\"pl-en\">Int</span>]\ncallback(<span class=\"pl-c1\">1</span>) <span class=\"pl-c\"><span class=\"pl-c\">//</span> nothing happens because stream has no observers</span>\nstream.foreach(println)\ncallback(<span class=\"pl-c1\">2</span>) <span class=\"pl-c\"><span class=\"pl-c\">//</span> `2` will be printed  </span></pre></div>\n<p dir=\"auto\"><code>EventStream.withJsCallback[A]</code> works similarly except it returns a js.Function for easier integration with Javascript libraries.</p>\n<p dir=\"auto\"><code>EventStream.withUnitCallback</code> works similarly except it provides a callback that accepts no arguments, and a stream that emits <code>Unit</code>.</p>\n<p dir=\"auto\"><code>EventStream.withObserver[A]</code> works similarly but creates an observer, which among other conveniences passes the errors that it receives into the stream.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">EventBus</h4><a id=\"user-content-eventbus\" class=\"anchor\" aria-label=\"Permalink: EventBus\" href=\"#eventbus\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><code>new EventBus[MyEvent]</code> is a more powerful way to create a stream on which you can manually trigger events. The resulting EventBus exposes two properties:</p>\n<p dir=\"auto\"><strong><code>events</code></strong> is the stream of events emitted by the EventBus.</p>\n<p dir=\"auto\"><strong><code>writer</code></strong> is a WriteBus object that lets you trigger EventBus events in a few ways.</p>\n<p dir=\"auto\">WriteBus extends Observer, so you can call <code>onNext(newEventValue)</code> on it, or pass it as an observer to another stream's <code>addObserver</code> method. This will cause the event bus to emit <code>newEventValue</code> in a new transaction.</p>\n<p dir=\"auto\">Or you can just call <code>eventBus.emit(newEvent)</code> for the same effect.</p>\n<p dir=\"auto\">What sets EventBus apart from e.g. <code>EventStream.withObserver</code> is that you can also call <code>eventBus.addSource(otherStream)(owner)</code>, and the event bus will re-emit every event emitted by that stream. This is somewhat similar to adding <code>writer</code> as an observer to <code>otherStream</code>, except this will not cause <code>otherStream</code> to be started unless/until the EventBus's own stream is started (see <a href=\"#laziness\">Laziness</a>).</p>\n<p dir=\"auto\">You've probably noticed that <code>addSource</code> takes <code>owner</code> as an implicit param – this is for memory management purposes. You would typically pass a WriteBus to a child component if you want the child to send any events to the parent. Thus, we want <code>addSource</code> to be automatically undone when said child is discarded (see <a href=\"#ownership\">Ownership</a>), even if <code>writer.stream</code> is still being observed.</p>\n<p dir=\"auto\">An EventBus can have multiple sources simultaneously. In that case it will emit events from all of those sources in the order in which they come in. <strong>EventBus always emits every event in a new <a href=\"#transactions\">Transaction</a>.</strong> Note that EventBus lets you create loops of Observables. It is up to you to make sure that a propagation of an event through such loops eventually terminates (via a proper <code>.filter(passes)</code> gate for example, or the implicit <code>==</code> equality filter in Signal).</p>\n<p dir=\"auto\">You can manually remove a previously added source stream by calling <code>kill()</code> on the Subscription object returned by the addSource call.</p>\n<p dir=\"auto\">EventBus is particularly useful to get a single stream of events from a dynamic list of child components. You basically pass down the <code>writer</code> to every child component, and inside the child component you can add a source stream to it, or add the <code>writer</code> as an observer to some stream. Then when any given child component is discarded (i.e. its owner kills its subscriptions), its connection to the event bus will also be severed.</p>\n<p dir=\"auto\">Typically you don't pass EventBus itself down to child components as it provides both read and write access. Instead, you pass down either the writer or the event stream, depending on what is needed. This separation of concerns is the reason why EventBus doesn't just extend WriteBus and EventStream, by the way.</p>\n<p dir=\"auto\">WriteBus comes with a few ways to create new writers. Consider this:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val eventBus = new EventBus[Foo]\nval barWriter: WriteBus[Bar] = eventBus.writer\n  .filterWriter(isGoodFoo)\n  .contramapWriter(barToFoo)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">eventBus</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-en\">EventBus</span>[<span class=\"pl-en\">Foo</span>]\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">barWriter</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">WriteBus</span>[<span class=\"pl-en\">Bar</span>] <span class=\"pl-k\">=</span> eventBus.writer\n  .filterWriter(isGoodFoo)\n  .contramapWriter(barToFoo)</pre></div>\n<p dir=\"auto\">Now you can send <code>Bar</code> events to <code>barWriter</code>, and they will appear in <code>eventBus</code> processed with <code>barToFoo</code> then and filtered by <code>isGoodFoo</code>. This is useful when you want to get events from a child component, but the child component does not or should not know what <code>Foo</code> is. Generally if you don't need such separation of concerns, you can just <code>map</code>/<code>filter</code> the stream that's feeding the EventBus instead.</p>\n<p dir=\"auto\">WriteBus also offers a powerful <code>contracomposeWriter</code> method, which is like <code>contramapWriter</code> but with <code>compose</code> rather than <code>map</code> as the underlying transformation.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Batch EventBus Updates</h5><a id=\"user-content-batch-eventbus-updates\" class=\"anchor\" aria-label=\"Permalink: Batch EventBus Updates\" href=\"#batch-eventbus-updates\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">EventBus emits every event in a new transaction. However, similar to Var <a href=\"#batch-updates\">batch updates</a> you can call <code>EventBus.emit</code> or <code>EventBus.emitTry</code> to send values into several EventBus-es simultaneously, within the same transaction, to avoid <a href=\"#frp-glitches\">glitches</a> downstream.</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val valuesEventBus = new EventBus[Int]\nval labelsEventBus = new EventBus[String]\n \nEventBus.emit(\n  valuesEventBus -&gt; 100,\n  labelsEventBus -&gt; &quot;users&quot;\n)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">valuesEventBus</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-en\">EventBus</span>[<span class=\"pl-en\">Int</span>]\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">labelsEventBus</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-en\">EventBus</span>[<span class=\"pl-en\">String</span>]\n \n<span class=\"pl-en\">EventBus</span>.emit(\n  valuesEventBus <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">100</span>,\n  labelsEventBus <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>users<span class=\"pl-pds\">\"</span></span>\n)</pre></div>\n<p dir=\"auto\">Similar to Vars, you can't emit more than one event into the same EventBus in the same transaction. Airstream will throw if you attempt to do this, so you can't have duplicate inputs like <code>EventBus.emit(bus1 -&gt; ev1, bus1 -&gt; ev2, bus2 -&gt; ev3)</code>. If you need to emit more than one event into the same EventBus, just call the method twice, and they will be sent in separate transactions.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Var</h4><a id=\"user-content-var\" class=\"anchor\" aria-label=\"Permalink: Var\" href=\"#var\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Var is a reactive variable that you can update manually, and that exposes its current value at all times, as well as a <code>.signal</code> of its current value.</p>\n<p dir=\"auto\">Creating a Var is straightforward: <code>Var(initialValue)</code>, <code>Var.fromTry(tryValue)</code>.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Simple Updates</h5><a id=\"user-content-simple-updates\" class=\"anchor\" aria-label=\"Permalink: Simple Updates\" href=\"#simple-updates\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">You can update a Var using one of its methods: <code>set(value)</code>, <code>setTry(Try(value))</code>, <code>update(currentValue =&gt; nextValue)</code>, <code>tryUpdate(currentValueTry =&gt; Try(nextValue))</code>. Note that <code>update</code> will send a VarError into <a href=\"#unhandled-errors-do-not-terminate-the-program\">unhandled errors</a> if the Var's current value is an error. Use <code>set*</code> or <code>tryUpdate</code> methods to update failed Vars.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Observers Feeding into Var</h5><a id=\"user-content-observers-feeding-into-var\" class=\"anchor\" aria-label=\"Permalink: Observers Feeding into Var\" href=\"#observers-feeding-into-var\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Every Var provides a <code>writer</code> which is an Observer that writes the values it receives into the Var.</p>\n<p dir=\"auto\">In addition to <code>writer</code>, Var also offers <code>updater</code>s, making it easy to create an Observer that updates the Var based on both the Observer's input value and the Var's current value:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val v = Var(List(1, 2, 3))\nval adder = v.updater[Int]((currValue, nextInput) =&gt; currValue :+ nextInput)\n\nadder.onNext(4)\nv.now() // List(1, 2, 3, 4)\n\nval inputStream: EventStream[Int] = ???\n\ninputStream.foreach(adder)\ndiv(inputStream --&gt; adder) // Laminar syntax\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">v</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">Var</span>(<span class=\"pl-en\">List</span>(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">3</span>))\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">adder</span> <span class=\"pl-k\">=</span> v.updater[<span class=\"pl-en\">Int</span>]((currValue, nextInput) <span class=\"pl-k\">=&gt;</span> currValue <span class=\"pl-k\">:</span><span class=\"pl-k\">+</span> nextInput)\n\nadder.onNext(<span class=\"pl-c1\">4</span>)\nv.now() <span class=\"pl-c\"><span class=\"pl-c\">//</span> List(1, 2, 3, 4)</span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">inputStream</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n\ninputStream.foreach(adder)\ndiv(inputStream <span class=\"pl-k\">--</span><span class=\"pl-k\">&gt;</span> adder) <span class=\"pl-c\"><span class=\"pl-c\">//</span> Laminar syntax</span></pre></div>\n<p dir=\"auto\"><code>updater</code> will send a VarError into unhandled errors if you ask it to update a Var that is in a failed state. In such cases, use <code>writer</code> or <code>tryUpdater</code> instead.</p>\n<p dir=\"auto\">Vars of Options, i.e. <code>Var[Option[A]]</code>, also offer <code>someWriter: Observer[A]</code> for convenience.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Reading Values from a Var</h5><a id=\"user-content-reading-values-from-a-var\" class=\"anchor\" aria-label=\"Permalink: Reading Values from a Var\" href=\"#reading-values-from-a-var\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">You can get the Var's current value using <code>now()</code> and <code>tryNow()</code>. <code>now</code> throws if the current value is an error. Var also exposes a <code>signal</code> of its values.</p>\n<p dir=\"auto\">SourceVar, i.e. any Var that you create with <code>Var(...)</code>, follows <strong>strict</strong> (not lazy) execution – it will update its current value as instructed even if its signal has no observers. Unlike most other signals, the Var's signal is also strict – its current value matches the Var's current value at all times regardless of whether it has observers. Of course, any downstream observables that depend on the Var's signal are still lazy as usual.</p>\n<p dir=\"auto\">Being a <code>StrictSignal</code>, the Var's signal also exposes <code>now</code> and <code>tryNow</code> methods, so if you need to provide your code with read-only access to a Var, sharing only its signal is the way to go.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Var Transaction Delay</h5><a id=\"user-content-var-transaction-delay\" class=\"anchor\" aria-label=\"Permalink: Var Transaction Delay\" href=\"#var-transaction-delay\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Var emits every event in a new <a href=\"#transactions\">transaction</a>. This has important ramifications when writing to and reading from a Var. Consider the following code:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val myVar = Var(0)\n\nprintln(&quot;Start&quot;)\n\nmyVar.set(1)\nprintln(s&quot;After set: ${myVar.now()}&quot;)\n\nmyVar.update(_ + 1)\nprintln(s&quot;After update: ${myVar.now()}&quot;)\n\nTransaction { _ =&gt;\n  println(s&quot;After trx: ${myVar.now()}&quot;)\n}\n\nprintln(&quot;Done&quot;)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">myVar</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">Var</span>(<span class=\"pl-c1\">0</span>)\n\nprintln(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Start<span class=\"pl-pds\">\"</span></span>)\n\nmyVar.set(<span class=\"pl-c1\">1</span>)\nprintln(<span class=\"pl-k\">s</span><span class=\"pl-s\">\"</span><span class=\"pl-s\">After set: </span>${myVar.now()}<span class=\"pl-s\">\"</span>)\n\nmyVar.update(_ <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>)\nprintln(<span class=\"pl-k\">s</span><span class=\"pl-s\">\"</span><span class=\"pl-s\">After update: </span>${myVar.now()}<span class=\"pl-s\">\"</span>)\n\n<span class=\"pl-en\">Transaction</span> { _ <span class=\"pl-k\">=&gt;</span>\n  println(<span class=\"pl-k\">s</span><span class=\"pl-s\">\"</span><span class=\"pl-s\">After trx: </span>${myVar.now()}<span class=\"pl-s\">\"</span>)\n}\n\nprintln(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Done<span class=\"pl-pds\">\"</span></span>)</pre></div>\n<p dir=\"auto\">If you put this code in your app's <code>main</code> method or inside a <code>setTimeout</code> callback, it will print:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Start\nAfter set: 1\nAfter update: 2\nAfter trx: 2\nDone\"><pre class=\"notranslate\"><code>Start\nAfter set: 1\nAfter update: 2\nAfter trx: 2\nDone\n</code></pre></div>\n<p dir=\"auto\">But if you try to run this same code <em>while another transaction is being executed</em>, for example inside one of your observers, in response to an incoming stream event, this is what will be printed:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Start\nDone\nAfter set: 0\nAfter update: 0\nAfter trx: 2\"><pre class=\"notranslate\"><code>Start\nDone\nAfter set: 0\nAfter update: 0\nAfter trx: 2\n</code></pre></div>\n<p dir=\"auto\">Why the difference? Var's current value exposed by <code>now()</code> only updates when the Var emits the updated value, and as we now know, this always happens in a new transaction. But we ran our code inside an observer, that is, while another transaction was running. And the new transaction will only run after the current transaction has finished propagating, so the Var' current value will not update until then.</p>\n<p dir=\"auto\">This is why reading <code>myVar.now()</code> after calling <code>myVar.set(1)</code> gives you a stale value in this case. Var tries very hard to do the right thing though. While you can't expect to see the new value in <code>now()</code>, the <code>update</code> method does provide the updated value, <code>1</code>, as the input to its callback. This is because the update callback is also scheduled for a new transaction, and so it is executed after the transaction in which the Var's value was set to <code>1</code> has finished propagating.</p>\n<p dir=\"auto\">Finally, in both cases the code prints \"After trx: 2\". This is because that println is only executed in a new transaction. Similar to the update callback, this only gets run when the previously scheduled transactions have finished propagating, so it will always see the final Var value.</p>\n<p dir=\"auto\">So there you have it, you have two ways to read the Var's <strong>new</strong> current value: either call <code>now()</code> inside a new transaction, or use <code>update</code>. And of course you can also listen to the Var's signal.</p>\n<p dir=\"auto\">Keep in mind that transaction scheduling is fully synchronous, we do not introduce an asynchronous delay anywhere, we merely order the execution chunks to make the maximum amount of sense possible. Read more about transaction scheduling in the <a href=\"#transactions\">Transactions</a> section.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Derived Vars</h5><a id=\"user-content-derived-vars\" class=\"anchor\" aria-label=\"Permalink: Derived Vars\" href=\"#derived-vars\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">If you have a <code>Var[A]</code>, you can get zoomed / derived <code>Var[B]</code> by providing a lens: <code>A =&gt; B</code> and <code>(A, B) =&gt; A</code>. The result is a <code>LazyDerivedVar</code>, essentially a combination of <code>var.signal.map</code> and <code>writer.contramap</code> packaged in a Var.</p>\n<p dir=\"auto\">The value of the derived var is linked two-way to its parent var. Updating one updates the other.</p>\n<p dir=\"auto\">Example:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"case class FormData(num: Int, str: String)\nval formDataVar = Var(FormData(0, &quot;a&quot;))\nval strVar = formDataVar.zoomLazy(_.str)((formData, newStr) =&gt; formData.copy(str = newStr))\n\n// strVar.now() == &quot;a&quot;\n\nformDataVar.update(_.copy(str = &quot;b&quot;))\n// formDataVar.now() == FormData(0, &quot;b&quot;)\n// strVar.now() == &quot;b&quot;\n\nstrVar.set(&quot;c&quot;)\n// formDataVar.now() == FormData(0, &quot;c&quot;)\n// strVar.now() == &quot;c&quot;\"><pre><span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">FormData</span>(<span class=\"pl-v\">num</span>: <span class=\"pl-en\">Int</span>, <span class=\"pl-v\">str</span>: <span class=\"pl-en\">String</span>)\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">formDataVar</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">Var</span>(<span class=\"pl-en\">FormData</span>(<span class=\"pl-c1\">0</span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>a<span class=\"pl-pds\">\"</span></span>))\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">strVar</span> <span class=\"pl-k\">=</span> formDataVar.zoomLazy(_.str)((formData, newStr) <span class=\"pl-k\">=&gt;</span> formData.copy(str <span class=\"pl-k\">=</span> newStr))\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> strVar.now() == \"a\"</span>\n\nformDataVar.update(_.copy(str <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>b<span class=\"pl-pds\">\"</span></span>))\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> formDataVar.now() == FormData(0, \"b\")</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> strVar.now() == \"b\"</span>\n\nstrVar.set(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>c<span class=\"pl-pds\">\"</span></span>)\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> formDataVar.now() == FormData(0, \"c\")</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> strVar.now() == \"c\"</span></pre></div>\n<p dir=\"auto\">As the name implies, <code>LazyDerivedVar</code> is evaluated lazily, unlike other Vars. That is, the <code>zoomIn</code> function you provide (<code>A =&gt; B</code>) will not be called until and unless you actually read the value from this Var (whether by calling <code>.now()</code> or subscribing to its signal). Generally it's not a problem as <code>zoomIn</code> is usually just a pure field selection function (e.g. it's just <code>_.str</code> in the example above).</p>\n<p dir=\"auto\">Before the introduction of <code>zoomLazy</code>, Airstream also offered a strict <code>zoom</code> method, which is now considered inferior, because it requires an <code>Owner</code>. Note that derived vars created with the old <code>zoom</code> method could only be updated if their owner remained active, or if they had any other subscribers. Otherwise, attempting to update the var would cause Airstream to emit an unhandled error. The old <code>zoom</code> method will be deprecated in 18.0.0.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Batch Updates</h5><a id=\"user-content-batch-updates\" class=\"anchor\" aria-label=\"Permalink: Batch Updates\" href=\"#batch-updates\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Similar to EventBus, Var emits each event in a new <a href=\"#transactions\">transaction</a>. And, similar to <code>EventBus.emit</code>, you can put values into multiple Vars \"at the same time\", in the same transaction, to avoid <a href=\"#frp-glitches\">glitches</a> downstream. To do that, use the <code>set</code> / <code>setTry</code> / <code>update</code> / <code>tryUpdate</code> methods on the Var <strong>companion object</strong>. For example:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val value = Var(1)\nval isEven = Var(false)\n\nval sumSignal = x.signal.combineWith(y.signal)\n\n// batch updates!\nVar.set(x -&gt; 2, y -&gt; true)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">value</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">Var</span>(<span class=\"pl-c1\">1</span>)\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">isEven</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">Var</span>(<span class=\"pl-c1\">false</span>)\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">sumSignal</span> <span class=\"pl-k\">=</span> x.signal.combineWith(y.signal)\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> batch updates!</span>\n<span class=\"pl-en\">Var</span>.set(x <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">2</span>, y <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">true</span>)</pre></div>\n<p dir=\"auto\">With such a batched update, <code>sumSignal</code> will only emit <code>(1, false)</code> and <code>(2, true)</code>. It will <strong>not</strong> emit an inconsistent value like <code>(1, true)</code> or <code>(2, false)</code>.</p>\n<p dir=\"auto\">Batch updates are also atomic in the following ways:</p>\n<ul dir=\"auto\">\n<li><code>update</code> and <code>tryUpdate</code> will only execute the provided mods when the transaction is actually executed, not immediately as it's scheduled. This ensures that the mods operate on the latest available Var state.</li>\n<li>Similar to <code>Var#update</code>, <code>Var.update</code> sends an error into unhandled if you try to apply <code>mod</code> to a failed Var. In the batch case <em>none</em> of the input Vars will be updated, although <em>some</em> of the mod functions will be executed. For this reason, mod functions should be pure of side effects. Use <code>tryUpdate</code> when you need more control over error handling.</li>\n<li>Similar to <code>Var#tryUpdate</code>, <code>Var.tryUpdate</code> sends an error into unhandled if any of the provided mods throw. None of the Vars will update in this case. You should return Failure() from your mod instead of throwing if this is not what you want.</li>\n</ul>\n<p dir=\"auto\">Also, since an Airstream observable can't emit more than once per transaction, the inputs to batch Var methods must have no duplicate vars. For example, you can't do this: <code>Var.set(var1 -&gt; 1, var1 -&gt; 2, var2 -&gt; 3)</code>. Airstream will detect that you're attempting to put two events into <code>var1</code> in the same transaction, and will send an error into unhandled. Use two separate calls if you want to send two updates into the same Var.</p>\n<p dir=\"auto\">Keep in mind that derived vars count as the underlying source vars for duplicate detection purposes, so you can't update vars <code>var1</code> and <code>var1.zoom(fa)(fb)</code> in the same transaction.</p>\n<p dir=\"auto\">Those are the only ways in which setting / updating a Var can trigger an error. If any of those happen when batch-updating Var values, Airstream will none of the involved Vars will fail to update, keeping their current value.</p>\n<p dir=\"auto\">Remember that this atomicity guarantee only applies to failures which would have caused an individual <code>update</code> / <code>tryUpdate</code> call to throw. For example, if the <code>mod</code> function provided to <code>update</code> throws, <code>update</code> will not throw, it will instead successfully set that Var <code>Failure(err)</code>.</p>\n<p dir=\"auto\">For extra clarity, note that \"sending error into unhandled\" simply <a href=\"#unhandled-errors-do-not-terminate-the-program\">reports the error</a> and cancels the update of the Var, it does not stop the execution of the program like a real <code>throw</code> could.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Val</h4><a id=\"user-content-val\" class=\"anchor\" aria-label=\"Permalink: Val\" href=\"#val\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><code>Val(value)</code> / <code>Val.fromTry(tryValue)</code> is a Signal \"constant\" – a Signal that never changes its value. Unlike other Signals, its value is evaluated immediately upon creation, and is exposed in public <code>now()</code> and <code>tryNow()</code> methods.</p>\n<p dir=\"auto\">Val is useful when a component wants to accept either a Signal or a constant value as input. You can just wrap your constant in a Val, and make the component accept a <code>Signal</code> (or a <code>StrictSignal</code>) instead.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">FetchStream</h4><a id=\"user-content-fetchstream\" class=\"anchor\" aria-label=\"Permalink: FetchStream\" href=\"#fetchstream\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Airstream has a convenient interface to make network requests using the modern <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\" rel=\"nofollow\">Fetch</a> browser API:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"FetchStream.get(\n  url,\n  _.redirect(_.follow),\n  _.referrerPolicy(_.`no-referrer`),\n  _.abortStream(...)\n) // EventStream[String] of response body\"><pre><span class=\"pl-en\">FetchStream</span>.get(\n  url,\n  _.redirect(_.follow),\n  _.referrerPolicy(_.`no-referrer`),\n  _.abortStream(...)\n) <span class=\"pl-c\"><span class=\"pl-c\">//</span> EventStream[String] of response body</span></pre></div>\n<p dir=\"auto\">You can also get a stream of raw <code>dom.Response</code>-s, or use a custom codec for requests and responses, all with the same API:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"FetchStream.raw.get(url) // EventStream[dom.Response]\"><pre><span class=\"pl-en\">FetchStream</span>.raw.get(url) <span class=\"pl-c\"><span class=\"pl-c\">//</span> EventStream[dom.Response]</span></pre></div>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val Fetch = FetchStream.withCodec(encodeRequest, decodeResponse)\n\nFetch.post(url, _.body(myRequest)) // EventStream[MyResponse]\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">Fetch</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">FetchStream</span>.withCodec(encodeRequest, decodeResponse)\n\n<span class=\"pl-en\">Fetch</span>.post(url, _.body(myRequest)) <span class=\"pl-c\"><span class=\"pl-c\">//</span> EventStream[MyResponse]</span></pre></div>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Ajax</h4><a id=\"user-content-ajax\" class=\"anchor\" aria-label=\"Permalink: Ajax\" href=\"#ajax\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Ajax (<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\" rel=\"nofollow\">XMLHttpRequest</a>) is a legacy web technology that was largely replaced by the Fetch API (see above). Nevertheless, Airstream has a built-in way to perform Ajax requests:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"AjaxStream\n  .get(&quot;/api/kittens&quot;) // EventStream[dom.XMLHttpRequest]\n  .map(req =&gt; req.responseText) // EventStream[String]\"><pre><span class=\"pl-en\">AjaxStream</span>\n  .get(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>/api/kittens<span class=\"pl-pds\">\"</span></span>) <span class=\"pl-c\"><span class=\"pl-c\">//</span> EventStream[dom.XMLHttpRequest]</span>\n  .map(req <span class=\"pl-k\">=&gt;</span> req.responseText) <span class=\"pl-c\"><span class=\"pl-c\">//</span> EventStream[String]</span></pre></div>\n<p dir=\"auto\">Methods for POST, PUT, PATCH, and DELETE are also available.</p>\n<p dir=\"auto\">The request is made every time the stream is started. If the stream is stopped while the request is pending, the old request will not be cancelled, but its result will be discarded.</p>\n<p dir=\"auto\">If the request times out, is aborted, returns an HTTP status code that isn't 2xx or 304, or fails in any other way, the stream will emit an <code>AjaxStreamError</code>.</p>\n<p dir=\"auto\">If you want a stream that never fails, a stream that emits an event regardless of all those errors, call <code>.completeEvents</code> on your ajax stream.</p>\n<p dir=\"auto\">You can listen for <code>progress</code> or <code>readyStateChange</code> events by passing in the corresponding observers to <code>AjaxEventStream.get</code> et al, for example:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val (progressObserver, progressS) = EventStream.withObserver[(dom.XMLHttpRequest, dom.ProgressEvent)]\n\nval requestS = AjaxEventStream.get(\n  url = &quot;/api/kittens&quot;,\n  progressObserver = progressObserver\n)\n\nval bytesLoadedS = progressS.mapN((xhr, ev) =&gt; ev.loaded)\"><pre><span class=\"pl-k\">val</span> (progressObserver, progressS) <span class=\"pl-k\">=</span> <span class=\"pl-en\">EventStream</span>.withObserver[(dom.<span class=\"pl-en\">XMLHttpRequest</span>, dom.<span class=\"pl-en\">ProgressEvent</span>)]\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">requestS</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">AjaxEventStream</span>.get(\n  url <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>/api/kittens<span class=\"pl-pds\">\"</span></span>,\n  progressObserver <span class=\"pl-k\">=</span> progressObserver\n)\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">bytesLoadedS</span> <span class=\"pl-k\">=</span> progressS.mapN((xhr, ev) <span class=\"pl-k\">=&gt;</span> ev.loaded)</pre></div>\n<p dir=\"auto\">In a similar manner, you can pass a <code>requestObserver</code> that will be called with the newly created <code>dom.XMLHttpRequest</code> just before the request is sent. This way you can save the pending request into a Var and e.g. <code>abort()</code> it if needed.</p>\n<p dir=\"auto\">Warning: dom.XmlHttpRequest is an ugly, imperative JS construct. We set event callbacks for <code>onload</code>, <code>onerror</code>, <code>onabort</code>, <code>ontimeout</code>, and if requested, also for <code>onprogress</code> and <code>onreadystatechange</code>. Make sure you don't override Airstream's listeners in your own code, or this stream will not work properly.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Websockets</h4><a id=\"user-content-websockets\" class=\"anchor\" aria-label=\"Permalink: Websockets\" href=\"#websockets\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Airstream has no official websockets integration yet.</p>\n<p dir=\"auto\">For several users' implementations, search the old <a href=\"https://gitter.im/Laminar_/Lobby\" rel=\"nofollow\">Laminar gitter room</a>, and the issues in this repo.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">DOM Events</h4><a id=\"user-content-dom-events\" class=\"anchor\" aria-label=\"Permalink: DOM Events\" href=\"#dom-events\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val element: dom.Element = ???\nDomEventStream[dom.MouseEvent](element, &quot;click&quot;) // EventStream[dom.MouseEvent]\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">element</span><span class=\"pl-k\">:</span> dom.<span class=\"pl-en\">Element</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-en\">DomEventStream</span>[dom.<span class=\"pl-en\">MouseEvent</span>](element, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>click<span class=\"pl-pds\">\"</span></span>) <span class=\"pl-c\"><span class=\"pl-c\">//</span> EventStream[dom.MouseEvent]</span></pre></div>\n<p dir=\"auto\">This stream, when started, registers a <code>click</code> event listener on <code>element</code>, and emits all events the listener receives until the stream is stopped, at which point the listener is removed.</p>\n<p dir=\"auto\">Airstream does not know the names &amp; types of DOM events, so you need to manually specify both. You can get those manually from MDN or programmatically from event props such as <code>onClick</code> available in Laminar.</p>\n<p dir=\"auto\"><code>DomEventStream</code> works not just on elements but on any <code>dom.EventTarget</code>. However, make sure to check browser compatibility for weird EventTarget-s such as XMLHttpRequest.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">Custom Event Sources</h3><a id=\"user-content-custom-event-sources\" class=\"anchor\" aria-label=\"Permalink: Custom Event Sources\" href=\"#custom-event-sources\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">If simpler event sources (see above) do not suit your needs, consider using <code>CustomSource</code>. This mechanism lets you create a custom stream or signal as long as it does not depend on other Airstream observables. So, it's good for bringing third party sources of events into Airstream.</p>\n<p dir=\"auto\">You can create custom event sources using <code>EventStream.fromCustomSource</code> and <code>Signal.fromCustomSource</code>, which are convenience wrappers over the underlying  <code>CustomEventSource</code> and <code>CustomSignalSource</code> classes. This section will explain how to use those underlying classes, and after that the understanding of <code>fromCustomSource</code> methods should come naturally.</p>\n<p dir=\"auto\">Airstream's <code>DomEventStream.apply</code> creates a stream of events by wrapping the DOM API into <code>CustomStreamSource</code>. Let's see how it works:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"def apply[Ev &lt;: dom.Event](\n  eventTarget: dom.EventTarget,\n  eventKey: String,\n  useCapture: Boolean = false\n): EventStream[Ev] = {\n\n  CustomStreamSource[Ev]( (fireValue, fireError, getStartIndex, getIsStarted) =&gt; {\n\n    val eventHandler: js.Function1[Ev, Unit] = fireValue\n\n    CustomSource.Config(\n      onStart = () =&gt; {\n        eventTarget.addEventListener(eventKey, eventHandler, useCapture)\n      },\n      onStop = () =&gt; {\n        eventTarget.removeEventListener(eventKey, eventHandler, useCapture)\n      }\n    )\n  })\n}\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">apply</span>[<span class=\"pl-en\">Ev</span> <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">:</span> dom.<span class=\"pl-en\">Event</span>](\n  <span class=\"pl-v\">eventTarget</span>: dom.<span class=\"pl-en\">EventTarget</span>,\n  <span class=\"pl-v\">eventKey</span>: <span class=\"pl-en\">String</span>,\n  <span class=\"pl-v\">useCapture</span>: <span class=\"pl-en\">Boolean</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">false</span>\n)<span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Ev</span>] <span class=\"pl-k\">=</span> {\n\n  <span class=\"pl-en\">CustomStreamSource</span>[<span class=\"pl-en\">Ev</span>]( (fireValue, fireError, getStartIndex, getIsStarted) <span class=\"pl-k\">=&gt;</span> {\n\n    <span class=\"pl-k\">val</span> <span class=\"pl-v\">eventHandler</span><span class=\"pl-k\">:</span> js.<span class=\"pl-en\">Function1</span>[<span class=\"pl-en\">Ev</span>, <span class=\"pl-en\">Unit</span>] <span class=\"pl-k\">=</span> fireValue\n\n    <span class=\"pl-en\">CustomSource</span>.<span class=\"pl-en\">Config</span>(\n      onStart <span class=\"pl-k\">=</span> () <span class=\"pl-k\">=&gt;</span> {\n        eventTarget.addEventListener(eventKey, eventHandler, useCapture)\n      },\n      onStop <span class=\"pl-k\">=</span> () <span class=\"pl-k\">=&gt;</span> {\n        eventTarget.removeEventListener(eventKey, eventHandler, useCapture)\n      }\n    )\n  })\n}</pre></div>\n<p dir=\"auto\">When we create a <code>CustomStreamSource</code>, we need to provide a callback that accepts some useful arguments and returns an instance of <code>CustomSource.Config</code>, which is essentially a bundle of two callbacks: <code>onStart</code> which fires when your stream is started, and <code>onStop</code> which fires when your stream is stopped (see <a href=\"#laziness\">Laziness</a>).</p>\n<p dir=\"auto\">Here we see that DomEventStream registers <code>fireValue</code> as an event listener on the DOM element when the stream starts, and unregisters that listener when the stream stops. This way the resulting stream will properly clean up its resources.</p>\n<p dir=\"auto\">Side note: <code>val eventHandler</code> is cached to avoid implicitly creating a new instance of <code>js.Function1</code>. We need to keep this exact reference to be able to unregister the listener. Just a bit of Scala-vs-js friction here.</p>\n<p dir=\"auto\">Let's look at the methods that <code>CustomStreamSource</code> makes available to us:</p>\n<ul dir=\"auto\">\n<li><strong>fireValue</strong> - call this with a value to make the custom stream emit that value in a new transaction</li>\n<li><strong>fireError</strong> - call this with a Throwable to make the custom stream emit an error (see <a href=\"#error-handling\">Error Handling</a>)</li>\n<li><strong>getStartIndex</strong> – call this to check how many times the custom stream has been started. Airstream uses this for the <code>emitOnce</code> param in streams like <code>EventStream.fromSeq</code>.</li>\n<li><strong>getIsStarted</strong> – call this to check if the custom stream is currently started</li>\n</ul>\n<p dir=\"auto\"><code>CustomSource.Config</code> instances have a <code>when(passes: () =&gt; Boolean)</code> method that returns a config that, when the predicate does not pass, will <strong>not</strong> call your <code>onStart</code> callback when the stream starts, and will not call your <code>onStop</code> callback when the stream is subsequently stopped (we assume that your <code>onStop</code> code cleans up after your <code>onStart</code> code). To clarify, the predicate is evaluated when the custom stream is about to start. And the stream *<em>will</em> actually start – you can't break this part of Airstream contract – the predicate only controls whether your callbacks defined in the config will be run. You can see this predicate being useful to implement the <code>emitOnce</code> param in streams like <code>EventStream.fromSeq</code>.</p>\n<p dir=\"auto\"><strong>CustomSignalSource</strong> is the Signal version of CustomStreamSource, and works similarly, just with a slightly different set of params:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"class CustomSignalSource[A] (\n  getInitialValue: =&gt; Try[A],\n  makeConfig: (SetCurrentValue[A], GetCurrentValue[A], GetStartIndex, GetIsStarted) =&gt; CustomSource.Config\n)\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">CustomSignalSource</span>[<span class=\"pl-en\">A</span>] (\n  <span class=\"pl-v\">getInitialValue</span>: <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">Try</span>[<span class=\"pl-en\">A</span>],\n  <span class=\"pl-v\">makeConfig</span>: (<span class=\"pl-en\">SetCurrentValue</span>[<span class=\"pl-en\">A</span>], <span class=\"pl-en\">GetCurrentValue</span>[<span class=\"pl-en\">A</span>], <span class=\"pl-en\">GetStartIndex</span>, <span class=\"pl-en\">GetIsStarted</span>) <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">CustomSource</span>.<span class=\"pl-en\">Config</span>\n)</pre></div>\n<p dir=\"auto\"><code>fireValue</code> and <code>fireError</code> are merged into one <code>setCurrentValue</code> callback that expects a <code>Try[A]</code>, and this being a Signal, we also provide a <code>getCurrentValue</code> param to check the custom signal's current value.</p>\n<p dir=\"auto\">Generally signals need to be started in order for their current value to update. Stopped signals generally don't update without listeners, unless they are a <code>StrictSignal</code> like <code>Var#signal</code>. <code>CustomSignalSource</code> is not a <code>StrictSignal</code> so there is no expectation for it to keep updating its value when it's stopped. Users should keep listening to signals that they care about.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Extending Observables</h4><a id=\"user-content-extending-observables\" class=\"anchor\" aria-label=\"Permalink: Extending Observables\" href=\"#extending-observables\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">If you need a custom observable that depends on another Airstream observable, you can subclass <code>WritableEventStream</code> or <code>WritableSignal</code>. See existing classes for inspiration, such as <code>MapSignal</code> and <code>MapEventStream</code>.</p>\n<p dir=\"auto\">You will likely want to mix in either <code>SingleParentSignal with InternalTryObserver</code> or <code>SingleParentStream with InternalNextErrorObserver</code>. Then you will just need to implement <code>onTry</code> (for signals) or <code>onNext</code> / <code>onError</code> (for streams) methods, which will be triggered when the parent observable emits. In turn, those methods should call <code>fireValue</code>, <code>fireError</code> or <code>fireTry</code> to make your custom observable emit its own value. Also, for signals you will need to implement <code>initialValue</code> which you should derive from the parent observable's <strong>current</strong> value (NOT from the parent observable's <code>initialValue</code>).</p>\n<p dir=\"auto\">If you want to put asynchronous logic in your observable, make sure to have a good understanding of Airstream transactions and topoRank, and consult with other asynchronous observables implementations such as <code>DelayEventStream</code>.</p>\n<p dir=\"auto\">If your custom observable does not depend on any Airstream observables, e.g. if you're writing a compatibility layer for a third party library, you generally should be able to use the simpler <a href=\"#custom-event-sources\">Custom Sources</a> API.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Accessing Protected Members</h5><a id=\"user-content-accessing-protected-members\" class=\"anchor\" aria-label=\"Permalink: Accessing Protected Members\" href=\"#accessing-protected-members\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Some values and methods that you might want to access on observables are <code>protected</code>. That means that the compiler will only let you access those values and methods on the same instance. So, you can read <code>this.topoRank</code>, but you can't read <code>parentObservable.topoRank</code>. To get around this, use the <code>Protected</code> object: <code>Protected.topoRank(parentObservable)</code>.</p>\n<p dir=\"auto\">Aside from <code>topoRank</code>, you will need to access <code>tryNow()</code> and <code>now()</code> this way, e.g. when implementing a custom signal's <code>initialValue</code>. These methods require an implicit evidence of type <code>Protected</code>, which is automatically in scope if you're calling these methods from inside your custom observable. You're not supposed to access a signal's current value from the outside, without proving that the signal is running (e.g. by subscribing to it), otherwise you might get a stale value.</p>\n<p dir=\"auto\">Honestly all this \"protected\" business smells funny to me, but I couldn't figure out a better way to allow third party extensions without making these protected members public.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">Sources &amp; Sinks</h3><a id=\"user-content-sources--sinks\" class=\"anchor\" aria-label=\"Permalink: Sources &amp; Sinks\" href=\"#sources--sinks\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">A <code>Source[A]</code> in Airstream is something that exposes a <code>toObservable</code> method, something that can be (explicitly, not implicitly) converted into an <code>Observable[A]</code>. For example, the observables themselves are Sources, but so are EventBus-es (<code>def toObservable = this.events</code>) and Var-s (<code>def toObservable = this.signal</code>).</p>\n<p dir=\"auto\">Source is further subtyped into – <code>EventSource</code> (EventStream, EventBus) and <code>SignalSource</code> (Signal, Var). Predictably, <code>eventSource.toObservable</code> returns an EventStream, whereas <code>signalSource.toObservable</code> returns a Signal.</p>\n<p dir=\"auto\">These types are useful when you want to create a method that can accept \"anything that you can get a stream from\". For example, it's used in Laminar:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val textBus = new EventBus[String]\ndiv(value &lt;-- textBus.events)\ndiv(value &lt;-- textBus) // Also works because this &lt;-- accepts Source[String]\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">textBus</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-en\">EventBus</span>[<span class=\"pl-en\">String</span>]\ndiv(value <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> textBus.events)\ndiv(value <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> textBus) <span class=\"pl-c\"><span class=\"pl-c\">//</span> Also works because this &lt;-- accepts Source[String]</span></pre></div>\n<p dir=\"auto\">The counterparty to <code>Source</code> in Airstream is <code>Sink</code>. <code>Sink[A]</code> is something that exposes a <code>toObserver</code> method that can be explicitly (not implicitly) convert a Sink to an Observer. So Observers are sinks, as are EventBus-es and Var-s, and even <code>js.Function1[A, Unit]</code> has an implicit conversion to <code>Sink[A]</code>.</p>\n<p dir=\"auto\">However, there is no implicit conversion from <code>A =&gt; Unit</code> to <code>Sink</code> because unfortunately Scala requires a lambda's type param to have a type ascription to implicitly convert it into a Sink[A], so syntax like <code>div(value &lt;-- (_ =&gt; println(\"x\"))</code> would not be possible with such an implicit defined. In Laminar we get around this by overloading the <code>&lt;--</code> method to accept either a <code>Sink[A]</code> or <code>A =&gt; Unit</code>. If you need this conversion, just wrap your function in <code>Observer()</code>. You'll still need to ascribe the types though.</p>\n<p dir=\"auto\">Speaking of implicits, why don't we have EventBus extend both <code>EventStream[A]</code> and <code>Observer[A]</code> instead of having separate Source and Sink types? On a technical level simply because Observable and Observer have overlapping methods defined, such as <code>filter</code> and <code>delay</code>, but more importantly, it would just be confusing. The whole point of Source and Sink is to not expose any methods other than toObservable, so that these types are only used as input types to methods that the developer wants to be flexible.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">FRP Glitches</h3><a id=\"user-content-frp-glitches\" class=\"anchor\" aria-label=\"Permalink: FRP Glitches\" href=\"#frp-glitches\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Other Libraries</h4><a id=\"user-content-other-libraries\" class=\"anchor\" aria-label=\"Permalink: Other Libraries\" href=\"#other-libraries\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">A glitch in Functional Reactive Programming is a situation where inconsistent state is allowed to exist and exposed to either an observable or an observer. For example, consider the typical diamond case:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val numbers: EventStream[Int] = ???\nval isPositive: EventStream[Boolean] = numbers.map(_ &gt; 0)\nval doubledNumbers: EventStream[Int] = numbers.map(_ * 2)\nval combinedStream: EventStream[(Int, Boolean)] = doubledNumbers.combineWith(isPositive)\ncombinedStream.addObserver(combinedStreamObserver)(owner)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">numbers</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">isPositive</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Boolean</span>] <span class=\"pl-k\">=</span> numbers.map(_ <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span>)\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">doubledNumbers</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> numbers.map(_ <span class=\"pl-k\">*</span> <span class=\"pl-c1\">2</span>)\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">combinedStream</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[(<span class=\"pl-en\">Int</span>, <span class=\"pl-en\">Boolean</span>)] <span class=\"pl-k\">=</span> doubledNumbers.combineWith(isPositive)\ncombinedStream.addObserver(combinedStreamObserver)(owner)</pre></div>\n<p dir=\"auto\">Now, without thinking too hard, what do you think <code>combinedStream</code> will emit when <code>numbers</code> emits <code>1</code>, assuming <code>-1</code> was previously emitted? You might expect that <code>isPositive</code> would emit <code>true</code>, <code>doubledNumbers</code> would emit <code>2</code>, and then combinedStream would emit a tuple <code>(2, true)</code>. That would make sense, and this is how Airstream works at no cost to you, and yet this is not how most streaming and state propagation libraries behave.</p>\n<p dir=\"auto\">Most streaming libraries will introduce a <strong>glitch</strong> in this scenario, as they are implemented with unconditional depth-first propagation. So in other libraries when the event from <code>numbers</code> (<code>1</code>) propagates, it goes to <code>isPositive</code> (<code>true</code>), then to <code>combinedStream</code> (<code>(-1, true)</code>). And that's a glitch. <code>(-1, true)</code> is not a valid state, as -1 is not a positive number. Immediately afterwards, <code>doubledNumbers</code> will emit <code>2</code>, and finally combinedStream would emit <code>(2, true)</code>, the correct event.</p>\n<p dir=\"auto\">Such behaviour is problematic in a few ways – first, you are now propagating two events on equal standing. Any observables (and in most other libraries, even observers!) downstream of <code>combinedStream</code> will see two events come in, the first one carrying invalid/incorrect state, and they will probably perform incorrect calculations or side effects because of that.</p>\n<p dir=\"auto\">In general, glitches happen when you have an observable that <em>synchronously depends</em> on multiple observables that <em>synchronously depend</em> on a common ancestor or one of themselves. I'm using the term <code>synchronously depends</code> to describe a situation where emitting an event to a parent observable might result in the child observable also emitting it – synchronously. So <code>map</code> and <code>filter</code> would fall into this category, but <code>delay</code> wouldn't.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Topological Rank</h4><a id=\"user-content-topological-rank\" class=\"anchor\" aria-label=\"Permalink: Topological Rank\" href=\"#topological-rank\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">In the diamond-combine case described above Airstream avoids a glitch because CombineObservable-s (those created using the <code>combineWith</code> method) do not propagate downstream immediately. Instead, they are put into a <code>pendingObservables</code> queue in the current Transaction (we'll get to those soon). When the rest of the propagation within a transaction finishes, the propagation of the first pending observable is resumed. When that is finished, we propagate the first remaining pending observable, and so on.</p>\n<p dir=\"auto\">So in our example, what happens in Airstream: after <code>isPositive</code> emits <code>true</code>, <code>combinedStream</code> is notified that one of its parents emitted a new event. Instead of emitting its own event, it adds itself to the list of pending observables. Then, as the <code>isPositive</code> branch finished propagating (for now), <code>doubledNumbers</code> emits <code>2</code>, and then again notifies <code>combinedStream</code> about this. <code>combinedStream</code> is already pending, so it just grabs and remembers the new value from this parent. At this point the propagation of <code>numbers</code> is complete (assuming no other branches exist), and Airstream checks <code>pendingObservables</code>on the current transaction. It finds only one – <code>combinedStream</code>, and re-starts the propagation from there. The only thing left to do in our example is to send the new event – <code>(2, true)</code> to <code>combinedStreamObserver</code>.</p>\n<p dir=\"auto\">Now, only this simple example could work with such logic. The important bit that makes this work for complex observable graphs is <a href=\"https://en.wikipedia.org/wiki/Topological_sorting\" rel=\"nofollow\">topological rank</a>. Topological rank in Airstream is defined as follows: if observable A <em>synchronously depends</em> (see definition above) on observable B, its topological rank will be greater than that of B. In practical terms, <code>doubledNumbers.topoRank = numbers.topoRank + 1</code> and <code>combinedStream.topoRank == max(isPositive.topoRank, doubledNumbers.topoRank) + 1</code>.</p>\n<p dir=\"auto\">In case of <code>combineWith</code>, Airstream uses topological rank for one thing – do determine which of the pending observables to resolve first. So when I said that Airstream continues the propagation of the \"first\" pending observable, I meant the one with the lowest <code>topoRank</code> among pending observables. This ensures that if you have more than one combined observable pending, that the one that doesn't depend on the other one will be propagated first.</p>\n<p dir=\"auto\">So this is how Airstream avoids the glitch in the diamond-combine case.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Transactions</h4><a id=\"user-content-transactions\" class=\"anchor\" aria-label=\"Permalink: Transactions\" href=\"#transactions\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Before we dive into other kinds of glitches (ha! you thought that was it!?), we need to know what a Transaction is.</p>\n<p dir=\"auto\">Philosophically, a Transaction in Airstream encapsulates a part of the propagation that 1) happens <strong>synchronously</strong>, and 2) contains <strong>no loops</strong> of observables. Within the confines of a single Transaction Airstream guarantees a) <strong>no glitches</strong>, and b) that no observable will emit more than once.</p>\n<p dir=\"auto\">Async streams such as <code>stream.delay(500)</code> emit their events in a new transaction because Airstream executes transactions sequentially – and there is no sense in keeping other transactions blocked until some Promise or Future decides to resolve itself.</p>\n<p dir=\"auto\">Events that come from outside of Airstream – see <a href=\"#sources-of-events\">Sources of Events</a> – each come in a new Transaction, and those source observables have a <code>topoRank</code> of 1. I guess it makes sense why <code>EventStream.periodic</code> would behave that way, but why wouldn't <code>EventBus</code> reuse the transaction of whatever event came in from one of its source streams?</p>\n<p dir=\"auto\">And the answer is the limitation of our topological ranking approach: it does not work for loops of observables. A topoRank is a property of an observable, not of the event coming in. And an observable's topoRank is static, determined at its creation. EventBus on its creation has no sources, and allows you to fire events into it manually, so its stream needs to emit all those events in a new Transaction because there is no way to guarantee correct topological ranking to avoid glitches.</p>\n<p dir=\"auto\">That said, in practice this is not a big deal because the events that an EventBus receives from different sources should be usually independent of each other because they are coming from different child components or from different browser events.</p>\n<p dir=\"auto\">Apart from EventBus there is another way to create a loop – the <code>eventStream.flatten</code> method. And that one too, produces an event stream that emits all events in a new transaction, for all the same reasons.</p>\n<p dir=\"auto\">Loops and potentially-loopy constructs necessarily require a new transaction as a tradeoff. Some other libraries do some kinds of dynamic topological sorting which is less predictable and whose performance worsens as your observables graph gets more complicated, but with Airstream there are no such costs. The only – and tiny – cost is when Airstream inserts a CombineObservable into the list of pending observables – that list is sorted by a static <code>topoRank</code> field, so it takes O(n) where n is the number of currently pending observables, which is usually zero or not much more than that.</p>\n<p dir=\"auto\">Lastly, keep in mind that emitting events inside Observer-s will necessarily happen in a new transaction as you will need to use EventBus / Var APIs that create new transactions. Observers are generally intended for side effects. Those effects might be emitting other events, but in that case we consider them independent events, not a continuation of the current transaction. Philosophically, Observers should not know what they're observing (and they can observe multiple things at a time).</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Avoiding Glitches When Merging</h4><a id=\"user-content-avoiding-glitches-when-merging\" class=\"anchor\" aria-label=\"Permalink: Avoiding Glitches When Merging\" href=\"#avoiding-glitches-when-merging\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Consider this:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val numbers: EventStream[Int] = ???\nval tens: EventStream[Int] = numbers.map(_ * 10)\nval hundreds: EventStream[Int] = tens.map(_ * 10)\nval multiples: EventStream[Int] = EventStream.merge(hundreds, tens)\nmultiples.addObserver(multiplesObserver)(owner)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">numbers</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">tens</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> numbers.map(_ <span class=\"pl-k\">*</span> <span class=\"pl-c1\">10</span>)\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">hundreds</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> tens.map(_ <span class=\"pl-k\">*</span> <span class=\"pl-c1\">10</span>)\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">multiples</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> <span class=\"pl-en\">EventStream</span>.merge(hundreds, tens)\nmultiples.addObserver(multiplesObserver)(owner)</pre></div>\n<p dir=\"auto\">What do you expect <code>multiples</code> to emit when <code>numbers</code> emits <code>1</code>? I expect it to emit <code>10</code>, and then <code>100</code>. Two important considerations here:</p>\n<ol dir=\"auto\">\n<li>\n<p dir=\"auto\">On a high level, the order of output events is determined by the order of input events: <code>hundreds</code> emits <code>100</code> after <code>tens</code> emits <code>10</code>, so the merged stream does the same. On a technical level, the order of events emitted in the same transaction is determined by the parent observables' topological rank.</p>\n</li>\n<li>\n<p dir=\"auto\">The merged stream can, by design, emit multiple events per one origination event (the <code>1</code> event), as shown in our example above. This means that it can't always emit all of the events in the same incoming transaction, because any observable can only emit one event per transaction. At the same time, in cases when the merge stream depends only on mutually unrelated observables (that never emit in the same transaction), we don't want to force the merge stream to fire <strong>all</strong> of its events in a new transaction, as this could cause FRP glitches down the road. And so, the merge stream takes a compromise: in every transaction, it emits the first parent observable's event as-is, but if any other parent observable also emits in the same transaction (like <code>tens</code> and <code>hundreds</code> do in our example), the merge stream re-emits <em>that</em> event in a new transaction. So, in our example, it would emit <code>10</code> in the same transaction as the original event, and then emit <code>100</code> in a new transaction.</p>\n</li>\n</ol>\n<p dir=\"auto\">Such handling of transactions might seem arbitrary, but it actually matches the semantics of merge streams. As a result, such a mechanism produces desired behaviour. Even though we're emitting some events in new transactions, which would normally increase the chance of FRP glitches downstream, we only do it when it's necessary (when the merge stream emits more than one event per one originating event), and so in practice we don't see glitches. In fact, any other behaviour is guaranteed to cause glitches (unexpected behaviour). This might sound handwavy, but there's actually a lot of real life experience and unit tests behind that principle. See <a href=\"#operators-vs-transactions\">Operators vs Transactions</a> for more on that.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Scheduling of Transactions</h4><a id=\"user-content-scheduling-of-transactions\" class=\"anchor\" aria-label=\"Permalink: Scheduling of Transactions\" href=\"#scheduling-of-transactions\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">When you call methods like <code>Var#set</code>, <code>EventBus.emit</code>, etc. we create a new transaction. If another transaction is currently executing, which is often the case (e.g. if you're doing this inside a <code>stream.foreach</code> callback), this transaction will not be executed immediately, but will be scheduled to be executed later, because to avoid glitches, the current transaction needs to finish first before any other transaction can put more events onto the observable graph.</p>\n<p dir=\"auto\">So if you set a Var's value, you will not be able to read it in the same transaction, because this instruction will only be executed after the current transaction finishes:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val logVar: Var[List[Event]] = ???\nstream.foreach { ev =&gt;\n  logVar.set(logVar.now() :+ ev)\n  logVar.set(logVar.now() :+ ev)\n  println(logVar.now())\n  // NONE of the logVar.now() calls here will contain any `ev`\n  // because they are all executed before the .set transaction executes.\n  // Because of this, after all of the transactions are executed,\n  // logVar will only contain one instance of `ev`, not two.\n}\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">logVar</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Var</span>[<span class=\"pl-en\">List</span>[<span class=\"pl-en\">Event</span>]] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\nstream.foreach { ev <span class=\"pl-k\">=&gt;</span>\n  logVar.set(logVar.now() <span class=\"pl-k\">:</span><span class=\"pl-k\">+</span> ev)\n  logVar.set(logVar.now() <span class=\"pl-k\">:</span><span class=\"pl-k\">+</span> ev)\n  println(logVar.now())\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> NONE of the logVar.now() calls here will contain any `ev`</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> because they are all executed before the .set transaction executes.</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> Because of this, after all of the transactions are executed,</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> logVar will only contain one instance of `ev`, not two.</span>\n}</pre></div>\n<p dir=\"auto\">If you need to read of Var after writing to it, you can use <code>Var#update</code>, which will evaluate its mod only when its transaction runs, so it will always look at the freshest state of the Var:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val logVar = Var(List[Event]())\nstream.foreach { ev =&gt;\n  logVar.update(_ :+ ev)\n  logVar.update(_ :+ ev)\n  // After both transactions execute, logVar will have two `ev`-s in it\n}\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">logVar</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">Var</span>(<span class=\"pl-en\">List</span>[<span class=\"pl-en\">Event</span>]())\nstream.foreach { ev <span class=\"pl-k\">=&gt;</span>\n  logVar.update(_ <span class=\"pl-k\">:</span><span class=\"pl-k\">+</span> ev)\n  logVar.update(_ <span class=\"pl-k\">:</span><span class=\"pl-k\">+</span> ev)\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> After both transactions execute, logVar will have two `ev`-s in it</span>\n}</pre></div>\n<p dir=\"auto\">Let's expand our example above:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val bus = new EventBus[Event]\nval logVar = Var(List[Event]())\nval countVar = Var(0)\nbus.events.foreach { ev =&gt;\n  logVar.update(_ :+ ev)\n  logVar.update(_ :+ ev)\n  // After both transactions execute, logVar will have two `ev`-s in it\n}\nlogVar.signal.foreach { log =&gt;\n  sideEffect(log.size)\n  countVar.update(_ += 1)\n}\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">bus</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-en\">EventBus</span>[<span class=\"pl-en\">Event</span>]\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">logVar</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">Var</span>(<span class=\"pl-en\">List</span>[<span class=\"pl-en\">Event</span>]())\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">countVar</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">Var</span>(<span class=\"pl-c1\">0</span>)\nbus.events.foreach { ev <span class=\"pl-k\">=&gt;</span>\n  logVar.update(_ <span class=\"pl-k\">:</span><span class=\"pl-k\">+</span> ev)\n  logVar.update(_ <span class=\"pl-k\">:</span><span class=\"pl-k\">+</span> ev)\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> After both transactions execute, logVar will have two `ev`-s in it</span>\n}\nlogVar.signal.foreach { log <span class=\"pl-k\">=&gt;</span>\n  sideEffect(log.size)\n  countVar.update(_ <span class=\"pl-k\">+</span><span class=\"pl-k\">=</span> <span class=\"pl-c1\">1</span>)\n}</pre></div>\n<p dir=\"auto\">Let's say you fires an event into <code>bus</code>, and its transaction A started executing. The callback provided to <code>bus.events.foreach</code> will schedule two transactions to update <code>logVar</code>, B and C. After that, transaction A will finish as there are no other listeners.</p>\n<p dir=\"auto\">Transaction B will immediately start executing. <code>ev</code> will be appended to <code>logVar</code> state, then this new state will be propagated to <code>logVar.signal</code>. <code>sideEffect(1)</code> will be called, and another transaction D to update <code>countVar</code> will be scheduled. After that, transaction B will finish as there are no other listeners.</p>\n<p dir=\"auto\">Now, which transaction will execute next, C (the second update to <code>logVar</code>), or D (update to <code>countVar</code>)? Since Airstream v0.11.0, D will execute next, because its considered to be a child of the transaction B that just finished, <strong>because it was scheduled while transaction B was running</strong>. After a transaction finishes, Airstream first executes any pending transactions that were scheduled while it was running, in the order in which they were scheduled. This is recursive, so effectively we iterate over an hierarchy of transactions in a depth-first search.</p>\n<p dir=\"auto\">In practice, this makes sense: in the code, the first <code>logVar.update(_ :+ ev)</code> is seen before the second <code>logVar.update(_ :+ ev)</code>, so the first transaction will completely finish, including any descendant transactions it creates, before we hand over control to its sibling transaction.</p>\n<p dir=\"auto\">Remember that all of this happens synchronously. There can be no async boundaries within a transaction. Any event fires after an async delay is necessarily fired in a new transaction that is initialized / scheduled <strong>after</strong> the async delay, so it's not part of the pending transaction queue until the async delay resolves, and when it does, it's guaranteed that there are no pending transactions in the queue as Javascript is single-threaded.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">Operators</h3><a id=\"user-content-operators\" class=\"anchor\" aria-label=\"Permalink: Operators\" href=\"#operators\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Airstream offers standard observables operators like <code>map</code> / <code>filter</code> / <code>collect</code> / <code>compose</code> / <code>combineWith</code> etc. You will need to read the <a href=\"https://javadoc.io/doc/com.raquo/airstream_sjs1_3/latest/com/raquo/airstream/index.html\" rel=\"nofollow\">API doc</a> or the actual code or use IDE autocompletion to discover those that aren't documented here or in other section of the documentation. In the code, see <code>BaseObservable</code>, <code>Observable</code>, <code>EventStream</code>, and <code>Signal</code> traits and their companion objects.</p>\n<p dir=\"auto\">Some of the more interesting / non-standard operators are documented below:</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Distinction Operators</h4><a id=\"user-content-distinction-operators\" class=\"anchor\" aria-label=\"Permalink: Distinction Operators\" href=\"#distinction-operators\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Both streams and signals have various <code>distinct*</code> operators to filter updates using <code>==</code> or other comparisons. These can be used to make your signals behave like they did prior to v15.0.0 (see <a href=\"https://laminar.dev/blog/2023/03/22/laminar-v15.0.0#no-more-automatic--checks-in-signals\" rel=\"nofollow\">blog post</a>), or to achieve different, custom logic:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"signal.distinct // performs `==` checks, similar to pre-15.0.0 behaviour\nsignal.distinctBy(_.id) // performs `==` checks on a certain key\nsignal.distinctByRef // performs reference equality checks\nsignal.distinctByFn((prevValue, nextValue) =&gt; isSame) // custom checks\nsignal.distinctErrors((prevErr, nextErr) =&gt; isSame) // filter errors in the error channel\nsignal.distinctTry((prevTryValue, nextTryValue) =&gt; isSame) // one comparator for both event and error channels\"><pre>signal.distinct <span class=\"pl-c\"><span class=\"pl-c\">//</span> performs `==` checks, similar to pre-15.0.0 behaviour</span>\nsignal.distinctBy(_.id) <span class=\"pl-c\"><span class=\"pl-c\">//</span> performs `==` checks on a certain key</span>\nsignal.distinctByRef <span class=\"pl-c\"><span class=\"pl-c\">//</span> performs reference equality checks</span>\nsignal.distinctByFn((prevValue, nextValue) <span class=\"pl-k\">=&gt;</span> isSame) <span class=\"pl-c\"><span class=\"pl-c\">//</span> custom checks</span>\nsignal.distinctErrors((prevErr, nextErr) <span class=\"pl-k\">=&gt;</span> isSame) <span class=\"pl-c\"><span class=\"pl-c\">//</span> filter errors in the error channel</span>\nsignal.distinctTry((prevTryValue, nextTryValue) <span class=\"pl-k\">=&gt;</span> isSame) <span class=\"pl-c\"><span class=\"pl-c\">//</span> one comparator for both event and error channels</span></pre></div>\n<p dir=\"auto\">The same operators are available on streams too.</p>\n<p dir=\"auto\">Note that all <code>distinct</code> operators <strong>assume that the values you pass through them are not mutated</strong>. Internally, <code>distinct</code> compares every new value to the last received value, and it remembers the latter by reference, so if you're always emitting the same instance (e.g. of <code>js.Array</code>) that you're mutating upstream, the <code>distinct</code> operator will never be able to detect those mutations, so it will filter them aall out.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">N-arity Operators</h4><a id=\"user-content-n-arity-operators\" class=\"anchor\" aria-label=\"Permalink: N-arity Operators\" href=\"#n-arity-operators\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Airstream offers several methods and operators that work on up to 9 observables or tuples up to Tuple9:</p>\n<p dir=\"auto\"><strong>mapN((a, b, ...) =&gt; ???)</strong></p>\n<p dir=\"auto\">Available on observables of <code>(A, B, ...)</code> tuples</p>\n<p dir=\"auto\"><strong>filterN((a, b, ...) =&gt; ???)</strong></p>\n<p dir=\"auto\">Available on observables of <code>(A, B, ...)</code> tuples</p>\n<p dir=\"auto\"><strong>observableA.combineWith(observableB, observableC, ...)</strong></p>\n<p dir=\"auto\">There is a bit of magic to this method for convenience. <code>streamOfA.combineWith(streamOfB)</code> returns a stream of <code>(A, B)</code> tuples only if neither A nor B are tuple types. Otherwise, <code>combineWith</code> flattens the tuple types, so for example both <code>streamOfA.combineWith(streamOfB).combineWith(streamOfC)</code> and <code>streamOfA.combineWith(streamOfB, streamOfC)</code> return a stream of <code>(A, B, C)</code>, <strong>not</strong> <code>((A, B), C)</code>. We achieve this using implicit <code>Composition</code> instances provided by the <a href=\"https://github.com/tulz-app/tuplez#composition\">tuplez</a> library.</p>\n<p dir=\"auto\"><strong>observableA.combineWithFn(observableB, ...)((a, b, ...) =&gt; ???)</strong></p>\n<p dir=\"auto\">Similar to <code>combineWith</code>, but you get to provide the combinator instead of relying on tuples. For example: <code>streamOfX.combineWithFn(streamOfY)(Point)</code> where Point is <code>case class Point(x: Int, y: Int)</code>.</p>\n<p dir=\"auto\"><strong>EventStream.combine(streamA, streamB, ...)</strong> et al.</p>\n<p dir=\"auto\">N-arity <code>combine</code> and <code>combineWithFn</code> methods are also available on EventStream and Signal companion objects.</p>\n<p dir=\"auto\"><strong>observableA.withCurrentValueOf(signalB, signalC, ...)</strong></p>\n<p dir=\"auto\">Same auto-flattening of tuples as <code>combineWith</code>.</p>\n<p dir=\"auto\"><strong>observable.sample(signalA, signalB, ...)</strong></p>\n<p dir=\"auto\">Returns an observable of <code>(A, B, ...)</code> tuples</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Compose Changes</h4><a id=\"user-content-compose-changes\" class=\"anchor\" aria-label=\"Permalink: Compose Changes\" href=\"#compose-changes\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Some operators are available only on Event Streams, not Signals. This is by design. For example, <code>filter</code> is not applicable to Signals because a Signal can't exist without a current value, so <code>signal.filter(_ =&gt; false)</code> would not make any sense. Similarly, you can't <code>delay(ms)</code> a signal because you can't delay its initial value.</p>\n<p dir=\"auto\">However, you can still use those operators with Signals, you just need to be explicit that you're applying them only to the Signal's changes, not to the initial value of the Signal:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val signal: Signal[Int] = ???\nval delayedSignal = signal.composeChanges(changes =&gt; changes.delay(1000)) // all updates delayed by one second\nval filteredSignal = signal.composeChanges(_.filter(_ % 2 == 0)) // only allows changes with even numbers (initial value can still be odd)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">signal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">delayedSignal</span> <span class=\"pl-k\">=</span> signal.composeChanges(changes <span class=\"pl-k\">=&gt;</span> changes.delay(<span class=\"pl-c1\">1000</span>)) <span class=\"pl-c\"><span class=\"pl-c\">//</span> all updates delayed by one second</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">filteredSignal</span> <span class=\"pl-k\">=</span> signal.composeChanges(_.filter(_ <span class=\"pl-k\">%</span> <span class=\"pl-c1\">2</span> <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span>)) <span class=\"pl-c\"><span class=\"pl-c\">//</span> only allows changes with even numbers (initial value can still be odd)</span></pre></div>\n<p dir=\"auto\">For more advanced transformations, <code>composeAll</code> operator lets you transform the Signal's initial value as well.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Sync Delay</h4><a id=\"user-content-sync-delay\" class=\"anchor\" aria-label=\"Permalink: Sync Delay\" href=\"#sync-delay\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Suppose you have two streams that emit in the same <a href=\"#transactions\">Transaction</a>. Generally you don't know in which order they will emit, unless one of them depends on the other.</p>\n<p dir=\"auto\">If this order matters to you, you can use <code>delaySync</code> operator to establish the desired order:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val stream1: EventStream[Int] = ???\nval stream2: EventStream[Int] = ???\n \nval stream1synced = stream1.delaySync(after = stream2)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">stream1</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">stream2</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n \n<span class=\"pl-k\">val</span> <span class=\"pl-v\">stream1synced</span> <span class=\"pl-k\">=</span> stream1.delaySync(after <span class=\"pl-k\">=</span> stream2)</pre></div>\n<p dir=\"auto\"><code>stream1synced</code> synchronously re-emits all values that <code>stream1</code> feeds into it. Its only guarantee is that if <code>stream1</code> and <code>stream2</code> emit in the same transaction, <code>stream1synced</code> will emit AFTER <code>stream2</code> (assuming it has observers of course, or it won't emit at all, as usual). Otherwise, <code>stream2</code> does not affect <code>stream1synced</code> in any way. Don't confuse this with the <code>sample</code> operator.</p>\n<p dir=\"auto\">Note: <code>delaySync</code> is better than a simple <code>delay</code> because it does not introduce an asynchronous boundary. <code>delaySync</code> does not use a <code>setTimeout</code> under the hood. In Airstream terms, <code>stream1synced</code> <em>synchronously depends</em> on <code>stream1</code>, so all events in <code>stream1synced</code> fire in the same transaction as <code>stream1</code>, which is not the case with <code>stream1.delay(1000)</code> – those events would fire in a separate Transaction, and at an async delay.</p>\n<p dir=\"auto\">Under the hood <code>delaySync</code> uses the same <code>pendingObservables</code> machinery as <code>combinedWith</code> operator – see <a href=\"#topological-rank\">Topological Rank</a> docs for an explanation.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Splitting Observables</h4><a id=\"user-content-splitting-observables\" class=\"anchor\" aria-label=\"Permalink: Splitting Observables\" href=\"#splitting-observables\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Airstream offers a powerful <code>split</code> operator that splits an observable of <code>M[Input]</code> into an observable of <code>M[Output]</code> based on <code>Input =&gt; Key</code>. The functionality of this operator is very generic, so we will explore its properties by diving into concrete examples.</p>\n<p dir=\"auto\">Note: These operators are available on qualifying streams and signals by means of <code>SplittableSignal</code> and <code>SplittableEventStream</code> value classes.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Example 0: Tests</h5><a id=\"user-content-example-0-tests\" class=\"anchor\" aria-label=\"Permalink: Example 0: Tests\" href=\"#example-0-tests\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">This operator is particularly hard to put into words, at least on my first try. You might want to read the <code>split signal into signals</code> test in <code>SplitEventStreamSpec.scala</code></p>\n<p dir=\"auto\">And hey, don't be a stranger, remember we have <a href=\"https://discord.gg/JTrUxhq7sj\" rel=\"nofollow\">Discord</a> for chat.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Example 1: Latest Version of Foo by Id</h5><a id=\"user-content-example-1-latest-version-of-foo-by-id\" class=\"anchor\" aria-label=\"Permalink: Example 1: Latest Version of Foo by Id\" href=\"#example-1-latest-version-of-foo-by-id\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><em>If you are familiar with Laminar, consider skipping to the second example</em></p>\n<p dir=\"auto\">Suppose you have an <code>Signal[List[Foo]]</code>, and you want to get <code>Signal[Map[String, Signal[Foo]]]</code> where the keys of the map are Foo ids, and the values of the map are signals of the latest version of a Foo with that id.</p>\n<p dir=\"auto\">The important part here is the desire to obtain individual signals of Foo by id, not to transform a <code>List</code> into a <code>Map</code>. Here is how we could do this:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"case class Foo(id: String, version: Int)\nval inputSignal: Signal[List[Foo]] = ???\n \nval outputSignal: Signal[List[(String, Signal[Foo])]] = inputSignal.split(\n  key = _.id\n)(\n  project = (key, initialFoo, thisFooSignal) =&gt; (key, thisFooSignal)\n)\n \nval resultSignal: Signal[Map[String, Signal[Foo]]] = outputSignal.map(list =&gt; Map(list: _*))\"><pre><span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">Foo</span>(<span class=\"pl-v\">id</span>: <span class=\"pl-en\">String</span>, <span class=\"pl-v\">version</span>: <span class=\"pl-en\">Int</span>)\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">inputSignal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">List</span>[<span class=\"pl-en\">Foo</span>]] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n \n<span class=\"pl-k\">val</span> <span class=\"pl-v\">outputSignal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">List</span>[(<span class=\"pl-en\">String</span>, <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">Foo</span>])]] <span class=\"pl-k\">=</span> inputSignal.split(\n  key <span class=\"pl-k\">=</span> _.id\n)(\n  project <span class=\"pl-k\">=</span> (key, initialFoo, thisFooSignal) <span class=\"pl-k\">=&gt;</span> (key, thisFooSignal)\n)\n \n<span class=\"pl-k\">val</span> <span class=\"pl-v\">resultSignal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">Map</span>[<span class=\"pl-en\">String</span>, <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">Foo</span>]]] <span class=\"pl-k\">=</span> outputSignal.map(list <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">Map</span>(<span class=\"pl-v\">list</span>: _<span class=\"pl-k\">*</span>))</pre></div>\n<p dir=\"auto\">Let's unpack all this.</p>\n<p dir=\"auto\">In this example our input is a signal of a list of Foo-s, and we <code>split</code> it into a signal of a list of <code>(fooId, fooSignal)</code> pairs. In each of those pairs, <code>fooSignal</code> is a signal that emits a new <code>Foo</code> whenever <code>inputSignal</code> emits a value that contains a Foo such that <code>foo.id == fooId</code>.</p>\n<p dir=\"auto\">So essentially each of the pairs in <code>outputSignal</code> contains a a foo id and a signal of the latest version of a Foo for this id, as found in <code>inputSignal</code>.</p>\n<p dir=\"auto\">Finally, in <code>resultSignal</code> we trivially transform <code>outputSignal</code> to convert a list to a map.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Example 2: Dynamic Lists of Laminar Elements</h5><a id=\"user-content-example-2-dynamic-lists-of-laminar-elements\" class=\"anchor\" aria-label=\"Permalink: Example 2: Dynamic Lists of Laminar Elements\" href=\"#example-2-dynamic-lists-of-laminar-elements\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Suppose you want to render a list of <code>Foo</code>-s into a list of elements. You know how to render an individual <code>Foo</code> from its signal, but the list of Foo-s changes over time, and you want to avoid unnecessarily re-creating DOM elements.</p>\n<p dir=\"auto\">This is what you can do:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"case class Foo(id: String, version: Int)\n   \ndef renderFoo(fooId: String, initialFoo: Foo, fooSignal: Signal[Foo]): HtmlElement = {\n  div(\n    &quot;foo id: &quot; + fooId,\n    &quot;first seen foo with this id: &quot; + initialFoo.toString,\n    &quot;last seen foo with this id: &quot;,\n    child &lt;-- fooSignal.map(_.toString)\n  )\n}\n \nval inputSignal: Signal[List[Foo]] = ???\nval outputSignal: Signal[List[HtmlElement]] = inputSignal.split(\n  key = _.id\n)(\n  project = renderFoo\n)\"><pre><span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">Foo</span>(<span class=\"pl-v\">id</span>: <span class=\"pl-en\">String</span>, <span class=\"pl-v\">version</span>: <span class=\"pl-en\">Int</span>)\n   \n<span class=\"pl-k\">def</span> <span class=\"pl-en\">renderFoo</span>(<span class=\"pl-v\">fooId</span>: <span class=\"pl-en\">String</span>, <span class=\"pl-v\">initialFoo</span>: <span class=\"pl-en\">Foo</span>, <span class=\"pl-v\">fooSignal</span>: <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">Foo</span>])<span class=\"pl-k\">:</span> <span class=\"pl-en\">HtmlElement</span> <span class=\"pl-k\">=</span> {\n  div(\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>foo id: <span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> fooId,\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>first seen foo with this id: <span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> initialFoo.toString,\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>last seen foo with this id: <span class=\"pl-pds\">\"</span></span>,\n    child <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> fooSignal.map(_.toString)\n  )\n}\n \n<span class=\"pl-k\">val</span> <span class=\"pl-v\">inputSignal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">List</span>[<span class=\"pl-en\">Foo</span>]] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">outputSignal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">List</span>[<span class=\"pl-en\">HtmlElement</span>]] <span class=\"pl-k\">=</span> inputSignal.split(\n  key <span class=\"pl-k\">=</span> _.id\n)(\n  project <span class=\"pl-k\">=</span> renderFoo\n)</pre></div>\n<p dir=\"auto\">This works somewhat similarly to React.js keys, if you're familiar with that API:</p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">As soon as a <code>Foo</code> with id=\"123\" appears in inputSignal, we call <code>renderFoo</code> to render it. This gives us a <code>Div</code> element <strong>that we will reuse</strong> for all future versions of this foo.</p>\n</li>\n<li>\n<p dir=\"auto\">We remember this <code>Div</code> element. Whenever <code>inputSignal</code> updates with a new version of the id=\"123\" foo, the <code>fooSignal</code> in <code>renderFoo</code> is updated with this new version.</p>\n</li>\n<li>\n<p dir=\"auto\">Similarly, when other foo-s are updated in <code>inputSignal</code> their updates are scoped to their own invocations of <code>renderFoo</code>. The grouping happens by <code>key</code>, which in our case is the id of Foo.</p>\n</li>\n<li>\n<p dir=\"auto\">When the list emitted by <code>inputSignal</code> no longer contains a Foo with id=\"123\", we remove its Div from the output and forget that we ever made it.</p>\n</li>\n<li>\n<p dir=\"auto\">Thus, the output signal contains a list of Div elements matching one-to-one to the Foo-s in the input signal list.</p>\n</li>\n</ul>\n<p dir=\"auto\">So in essence, our <code>outputSignal</code> is broadly equivalent to <code>inputSignal.map(_.map(renderFoo))</code>, except that <code>renderFoo</code> requires <strong>memoization</strong> and <strong>data</strong> that simple mapping can't provide, thus the need for <code>split</code>.</p>\n<p dir=\"auto\">To drive the point home, let's see how we would likely do this without <code>split</code>:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"case class Foo(id: String, version: Int)\n   \ndef renderFoo(foo: Foo): Div = {\n  div(\n    &quot;foo id: &quot; + foo.id,\n    &quot;last seen foo with this id: &quot; + foo.toString\n  )\n}\n \nval inputSignal: Signal[List[Foo]] = ???\nval outputSignal: Signal[List[Div]] = inputSignal.map(_.map(renderFoo))\"><pre><span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">Foo</span>(<span class=\"pl-v\">id</span>: <span class=\"pl-en\">String</span>, <span class=\"pl-v\">version</span>: <span class=\"pl-en\">Int</span>)\n   \n<span class=\"pl-k\">def</span> <span class=\"pl-en\">renderFoo</span>(<span class=\"pl-v\">foo</span>: <span class=\"pl-en\">Foo</span>)<span class=\"pl-k\">:</span> <span class=\"pl-en\">Div</span> <span class=\"pl-k\">=</span> {\n  div(\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>foo id: <span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> foo.id,\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>last seen foo with this id: <span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> foo.toString\n  )\n}\n \n<span class=\"pl-k\">val</span> <span class=\"pl-v\">inputSignal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">List</span>[<span class=\"pl-en\">Foo</span>]] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">outputSignal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">List</span>[<span class=\"pl-en\">Div</span>]] <span class=\"pl-k\">=</span> inputSignal.map(_.map(renderFoo))</pre></div>\n<p dir=\"auto\">Same input and output types, but the behaviour is very different.</p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">First, renderFoo is now called every time inputSignal updates, for every Foo. This means that we are recreating the entire list of DOM nodes from scratch on every update. This is very inefficient.</p>\n<ul dir=\"auto\">\n<li>In contrast, with <code>split</code>, we would only call <code>renderFoo</code> whenever we would see a new Foo with a previously unseen id in <code>inputSignal</code>, and the <code>child &lt;-- ...</code> modifier would take care of updating existing elements as new versions foo came in.</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\">Second, renderFoo no longer has access to <code>initialFoo</code> and <code>fooSignal</code>. It does not know anymore if the foo it's rendering has changed over time, it can't listen for those changes, etc.</p>\n</li>\n</ul>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\"><code>distinctCompose</code> parameter</h5><a id=\"user-content-distinctcompose-parameter\" class=\"anchor\" aria-label=\"Permalink: distinctCompose parameter\" href=\"#distinctcompose-parameter\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">The <a href=\"#splitting-observables\">split</a> operator internally uses <code>==</code> checks to determine whether each record in the collection has \"changed\" or not. If not for these <code>==</code> checks, <code>split</code> would trigger a useless update for every record on every incoming event, instead of triggering only on the record that was actually affected by the event.</p>\n<p dir=\"auto\">To allow customization, the <code>split</code> operator has a second parameter called <code>distinctCompose</code> which indicates how exactly the values are to be distinct-ed, and defaults to <code>_.distinct</code>. You can override it to provide a custom distinctor function if desired:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"children &lt;-- nodesStream.split(_.id, _.distinctByFn(customComparator))(/*...*/)\"><pre>children <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> nodesStream.split(_.id, _.distinctByFn(customComparator))(<span class=\"pl-c\"><span class=\"pl-c\">/*</span>...<span class=\"pl-c\">*/</span></span>)</pre></div>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\"><code>splitByIndex</code></h5><a id=\"user-content-splitbyindex\" class=\"anchor\" aria-label=\"Permalink: splitByIndex\" href=\"#splitbyindex\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">The <code>split</code> operator requires a unique key for each item, such as <code>_.id</code>. But what if you don't have such a key?</p>\n<p dir=\"auto\">One option is to change your model to create an ephemeral key, that is generated on the frontend and never sent to the backend. Airstream does not need the key to be meaningful or consistent across user sessions – the key simply needs to identify a certain item in the dynamic list for as long as Laminar is rendering that list.</p>\n<p dir=\"auto\">Another, simpler solution, is often quite workable – with <code>splitByIndex</code> you can use the index of the item in the list as its key. This works as well as any other key if you only ever append items to the list, and don't insert items in the middle, remove items from the middle, or reorder the items.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\"><code>splitOne</code></h5><a id=\"user-content-splitone\" class=\"anchor\" aria-label=\"Permalink: splitOne\" href=\"#splitone\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Now that you know how the <code>split</code> operator works, it's only a small leap to understand its special-cased cousin <code>splitOne</code>. Where <code>split</code> works on observables of <code>List[Foo]</code>, <code>Option[Foo]</code> etc., <code>splitOne</code> works on observables of <code>Foo</code> itself, that is, on any observable:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"case class Editor(text: Boolean, isMultiLine: Boolean)\n   \ndef renderEditor(\n  isMultiLine: Boolean,\n  initialEditor: Editor,\n  editorSignal: Signal[Editor]\n): HtmlElement = {\n  val tag = if (isMultiLine) textArea else input\n  tag(value &lt;-- editorSignal.map(_.text))\n}\n \nval inputSignal: Signal[Editor] = ???\n \nval outputSignal: Signal[HtmlElement] = \n  inputSignal.split(key = _.isMultiLine)(project = renderEditor)\"><pre><span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">Editor</span>(<span class=\"pl-v\">text</span>: <span class=\"pl-en\">Boolean</span>, <span class=\"pl-v\">isMultiLine</span>: <span class=\"pl-en\">Boolean</span>)\n   \n<span class=\"pl-k\">def</span> <span class=\"pl-en\">renderEditor</span>(\n  <span class=\"pl-v\">isMultiLine</span>: <span class=\"pl-en\">Boolean</span>,\n  <span class=\"pl-v\">initialEditor</span>: <span class=\"pl-en\">Editor</span>,\n  <span class=\"pl-v\">editorSignal</span>: <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">Editor</span>]\n)<span class=\"pl-k\">:</span> <span class=\"pl-en\">HtmlElement</span> <span class=\"pl-k\">=</span> {\n  <span class=\"pl-k\">val</span> <span class=\"pl-v\">tag</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">if</span> (isMultiLine) textArea <span class=\"pl-k\">else</span> input\n  tag(value <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> editorSignal.map(_.text))\n}\n \n<span class=\"pl-k\">val</span> <span class=\"pl-v\">inputSignal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">Editor</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n \n<span class=\"pl-k\">val</span> <span class=\"pl-v\">outputSignal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">HtmlElement</span>] <span class=\"pl-k\">=</span> \n  inputSignal.split(key <span class=\"pl-k\">=</span> _.isMultiLine)(project <span class=\"pl-k\">=</span> renderEditor)</pre></div>\n<p dir=\"auto\">The example is a bit contrived to demonstrate that <code>key</code> does not need to be a record ID but could be any property. In this case, <code>renderEditor</code> will be called only when the next emitted word's <code>isMultiline</code> value is different from that of the last emitted editor, because that is when we need to change the tag we use – it's impossible to update the tag name of an existing element.</p>\n<p dir=\"auto\">Another use case for this is when you want to reset a complex component's state, for example:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"case class Document(id: String, content: DocumentContent, ...)\n   \ndef editor(\n  documentId: Boolean,\n  initialDocument: Document,\n  documentSignal: Signal[Document]\n): HtmlElement = {\n  val documentState = Var(initialDocument)\n  ... // More complex setup here, with some internal state specific to a particular document\n  div(\n    someInput --&gt; documentState,\n    documentSignal.map(...) --&gt; documentState,\n    documentState --&gt; ...\n  )\n}\n \nval inputSignal: Signal[Document] = ???\n \nval outputSignal: Signal[HtmlElement] = \n  inputSignal.split(key = _.id)(project = editor)\"><pre><span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">Document</span>(<span class=\"pl-v\">id</span>: <span class=\"pl-en\">String</span>, <span class=\"pl-v\">content</span>: <span class=\"pl-en\">DocumentContent</span>, ...)\n   \n<span class=\"pl-k\">def</span> <span class=\"pl-en\">editor</span>(\n  <span class=\"pl-v\">documentId</span>: <span class=\"pl-en\">Boolean</span>,\n  <span class=\"pl-v\">initialDocument</span>: <span class=\"pl-en\">Document</span>,\n  <span class=\"pl-v\">documentSignal</span>: <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">Document</span>]\n)<span class=\"pl-k\">:</span> <span class=\"pl-en\">HtmlElement</span> <span class=\"pl-k\">=</span> {\n  <span class=\"pl-k\">val</span> <span class=\"pl-v\">documentState</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">Var</span>(initialDocument)\n  ... <span class=\"pl-c\"><span class=\"pl-c\">//</span> More complex setup here, with some internal state specific to a particular document</span>\n  div(\n    someInput <span class=\"pl-k\">--</span><span class=\"pl-k\">&gt;</span> documentState,\n    documentSignal.map(...) <span class=\"pl-k\">--</span><span class=\"pl-k\">&gt;</span> documentState,\n    documentState <span class=\"pl-k\">--</span><span class=\"pl-k\">&gt;</span> ...\n  )\n}\n \n<span class=\"pl-k\">val</span> <span class=\"pl-v\">inputSignal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">Document</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n \n<span class=\"pl-k\">val</span> <span class=\"pl-v\">outputSignal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">HtmlElement</span>] <span class=\"pl-k\">=</span> \n  inputSignal.split(key <span class=\"pl-k\">=</span> _.id)(project <span class=\"pl-k\">=</span> editor)</pre></div>\n<p dir=\"auto\">In this case we don't have a strict technical constraint like changing the element type that we need to work around. In principle, we don't absolutely need <code>splitOne</code>. However, imagine that this component is rendering an editor for a complex document, similar to e.g. Google Docs. This kind of component has a lot of internal state which is all tied to a specific document, to a specific document ID. When <code>inputSignal</code> emits an update to the current document (documentId is the same), we want <code>documentSignal</code> to update as usual, but when <code>inputSignal</code> emits a new document ID... we don't want to manually clear / reset all that complex <code>documentId</code>-specific state inside <code>editor</code> – with all the redundant state / caches / etc. in it, this could easily become prone to bugs. It would be much easier to simply discard the old editor component and create a new one for the new document. And this is exactly what the code above does. Less code – fewer bugs.</p>\n<p dir=\"auto\">In other words, our <code>splitOne</code> code above guarantees that every instance of <code>documentSignal</code> will always have unchanging <code>document.id</code> matching <code>documentId</code>, and that the <code>editor</code> method will be called whenever we switch to rendering a new <code>documentId</code>.</p>\n<p dir=\"auto\">This all might seem similar to what a <code>distinct</code> operator would do, and indeed there is some conceptual overlap, because <code>distinct</code> is a fundamental part of <code>split</code> semantics, but you will be hard pressed to implement this pattern with <code>distinct</code> instead of <code>splitOne</code>, at least if you have a single observable like <code>Signal[Document]</code> as your input.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Split Operators for Special Types</h5><a id=\"user-content-split-operators-for-special-types\" class=\"anchor\" aria-label=\"Permalink: Split Operators for Special Types\" href=\"#split-operators-for-special-types\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">The canonical <a href=\"#splitting-observables\"><code>split</code> operator</a> works on collections, but there are a few types that we can think of as fixed-size collections, or perhaps rather, as types with a fixed number of branches, of which only one is active at a time.</p>\n<p dir=\"auto\">For example, all of the following types have two possible branches:</p>\n<ul dir=\"auto\">\n<li><code>Boolean</code> has <code>true</code> and <code>false</code></li>\n<li><code>Option[Foo]</code> has <code>Some[Foo]</code> and <code>None</code></li>\n<li><code>Try[V]</code> has <code>Success[V]</code> and <code>Failure</code></li>\n<li><code>Either[L, R]</code> has <code>Left[L]</code> and <code>Right[R]</code></li>\n<li><code>Status[In, Out]</code> has <code>Pending[In]</code> and <code>Resolved[In, Out]</code></li>\n</ul>\n<p dir=\"auto\">For each of those types, we have <code>split&lt;type&gt;</code> operators that let you switch between the two branches, in a similar manner to how the standard <code>split</code> operator lets you switch between the items in the collection.</p>\n<p dir=\"auto\">Perhaps a very concrete example in Laminar would help:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val userTrySignal: Signal[Try[User]] = ???\ndiv(\n  child &lt;-- userTrySignal.splitTry(\n    success = (initialUser: User, userSignal: Signal[User]) =&gt;\n       div(&quot;User name: &quot;, text &lt;-- userSignal.map(_.name)),\n    failure = (initialErr: Throwable, errSignal: Signal[Throwable]) =&gt;\n       div(&quot;Something is wrong: &quot;, text &lt;-- errSignal.map(_.getMessage))\n  )\n)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">userTrySignal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">Try</span>[<span class=\"pl-en\">User</span>]] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\ndiv(\n  child <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> userTrySignal.splitTry(\n    success <span class=\"pl-k\">=</span> (<span class=\"pl-v\">initialUser</span>: <span class=\"pl-en\">User</span>, <span class=\"pl-v\">userSignal</span>: <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">User</span>]) <span class=\"pl-k\">=&gt;</span>\n       div(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>User name: <span class=\"pl-pds\">\"</span></span>, text <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> userSignal.map(_.name)),\n    failure <span class=\"pl-k\">=</span> (<span class=\"pl-v\">initialErr</span>: <span class=\"pl-en\">Throwable</span>, <span class=\"pl-v\">errSignal</span>: <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">Throwable</span>]) <span class=\"pl-k\">=&gt;</span>\n       div(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Something is wrong: <span class=\"pl-pds\">\"</span></span>, text <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> errSignal.map(_.getMessage))\n  )\n)</pre></div>\n<p dir=\"auto\">As you can see, <code>splitTry</code>'s callbacks are very similar to the standard <code>split</code> callback, except that the discriminator key was implicitly decided for you (<code>_.isSuccess</code>), and you get separate callbacks for each branch, that are precisely typed for its values.</p>\n<p dir=\"auto\">Let's work through this example to make sure you understand what's happening. In the code above, the <code>failure</code> callback is called once when <code>userTrySignal</code> emits <code>Failure(v1)</code> for the first time, and then if it subsequently emits <code>Failure(v2)</code>, the <code>failure</code> callback is <em>not</em> called again, but <code>errSignal</code> is updated with value <code>v2</code>. And if then <code>userTrySignal</code> emits <code>Success(v3)</code>, we forget everything we did with the <code>failure</code> callback, and call the <code>success</code> callback, and if we then emit <code>Right(v4)</code>, then <code>successSignal</code> will be updated to value <code>v4</code>, but the <code>success</code> callback itself will <em>not</em> be called. And so on.</p>\n<p dir=\"auto\">You can see how this parallels the standard <a href=\"#splitting-observables\"><code>split</code> operator</a> behaviour, right? Consider that our <code>splitTry</code> is roughly equivalent to <code>userListSignal.split(_.isSuccess)((_, initialUserTry: Try[User], trySignal: Signal[Try[Usr]]) =&gt; C)</code>, and that the events we mentioned are roughly equivalent to <code>userListSignal</code> emitting single-item collections: <code>List(Failure(v1))</code>, <code>List(Failure(v2))</code>, <code>List(Failure(v3))</code>, <code>List(Failure(v4))</code>, etc. – so, given the <code>_.isSuccess</code> discriminator key, switching between Failure and Success branches is similar to switching between <em>unrelated</em> elements in the list, and switching between values <em>within the branch</em> is similar to <em>updating</em> a collection item with a given \"id\" (which happens to be <code>_.isSuccess</code> in this case).</p>\n<p dir=\"auto\">If this is confusing, make sure you understand the regular <code>split</code> operator first. The big Laminar video also has a <a href=\"https://www.youtube.com/watch?v=L_AHCkl6L-Q&amp;t=767s\" rel=\"nofollow\">chapter</a> about it, maybe that's more helpful.</p>\n<p dir=\"auto\">Aside from <code>splitEither</code>, we also have <code>splitOption</code>, <code>splitTry</code>, <code>splitStatus</code>, <code>splitStatus</code>, and <code>splitBoolean</code>, which behave similarly. We actually have more type-specific operators for these types, like <code>mapSome</code>, <code>collectRight</code>, <code>foldStatus</code>, etc. – see <a href=\"#specialized-type-operators\">Specialized Type Operators</a> section below.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Duplicate Key Warnings</h5><a id=\"user-content-duplicate-key-warnings\" class=\"anchor\" aria-label=\"Permalink: Duplicate Key Warnings\" href=\"#duplicate-key-warnings\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">The <code>split</code> operator does not tolerate items with non-unique keys – this is simply invalid input for it, and it will crash and burn if provided such bad data.</p>\n<p dir=\"auto\">Therefore, Airstream offers duplicate key warnings by default. <strong>Your code will still break</strong> if the <code>split</code> operator encounters duplicate keys, but Airstream will first print a warning in the browser console listing the duplicate keys at fault.</p>\n<p dir=\"auto\">Thus, these new warnings do not affect the execution of your code, and can be safely turned on for debugging or turned off for performance. You can adjust this setting both for your entire application, and for individual usages of <code>split</code>:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// Disable duplicate key warnings by default\nDuplicateKeysConfig.setDefault(DuplicateKeysConfig.noWarnings)\n\n// Disable warnings for just one split observable\nstream.split(_.id, duplicateKeys = DuplicateKeysConfig.noWarnings)(...)\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> Disable duplicate key warnings by default</span>\n<span class=\"pl-en\">DuplicateKeysConfig</span>.setDefault(<span class=\"pl-en\">DuplicateKeysConfig</span>.noWarnings)\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Disable warnings for just one split observable</span>\nstream.split(_.id, duplicateKeys <span class=\"pl-k\">=</span> <span class=\"pl-en\">DuplicateKeysConfig</span>.noWarnings)(...)</pre></div>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Splitting Vars</h4><a id=\"user-content-splitting-vars\" class=\"anchor\" aria-label=\"Permalink: Splitting Vars\" href=\"#splitting-vars\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Similarly to how you can <code>split</code> a <code>Signal[List[A]]</code> into N individual <code>Signal[A]</code> (see the whole section above), you can split a <code>Var[List[A]]</code> into N individual <code>Var[A]</code>. Each of those Vars is linked both ways to the parent <code>Var[List[A]]</code>, such that updating the parent Var updates the relevant child Vars, and updating the child Var updates the data of that child in the parent Var.</p>\n<p dir=\"auto\">For example, in the example below, the user's name in both <code>userVar</code> and <code>usersVar</code> is updated when you type the new name into the input text box.</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// Laminar example\ncase class User(id: String, name: String)\nval usersVar = Var[List[User]](???)\n\ndiv(\n  usersVar.split(_.id)((userId, initial, userVar) =&gt; {\n    div(\n      s&quot;User ${userId}: &quot;,\n      input(\n        value &lt;-- userVar.signal.map(_.name),\n        onInput.mapToValue --&gt; { newName =&gt;\n          userVar.update(_.copy(name = newName))\n        }\n      )\n    )\n  })\n)\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> Laminar example</span>\n<span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">User</span>(<span class=\"pl-v\">id</span>: <span class=\"pl-en\">String</span>, <span class=\"pl-v\">name</span>: <span class=\"pl-en\">String</span>)\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">usersVar</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">Var</span>[<span class=\"pl-en\">List</span>[<span class=\"pl-en\">User</span>]](<span class=\"pl-k\">???</span>)\n\ndiv(\n  usersVar.split(_.id)((userId, initial, userVar) <span class=\"pl-k\">=&gt;</span> {\n    div(\n      <span class=\"pl-k\">s</span><span class=\"pl-s\">\"</span><span class=\"pl-s\">User </span>${userId}<span class=\"pl-s\">: </span><span class=\"pl-s\">\"</span>,\n      input(\n        value <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> userVar.signal.map(_.name),\n        onInput.mapToValue <span class=\"pl-k\">--</span><span class=\"pl-k\">&gt;</span> { newName <span class=\"pl-k\">=&gt;</span>\n          userVar.update(_.copy(name <span class=\"pl-k\">=</span> newName))\n        }\n      )\n    )\n  })\n)</pre></div>\n<p dir=\"auto\">These individual child Var-s provided by <code>split</code> work similarly to lazy derived vars created with the Var's <code>zoomLazy</code> method. Their state is always derived from the state of the splittable parent var (<code>usersVar</code> in this case). The <code>zoomIn</code> function selects the item by the split key (<code>_.id</code> in this case), and the <code>zoomOut</code> function updates the item in the parent var, finding it by matching the split key (<code>_.id == userId</code>).</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Splitting Vars with in-place mutations</h5><a id=\"user-content-splitting-vars-with-in-place-mutations\" class=\"anchor\" aria-label=\"Permalink: Splitting Vars with in-place mutations\" href=\"#splitting-vars-with-in-place-mutations\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Vars that contain mutable collections such as <code>mutable.Buffer</code> or <code>js.Array</code> also offer a <code>splitMutate</code> method. It works just like their regular <code>split</code> method, except that when you update one of the individual child Var-s, the <code>splitMutate</code> operator <strong>mutates</strong> the contents of the splittable Var with the new child data, instead of creating an updated copy of it. For large collections this could be more efficient.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Async Status Operators</h4><a id=\"user-content-async-status-operators\" class=\"anchor\" aria-label=\"Permalink: Async Status Operators\" href=\"#async-status-operators\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><em>For the full list of Status-related operators, see the <a href=\"#status-operators\">Status Operators</a> subsection below.</em></p>\n<p dir=\"auto\">When performing async operations using event streams, you sometimes need to know the current status of the operation – was it never triggered, was it triggered but is it still pending, or is it complete? (For error handling, refer to <a href=\"#error-handling\">Airstream error handling</a>).</p>\n<p dir=\"auto\">Basic types:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"sealed trait Status[+In, +Out] { /* ... */ }\ncase class Pending[+In](input: In) extends Status[In, Nothing] { /* ... */ }\ncase class Resolved[+In, +Out](input: In, output: Out, ix: Int) extends Status[In, Out] { /* ... */ }\"><pre><span class=\"pl-k\">sealed</span> <span class=\"pl-k\">trait</span> <span class=\"pl-en\">Status</span>[<span class=\"pl-k\">+</span><span class=\"pl-en\">In</span>, <span class=\"pl-k\">+</span><span class=\"pl-en\">Out</span>] { <span class=\"pl-c\"><span class=\"pl-c\">/*</span> ... <span class=\"pl-c\">*/</span></span> }\n<span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">Pending</span>[<span class=\"pl-k\">+</span><span class=\"pl-en\">In</span>](<span class=\"pl-v\">input</span>: <span class=\"pl-en\">In</span>) <span class=\"pl-k\">extends</span> <span class=\"pl-en\">Status</span>[<span class=\"pl-en\">In</span>, <span class=\"pl-en\">Nothing</span>] { <span class=\"pl-c\"><span class=\"pl-c\">/*</span> ... <span class=\"pl-c\">*/</span></span> }\n<span class=\"pl-k\">case</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">Resolved</span>[<span class=\"pl-k\">+</span><span class=\"pl-en\">In</span>, <span class=\"pl-k\">+</span><span class=\"pl-en\">Out</span>](<span class=\"pl-v\">input</span>: <span class=\"pl-en\">In</span>, <span class=\"pl-v\">output</span>: <span class=\"pl-en\">Out</span>, <span class=\"pl-v\">ix</span>: <span class=\"pl-en\">Int</span>) <span class=\"pl-k\">extends</span> <span class=\"pl-en\">Status</span>[<span class=\"pl-en\">In</span>, <span class=\"pl-en\">Out</span>] { <span class=\"pl-c\"><span class=\"pl-c\">/*</span> ... <span class=\"pl-c\">*/</span></span> }</pre></div>\n<p dir=\"auto\">Suppose we have a stream of networks request arguments (<code>requestS</code>), and we want to execute those requests, and show a \"loading\" indicator while the requests are in progress. This is how we could do it:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val requestS: EventStream[Request] = ???\n\ntype Response = String // but it could be something else\n\nval responseS: EventStream[Status[Request, Response]] =\n  requestS.flatMapWithStatus { request =&gt;\n    // returns EventStream[Response]\n    FetchStream.get(request.url, request.options)\n  }\n\nval isLoadingS: EventStream[Boolean] = responseS.map(_.isPending)\n\nval textS: EventStream[String] =\n  responseS.foldStatus(\n    resolved = _.toString,\n    pending = _ =&gt; &quot;Loading...&quot; \n  )\n\n// Example usage from Laminar:\ndiv(\n  child(img(src(&quot;spinner.gif&quot;))) &lt;-- isLoadingS,\n  text &lt;-- textS\n)\n\n// Or, perhaps more realistically:\ndiv(\n  child &lt;-- responseS.splitStatus(\n    (resolved, _) =&gt; div(&quot;Response: &quot; + resolved.output.toString),\n    (pending, _) =&gt; div(img(src(&quot;spinner.gif&quot;)), &quot;Loading ...&quot;)\n  )\n)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">requestS</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Request</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-en\">Response</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">String</span> <span class=\"pl-c\"><span class=\"pl-c\">//</span> but it could be something else</span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">responseS</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Status</span>[<span class=\"pl-en\">Request</span>, <span class=\"pl-en\">Response</span>]] <span class=\"pl-k\">=</span>\n  requestS.flatMapWithStatus { request <span class=\"pl-k\">=&gt;</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> returns EventStream[Response]</span>\n    <span class=\"pl-en\">FetchStream</span>.get(request.url, request.options)\n  }\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">isLoadingS</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Boolean</span>] <span class=\"pl-k\">=</span> responseS.map(_.isPending)\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">textS</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">String</span>] <span class=\"pl-k\">=</span>\n  responseS.foldStatus(\n    resolved <span class=\"pl-k\">=</span> _.toString,\n    pending <span class=\"pl-k\">=</span> _ <span class=\"pl-k\">=&gt;</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Loading...<span class=\"pl-pds\">\"</span></span> \n  )\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Example usage from Laminar:</span>\ndiv(\n  child(img(src(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>spinner.gif<span class=\"pl-pds\">\"</span></span>))) <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> isLoadingS,\n  text <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> textS\n)\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Or, perhaps more realistically:</span>\ndiv(\n  child <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> responseS.splitStatus(\n    (resolved, _) <span class=\"pl-k\">=&gt;</span> div(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Response: <span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> resolved.output.toString),\n    (pending, _) <span class=\"pl-k\">=&gt;</span> div(img(src(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>spinner.gif<span class=\"pl-pds\">\"</span></span>)), <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Loading ...<span class=\"pl-pds\">\"</span></span>)\n  )\n)</pre></div>\n<p dir=\"auto\">When we call <code>flatMapWithStatus(makeStream)</code>, we essentially call <a href=\"#flatmapswitch\">flatMapSwitch</a> on that stream, merge the resulting stream with the original stream, and wrap the events from the original stream into <code>Pending()</code>, and the (async) events from the inner stream created by <code>makeStream</code> – network responses in this case – into <code>Resolved()</code>.</p>\n<p dir=\"auto\">So for example, if requestS emits <code>request1</code>, the following will happen:</p>\n<ol dir=\"auto\">\n<li>The <code>flatMapWithStatus</code> operator will create <code>fetchStream = FetchStream.get(request1.url, request1.options)</code> internally, and <code>FetchStream</code> will start executing the request</li>\n<li>The <code>responseS</code> stream will immediately emit a <code>Pending(request1)</code> event</li>\n<li><code>fetchStream</code> will eventually emit the response event (<code>response1</code>), which by default happens to be the raw HTTP Body response text</li>\n<li><code>responseS</code> will then emit <code>Resolved(request1, response1, ix = 1)</code></li>\n</ol>\n<p dir=\"auto\">If <code>fetchStream</code> emitted more events afterward, <code>responseS</code> would have emitted the corresponding <code>Resolved(request1, responseN, ix = N)</code> events. But this particular <code>fetchStream</code> does not do that.</p>\n<p dir=\"auto\">If <code>requestS</code> emitted a new <code>request2</code> event before we received <code>response1</code>, <code>flatMapWithStatus</code> would forget about <code>request1</code> and would switch to processing <code>request2</code> (same sequence as above), similarly to how the regular <a href=\"#flatmapswitch\">flatMapSwitch</a> operator switches from one stream to another. This means that you may never get to process <code>response1</code>.</p>\n<p dir=\"auto\">Finally, we used <code>foldStatus</code> operator that is only available on observables of <code>Status</code>, to fold all types of <code>Status</code> into a string that we could display. Other Status-specific operators let you map status values over input or output values, etc.: <code>mapInput(input =&gt; input)</code>, <code>mapOutput(output =&gt; output)</code>, <code>mapPending(pending =&gt; ???)</code>, <code>mapResolved(resolved =&gt; ???)</code>.</p>\n<p dir=\"auto\">Aside from <code>flatMapWithStatus</code>, there are similar operators for non-flatMap-based async operators: <code>delayWithStatus</code>, <code>throttleWithStatus</code>, <code>debounceWithStatus</code>. They work similarly,e.g. you can think of <code>delayWithStatus(ms = 1000)</code> being equivalent to <code>flatMapWithStatus(ev =&gt; EventStream.delay(ms = 1000, event = ev))</code>.</p>\n<p dir=\"auto\">For example, suppose we're receiving messages from somewhere (<code>receivedMessageS</code>), and whenever a new message comes in, we want to automatically show its text for a few seconds, before switching to showing nothing (empty text). This is how we could do it:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val receivedMessageS: EventStream[String] = ???\n\nval messageStatusS: EventStream[Status[String, String]] =\n  receivedMessageS.delayWithStatus(ms = 3000)\n\nval showMessageS: EventStream[String] =\n  messageStatusS.foldStatus(\n    resolved = _ =&gt; &quot;&quot;,\n    pending = _.input // contains the event fired by `messageReceivedS`, i.e. the message\n  )\n  \ndiv(text &lt;-- showMessageS) // in Laminar\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">receivedMessageS</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">String</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">messageStatusS</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Status</span>[<span class=\"pl-en\">String</span>, <span class=\"pl-en\">String</span>]] <span class=\"pl-k\">=</span>\n  receivedMessageS.delayWithStatus(ms <span class=\"pl-k\">=</span> <span class=\"pl-c1\">3000</span>)\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">showMessageS</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">String</span>] <span class=\"pl-k\">=</span>\n  messageStatusS.foldStatus(\n    resolved <span class=\"pl-k\">=</span> _ <span class=\"pl-k\">=&gt;</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-pds\">\"</span></span>,\n    pending <span class=\"pl-k\">=</span> _.input <span class=\"pl-c\"><span class=\"pl-c\">//</span> contains the event fired by `messageReceivedS`, i.e. the message</span>\n  )\n  \ndiv(text <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">--</span> showMessageS) <span class=\"pl-c\"><span class=\"pl-c\">//</span> in Laminar</span></pre></div>\n<p dir=\"auto\">Note that in this example, both <code>input</code> and <code>output</code> in the <code>Resolved</code> case are the same, and contain the message emitted by <code>receivedMessageS</code>, because the <code>delay</code> operation does not transform the value, it only delays it.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Specialized Type Operators</h4><a id=\"user-content-specialized-type-operators\" class=\"anchor\" aria-label=\"Permalink: Specialized Type Operators\" href=\"#specialized-type-operators\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Airstream has many helper operators designed for specific types only. For example, all observables of Boolean have an <code>.not</code> aka <code>.invert</code> operator that flips the boolean.</p>\n<p dir=\"auto\">Such operators are mostly self-explanatory, at least once you've met similar ones for other types, so we only briefly list them below, with links to the files in which they are defined, that may have additional comments. Note that links go to <code>master</code> git branch, not any particular version. You can switch to a version tag in Github UI, or better yet, use your IDE code navigation.</p>\n<p dir=\"auto\">For the explanation of the split operators mentioned here, see <a href=\"#split-operators-for-special-types\">Split Operators for Special Types</a> section above.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Boolean Operators</h5><a id=\"user-content-boolean-operators\" class=\"anchor\" aria-label=\"Permalink: Boolean Operators\" href=\"#boolean-operators\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Operators: <code>not</code> aka <code>invert</code>, <code>foldBoolean</code>, <code>splitBoolean</code></p>\n<p dir=\"auto\">Sources: <a href=\"https://github.com/raquo/Airstream/blob/master/src/main/scala/com/raquo/airstream/extensions/BooleanObservable.scala\">BooleanObservable</a>, <a href=\"https://github.com/raquo/Airstream/blob/master/src/main/scala/com/raquo/airstream/extensions/BooleanStream.scala\">BooleanStream</a>, <a href=\"https://github.com/raquo/Airstream/blob/master/src/main/scala/com/raquo/airstream/extensions/BooleanSignal.scala\">BooleanSignal</a></p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Option Operators</h5><a id=\"user-content-option-operators\" class=\"anchor\" aria-label=\"Permalink: Option Operators\" href=\"#option-operators\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Operators: <code>mapSome</code>, <code>mapFilterSome</code>, <code>mapToRight</code>, <code>mapToLeft</code>, <code>foldOption</code>, <code>splitOption</code></p>\n<p dir=\"auto\">Stream-only operators: <code>collectSome</code></p>\n<p dir=\"auto\">Sources: <a href=\"https://github.com/raquo/Airstream/blob/master/src/main/scala/com/raquo/airstream/extensions/OptionObservable.scala\">OptionObservable</a>, <a href=\"https://github.com/raquo/Airstream/blob/master/src/main/scala/com/raquo/airstream/extensions/OptionStream.scala\">OptionStream</a>, <a href=\"https://github.com/raquo/Airstream/blob/master/src/main/scala/com/raquo/airstream/extensions/OptionSignal.scala\">OptionSignal</a></p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Try Operators</h5><a id=\"user-content-try-operators\" class=\"anchor\" aria-label=\"Permalink: Try Operators\" href=\"#try-operators\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Operators: <code>mapSuccess</code>, <code>mapFailure</code>, <code>mapToEither</code>, <code>foldTry</code>, <code>recoverFailure</code>, <code>throwFailure</code>, <code>splitTry</code></p>\n<p dir=\"auto\">Stream-only operators: <code>collectSuccess</code>, <code>collectFailure</code></p>\n<p dir=\"auto\">Sources: <a href=\"https://github.com/raquo/Airstream/blob/master/src/main/scala/com/raquo/airstream/extensions/TryObservable.scala\">TryObservable</a>, <a href=\"https://github.com/raquo/Airstream/blob/master/src/main/scala/com/raquo/airstream/extensions/TryStream.scala\">TryStream</a>, <a href=\"https://github.com/raquo/Airstream/blob/master/src/main/scala/com/raquo/airstream/extensions/TrySignal.scala\">TrySignal</a></p>\n<p dir=\"auto\">Also, some of the standard operators that deal with Try-s: <code>recoverToTry</code>, <code>EventStream.fromTry</code>, <code>Signal.fromTry</code></p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Either Operators</h5><a id=\"user-content-either-operators\" class=\"anchor\" aria-label=\"Permalink: Either Operators\" href=\"#either-operators\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Operators: <code>mapRight</code>, <code>mapLeft</code>, <code>mapToOption</code>, <code>mapLeftToOption</code>, <code>foldEither</code>, <code>swap</code>, <code>splitEither</code></p>\n<p dir=\"auto\">Stream-only operators: <code>collectLeft</code>, <code>collectRight</code></p>\n<p dir=\"auto\">Only when the <code>L</code> type in <code>Either[L, R]</code> is <code>Throwable</code>: <code>recoverLeft</code>, <code>throwLeft</code></p>\n<p dir=\"auto\">Sources: <a href=\"https://github.com/raquo/Airstream/blob/master/src/main/scala/com/raquo/airstream/extensions/EitherObservable.scala\">EitherObservable</a>, <a href=\"https://github.com/raquo/Airstream/blob/master/src/main/scala/com/raquo/airstream/extensions/EitherStream.scala\">EitherStream</a>, <a href=\"https://github.com/raquo/Airstream/blob/master/src/main/scala/com/raquo/airstream/extensions/EitherSignal.scala\">EitherSignal</a>, <a href=\"https://github.com/raquo/Airstream/blob/master/src/main/scala/com/raquo/airstream/extensions/EitherThrowableObservable.scala\">EitherThrowableObservable</a></p>\n<p dir=\"auto\">Also, some of the standard operators that deal with Either-s: <code>recoverToEither</code>, <code>EventStream.fromEither</code>, <code>Signal.fromEither</code></p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Status Operators</h5><a id=\"user-content-status-operators\" class=\"anchor\" aria-label=\"Permalink: Status Operators\" href=\"#status-operators\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">See <a href=\"#async-status-operators\">Async Status Operators</a> for explanation of the <code>Status</code> concept in Airstream.</p>\n<p dir=\"auto\">Operators: <code>mapOutput</code>, <code>mapInput</code>, <code>mapResolved</code>, <code>mapPending</code>, <code>foldStatus</code>, <code>splitStatus</code></p>\n<p dir=\"auto\">Stream-only operators: <code>collectOutput</code>, <code>collectResolved</code>, <code>collectPending</code>, <code>collectPendingInput</code></p>\n<p dir=\"auto\">Sources: <a href=\"https://github.com/raquo/Airstream/blob/master/src/main/scala/com/raquo/airstream/extensions/StatusObservable.scala\">StatusObservable</a>, <a href=\"https://github.com/raquo/Airstream/blob/master/src/main/scala/com/raquo/airstream/extensions/StatusStream.scala\">StatusStream</a>, <a href=\"https://github.com/raquo/Airstream/blob/master/src/main/scala/com/raquo/airstream/extensions/StatusSignal.scala\">StatusSignal</a></p>\n<p dir=\"auto\">Also, some of the standard operators that deal with Try-s:</p>\n<p dir=\"auto\"><code>flatMapWithStatus</code>, <code>delayWithStatus</code>, <code>throttleWithStatus</code>, <code>debounceWithStatus</code>.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Flattening Observables</h4><a id=\"user-content-flattening-observables\" class=\"anchor\" aria-label=\"Permalink: Flattening Observables\" href=\"#flattening-observables\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><em>Flattening</em> generally refers to reducing the number of nested container layers. For example, you could <code>.flatten</code> an <code>Option[Option[A]]</code> into an <code>Option[A]</code>, and in Airstream, you can flatten types like <code>EventStream[EventStream[A]]</code> into <code>EventStream[A]</code>. The <code>flatMap</code> operation works essentially similarly, just adding a <code>map</code> operation (that internally creates the nested structure) before flattening it.</p>\n<p dir=\"auto\">Note: Airstream offers several variations of <code>flatMap</code> and <code>flatten</code> operators, the \"standard\" ones being <code>flatMapSwitch</code> and <code>flattenSwitch</code>. More on these variations below.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Avoid unnecessary flatMap</h5><a id=\"user-content-avoid-unnecessary-flatmap\" class=\"anchor\" aria-label=\"Permalink: Avoid unnecessary flatMap\" href=\"#avoid-unnecessary-flatmap\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Unlike other contexts and libraries where flattening may be an unremarkable operation, <strong>in Airstream flattening is special and different and needs your attention to learn properly</strong>.</p>\n<p dir=\"auto\">Long story short, Airstream is able to automatically prevent <a href=\"#frp-glitches\">FRP glitches</a> within the confines of a <a href=\"#transactions\">Transaction</a>. Airstream's <code>flatMap*</code> and <code>flatten*</code> operators are <a href=\"#loopy-operators\">loopy</a> – so, due to their unlimited flexibility, they must break out of the current Transaction, and fire each of their events in a new Transaction. This is of course undesirable because splintering your dataflow into multiple transactions increases the opportunities for FRP glitches.</p>\n<p dir=\"auto\">You should use Airstream <code>flatMap*</code> / <code>flatten</code> operators <strong>only when you can't implement the required logic using <a href=\"#flowy-operators\">flowy operators</a> such as <code>combineWith</code> or <code>withCurrentValueOf</code></strong>. You should absolutely not be using <code>flatMap*</code> operators just to get the current values of two observables into the same scope. Such usage of <code>flatMap*</code> operators is <strong>unnecessary</strong>, and is likely to result in FRP glitches as your program grows in size.</p>\n<p dir=\"auto\">Unfortunately, with <code>flatMap</code> being such a common and innocuous operation on many data types, and being easily available via Scala's for-comprehensions, developers tend to reach for it in Airstream before they learn about the proper way to do these things in Airstream. So, starting with v17, we introduced additional friction to this workflow. Trying to use the methods named <code>flatMap</code> and <code>flatten</code> now throws a compiler error pointing to this documentation section. For now, you can convert it into deprecation warning by importing <code>FlattenStrategy.flatMapAllowed</code> (or <code>FlattenStrategy.flattenAllowed</code> for the <code>flatten</code> operator), however this option is only there to ease migration to v17, it will be removed in the future. See v17 release blog post for more details.</p>\n<p dir=\"auto\">If you see this compiler error, you should try to rewrite your logic with flowy operators like <code>combineWith</code>. Only if it's truly impossible to do that, should you use <code>flatMapSwitch</code>, or one of the other operators detailed below.</p>\n<p dir=\"auto\"><strong>See also Laminar docs about <a href=\"https://laminar.dev/documenation#flatmap-all-the-things\" rel=\"nofollow\">the flatMap anti-pattern</a>.</strong></p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Acceptable uses of flatMap</h5><a id=\"user-content-acceptable-uses-of-flatmap\" class=\"anchor\" aria-label=\"Permalink: Acceptable uses of flatMap\" href=\"#acceptable-uses-of-flatmap\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Perhaps the most popular legitimate use case for <code>flatMap</code> / <code>flatMapSwitch</code> is triggering a network request whenever a signal or stream updates, and subscribing to the corresponding network responses, all in one go, for example:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val userS: Signal[User] = ???\nval responseS: EventStream[Response] = userS.flatMapSwitch { user =&gt;\n  FetchStream.get(s&quot;/user/${user.id}&quot;)\n}\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">userS</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">User</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">responseS</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Response</span>] <span class=\"pl-k\">=</span> userS.flatMapSwitch { user <span class=\"pl-k\">=&gt;</span>\n  <span class=\"pl-en\">FetchStream</span>.get(<span class=\"pl-k\">s</span><span class=\"pl-s\">\"</span><span class=\"pl-s\">/user/</span>${user.id}<span class=\"pl-s\">\"</span>)\n}</pre></div>\n<p dir=\"auto\"><strong>This is a perfectly valid use case.</strong> You will not see any glitches when doing this, because the response events are fired independently of any other events that your observable graph may emit. And so, you have no choice but to use flatMap here.</p>\n<p dir=\"auto\">From another angle, you know that this will not cause glitches because these network response events are fired <em>asynchronously</em>. Glitches are essentially situations when events that you expect to happen <em>simultaneously</em>, happen <em>sequentially</em> instead (like in the <a href=\"https://github.com/raquo/Airstream#frp-glitches\">diamond glitch example</a>). But this mismatch of expectations can't arise if you don't actually expect your events to happen simultaneously with any other events. And since this is basically always the case for async events, the problem of glitches generally doesn't apply to observables emitting events asynchronously.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\"><code>flatMapSwitch</code></h5><a id=\"user-content-flatmapswitch\" class=\"anchor\" aria-label=\"Permalink: flatMapSwitch\" href=\"#flatmapswitch\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">This v17+ flatMap operator matches the default behavior of <code>flatMap</code> in prior versions of Airstream. It follows the default \"switching\" semantics of flatMap in Airstream. This variation of flatMap is probably what you want, if you need flatMap at all. Suppose you have:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val parentStream: EventStream[A] = ???\n\ndef makeInnerStream(ev: A): EventStream[B] = ???\n\nval flatStream: EventStream[B] =\n  parentStream.flatMapSwitch(ev =&gt; makeInnerStream(ev))\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">parentStream</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">A</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">makeInnerStream</span>(<span class=\"pl-v\">ev</span>: <span class=\"pl-en\">A</span>)<span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">B</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">flatStream</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">B</span>] <span class=\"pl-k\">=</span>\n  parentStream.flatMapSwitch(ev <span class=\"pl-k\">=&gt;</span> makeInnerStream(ev))</pre></div>\n<p dir=\"auto\">When <code>parentStream</code> emits <code>ev</code>, <code>flatStream</code> calls <code>makeInnerStream(ev)</code> to create an <code>innerStream</code> from that event, and starts \"mirroring\" this <code>innerStream</code>, i.e. it starts re-emitting all events emitted by this <code>innerStream</code>.</p>\n<p dir=\"auto\">Later, when <code>parentStream</code> emits a different <code>ev</code> event, <code>flatStream</code> kills the <code>innerStream</code> that it previously created, stops mirroring it, then creates a new version of it by calling <code>makeInnerStream</code> again – now with the new <code>ev</code> event – and starts \"mirroring\" this newly created <code>innerStream</code>.</p>\n<p dir=\"auto\">So, in short, whenever <code>parentStream</code> emits a new <code>ev</code> event, <code>flatStream</code> <strong>switches</strong> from mirroring the previous <code>innerStream</code> to mirroring the next <code>innerStream</code>. <strong>It forgets about the previous <code>innerStream</code> from then on.</strong></p>\n<p dir=\"auto\">The <code>flattenSwitch</code> operator does the same, except without the mapping part.</p>\n<p dir=\"auto\">This \"switching\" semantic is the canonical way to flatten observables in Airstream. You can flatten:</p>\n<ul dir=\"auto\">\n<li><code>Observable[EventStream[A]]</code> into <code>EventStream[A]</code></li>\n<li><code>Observable[Signal[A]]</code> into <code>Observable[A]</code></li>\n<li><code>EventStream[Signal[A]</code> into <code>EventStream[A]</code></li>\n<li><code>Signal[Signal[A]]</code> into <code>Signal[A]</code></li>\n</ul>\n<p dir=\"auto\">For implementations, see <code>trait SwitchingStrategy</code> and <code>class MetaObservable</code>.</p>\n<p dir=\"auto\">You can also flatten observables of Scala Futures, and Futures of Observables, and similarly with JS Promises, <strong>by first converting the Future / Promise into an Observable</strong>, for example using <code>Signal.fromFuture</code> or <code>EventStream.fromJsPromise</code>.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">flatMapMerge</h5><a id=\"user-content-flatmapmerge\" class=\"anchor\" aria-label=\"Permalink: flatMapMerge\" href=\"#flatmapmerge\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Aside from <strong>switching</strong> from one <code>innerStream</code> to another, there is another way to flatten an observable of streams – <strong>merging</strong> them. Instead of forgetting the previous <code>innerStream</code> when a new one is emitted, keep listening to all of them, accumulating more streams as <code>parentStream</code> emits more events.</p>\n<p dir=\"auto\">So, the resulting <code>flatStream</code> ends up emitting the events from <strong>all</strong> of the <code>innerStream</code>-s that is has seen. This is similar to the <code>mergeWith</code> operator, except the streams to be merged are provided dynamically. In that sense, it is also similar to the <code>EventBus.addSource</code> functionality, and the latter may be preferable in some cases since it is more flexible, allowing you to remove the added streams if you kept a reference to the subscription. There is no way to remove streams accumulated</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val parentBus: EventBus[A] = ???\n\nval parentStream: EventStream[A] = parentBus.events\n\ndef makeInnerStream(ev: A): EventStream[B] = ???\n\nval flatStream: EventStream[B] =\n  parentStream.flatMapMerge(ev =&gt; makeInnerStream(ev))\n  \nparentBus.emit(a1)\nparentBus.emit(a2)\n\n// Now flatStream re-emits the events from both\n// makeInnerStream(a1) and makeInnerStream(a2),\n// assuming it has any observers, of course.\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">parentBus</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventBus</span>[<span class=\"pl-en\">A</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">parentStream</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">A</span>] <span class=\"pl-k\">=</span> parentBus.events\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">makeInnerStream</span>(<span class=\"pl-v\">ev</span>: <span class=\"pl-en\">A</span>)<span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">B</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">flatStream</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">B</span>] <span class=\"pl-k\">=</span>\n  parentStream.flatMapMerge(ev <span class=\"pl-k\">=&gt;</span> makeInnerStream(ev))\n  \nparentBus.emit(a1)\nparentBus.emit(a2)\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Now flatStream re-emits the events from both</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> makeInnerStream(a1) and makeInnerStream(a2),</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> assuming it has any observers, of course.</span></pre></div>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Other Notable Operators</h4><a id=\"user-content-other-notable-operators\" class=\"anchor\" aria-label=\"Permalink: Other Notable Operators\" href=\"#other-notable-operators\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Once again, this is not a full list of Airstream operators, just some of the interesting / non-standard ones.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\"><code>take</code> and <code>drop</code> Operators</h5><a id=\"user-content-take-and-drop-operators\" class=\"anchor\" aria-label=\"Permalink: take and drop Operators\" href=\"#take-and-drop-operators\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">The <code>stream.take(numEvents)</code> operator returns a stream that re-emits the first <code>numEvents</code> events emitted by the parent <code>stream</code>, and then stops emitting. <code>stream.drop(numEvents)</code> does the opposite, skipping the first <code>numEvents</code> events and then starting to re-emit everything that the parent <code>stream</code> emits.</p>\n<p dir=\"auto\">These operators are available with several signatures:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"stream.take(numEvents = 5)\nstream.takeWhile(ev =&gt; passes(ev)) // stop taking when `passes(ev)` returns `false`\nstream.takeUntil(ev =&gt; passes(ev)) // stop taking when `passes(ev)` returns `true`\"><pre>stream.take(numEvents <span class=\"pl-k\">=</span> <span class=\"pl-c1\">5</span>)\nstream.takeWhile(ev <span class=\"pl-k\">=&gt;</span> passes(ev)) <span class=\"pl-c\"><span class=\"pl-c\">//</span> stop taking when `passes(ev)` returns `false`</span>\nstream.takeUntil(ev <span class=\"pl-k\">=&gt;</span> passes(ev)) <span class=\"pl-c\"><span class=\"pl-c\">//</span> stop taking when `passes(ev)` returns `true`</span></pre></div>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"stream.drop(numEvents = 5)\nstream.dropWhile(ev =&gt; passes(ev)) // stop skipping when `passes(ev)` returns `false`\nstream.dropUntil(ev =&gt; passes(ev)) // stop skipping when `passes(ev)` returns `true`\"><pre>stream.drop(numEvents <span class=\"pl-k\">=</span> <span class=\"pl-c1\">5</span>)\nstream.dropWhile(ev <span class=\"pl-k\">=&gt;</span> passes(ev)) <span class=\"pl-c\"><span class=\"pl-c\">//</span> stop skipping when `passes(ev)` returns `false`</span>\nstream.dropUntil(ev <span class=\"pl-k\">=&gt;</span> passes(ev)) <span class=\"pl-c\"><span class=\"pl-c\">//</span> stop skipping when `passes(ev)` returns `true`</span></pre></div>\n<p dir=\"auto\">Like some other operators, these have an optional <code>resetOnStop</code> argument. Defaults to <code>false</code>, but if set to <code>true</code>, they \"forget\" all past events, and are reset to their original state when the parent stream is stopped and then started again.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\"><code>filterWith</code></h5><a id=\"user-content-filterwith\" class=\"anchor\" aria-label=\"Permalink: filterWith\" href=\"#filterwith\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><code>stream.filterWith(signalOfBooleans)</code> emits events from <code>stream</code>, but only when the given signal's (or Var's) current value is <code>true</code>.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\"><code>tapEach</code></h5><a id=\"user-content-tapeach\" class=\"anchor\" aria-label=\"Permalink: tapEach\" href=\"#tapeach\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><code>observable.tapEach(callback)</code> executes a side effecting callback every time the observable emits. If it's a signal, it also runs when its initial value is evaluated. This method is similar in spirit to Scala collections <code>tapEach</code> method.</p>\n<p dir=\"auto\"><code>tapEach</code> is a helper for situations where the ergonomics of chaining are more important than keeping side effects in observers. Normally it's a good practice to put any side-effecting callbacks into observers, where they are easy to find and recognize.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">Operators vs Transactions</h3><a id=\"user-content-operators-vs-transactions\" class=\"anchor\" aria-label=\"Permalink: Operators vs Transactions\" href=\"#operators-vs-transactions\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">This section is intended to help understand the practical aspects of <a href=\"#transactions\">transactions</a> and <a href=\"#frp-glitches\">FRP glitches</a>. It assumes familiarity with those documentation sections, and seeks to improve their understanding.</p>\n<p dir=\"auto\">We say that some Airstream operators like <code>flatMap</code> fire events in a new transaction. This can cause FRP glitches in cases when, at a high level, using <code>flatMap</code> or similar transaction-creating methods was <strong>unnecessary</strong>. In contrast, when the usage of <code>flatMap</code> is truly <strong>necessary</strong> to achieve your desired behaviour, you will not see FRP glitches. Let's try to categorize the methods and operators that Airstream offers, to get a more intuitive understanding of why that is.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Flowy Operators</h4><a id=\"user-content-flowy-operators\" class=\"anchor\" aria-label=\"Permalink: Flowy Operators\" href=\"#flowy-operators\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">First of all, remember that Airstream guarantees no FRP glitches within a Transaction, and places the following limits on what observables can do in a transaction:</p>\n<ul dir=\"auto\">\n<li>No observable can emit more than once in a transaction.</li>\n<li>An observable can only emit in a transaction synchronously, in response to its parent observable emitting in the same transaction</li>\n</ul>\n<p dir=\"auto\"><strong>Basically, observables need to be expressible as <code>map</code> and/or <code>filter</code> to avoid the need for emitting events in a new transaction. We call such operators \"flowy\".</strong></p>\n<p dir=\"auto\">With such requirements, we can essentially forget about the concept of time within a transaction, and live in a beautiful world where all the observables are connected in a directed acyclic graph, and their updates propagate from the root(s) to the leaves of that graph.</p>\n<p dir=\"auto\">This is a very desirable feel, because it comes closest to imperative programming with plain values. Normally when working with observables we have to worry about glitches, delays, side effects, recursive updates, etc., but within a transaction, we have none of that.</p>\n<p dir=\"auto\">And so, we want to confine the propagation of each event to a single transaction, as much as possible. We do this by using <strong>\"flowy\"</strong> operators – these operators keep the flow going smoothly, and emit events in the same transaction as their input events, because they satisfy Airstream transaction guarantees:</p>\n<ul dir=\"auto\">\n<li>They emit events only in response to parent observable emitting events</li>\n<li>They emit at most one event per one input event</li>\n</ul>\n<p dir=\"auto\">The basic operators are all flowy: <code>map</code>, <code>filter</code>, <code>collect</code>, <code>take</code>, <code>drop</code>, etc.</p>\n<p dir=\"auto\">Even operators that convert streams to signals and back like <code>startWith</code> and <code>changes</code> are flowy, because aside from adding or removing the initial value, they are a mere <code>map(identity)</code> operator.</p>\n<p dir=\"auto\">In addition, in Airstream the operators that combine multiple observables are also flowy – <code>combineWith</code> / <code>withCurrentValueOf</code> / <code>sample</code> all have <code>map</code> + <code>filter</code> semantics, albeit relating to several input observables, and are implemented in a special way to remain flowy and avoid FRP glitches. Explanation of their exact mechanics is <a href=\"https://github.com/raquo/Airstream#frp-glitches\">here</a>.</p>\n<p dir=\"auto\">If you think real hard, you can imagine the <code>split</code> and <code>distinct</code> operators as (rather complicated) versions of <code>map</code> + <code>filter</code>, and so they too are flowy operators.</p>\n<p dir=\"auto\">The same goes for the <code>delaySync</code> operator, because it reorders / prioritizes events within a transaction, without introducing an async delay, and it only emits as many events as it receives.</p>\n<p dir=\"auto\">As you see, you can get pretty far with just flowy operators – you can map, filter, combine, and split observables in all sorts of ways. All other operators emit their events in a new transaction, and now we will see why, for each category.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Async Operators</h4><a id=\"user-content-async-operators\" class=\"anchor\" aria-label=\"Permalink: Async Operators\" href=\"#async-operators\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Flowy operators are by definition synchronous, because there can be no async delay within a transaction. Thus, all operators that emit after an async delay are not flowy, and must emit their events in a new transaction.</p>\n<p dir=\"auto\">This includes <code>EventStream.periodic</code>, <code>delay</code>, <code>throttle</code>, <code>debounce</code>, <code>fromFuture</code>, <code>fromJsPromise</code>.</p>\n<p dir=\"auto\">Can these operators cause FRP glitches? The answer is the same – did you <strong>need</strong> the delay, either for business logic reasons, or for technical reasons (e.g. making a network request)? If yes, then you will see no glitches.</p>\n<p dir=\"auto\">However, if you add <code>.delay(0)</code> to <code>doubledNumbers</code> in the <a href=\"https://github.com/raquo/Airstream#frp-glitches\">diamond glitch example</a> for no good reason, you would get glitch-like behaviour. I say \"no good reason\" because if you actually had a reason to do that, then the \"glitch\" wouldn't be a glitch, but would be your desired behaviour. I know this seems a bit hand-wavy, but when you actually run into such cases it's extremely obvious.</p>\n<p dir=\"auto\">When we combine two observables into one (e.g. using <code>combineWith</code>), and we expect a given event in both parent observables to happen \"at the same time\", we also expect the combined observable to emit only one combined event as a result. When something else happens instead (e.g. the observable emits two events), we call it a glitch. But, if one of your parent observables is asynchronous, e.g. it's making a network request for each of its input events, you don't expect its output to happen at the same time as the other parent, and so even though you technically get the exact same behaviour with the combined observable emitting two events, it's a not a glitch, that's now your expected outcome, due to the asynchrony involved.</p>\n<p dir=\"auto\">So, FRP glitches are expectation-vs-reality mismatches in behaviour. When you use async operators, you don't have expectations of events happening \"at the same time\", so the concept of glitches that we're used to in synchronous operators is not applicable.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Loopy Operators</h4><a id=\"user-content-loopy-operators\" class=\"anchor\" aria-label=\"Permalink: Loopy Operators\" href=\"#loopy-operators\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">When we earlier called the <code>flatMap</code> operator \"unnecessary\", we implied that it is more powerful, or perhaps somehow more expensive, than \"flowy\" operators that don't need to create a new transaction for every event they emit.</p>\n<p dir=\"auto\">And this is indeed the case. <code>flatMap</code> allows you to trivially violate the constraints of a transaction, for example you can emit more than one event per incoming event:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val intStream: EventStream[Int] = ???\nval flatIntStream: EventStream[Int] = intStream.flatMap { ev =&gt;\n  EventStream.fromSeq(List(ev + 1, ev + 2))\n}\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">intStream</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">flatIntStream</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> intStream.flatMap { ev <span class=\"pl-k\">=&gt;</span>\n  <span class=\"pl-en\">EventStream</span>.fromSeq(<span class=\"pl-en\">List</span>(ev <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>, ev <span class=\"pl-k\">+</span> <span class=\"pl-c1\">2</span>))\n}</pre></div>\n<p dir=\"auto\">Or create a loop in the observable graph, i.e. a stream that depends on itself:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val intStream: EventStream[Int] = ???\nval flatIntStream: EventStream[Int] = intStream.flatMap { ev =&gt;\n  flatIntStream.map(_ + 1)\n}\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">intStream</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">flatIntStream</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> intStream.flatMap { ev <span class=\"pl-k\">=&gt;</span>\n  flatIntStream.map(_ <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>)\n}</pre></div>\n<p dir=\"auto\">As we mentioned before, Airstream can only propagate events within a single transaction as long as we're walking down a direct acyclic graph of observables. \"acyclic\" means that such a graph must have no cycles in it, that is, no observable can depend on itself, whether directly or indirectly. Thus, <code>flatMap</code> can not possibly be a part of an acyclic graph, as it can depend on itself.</p>\n<p dir=\"auto\">Or, to be more precise, <code>flatMap</code> <strong>can</strong> be used without creating cycles / loops in the observable graph, but whether it is or isn't used that way in your program is <strong>not knowable</strong> in advance. Airstream calculates a static <a href=\"https://github.com/raquo/Airstream#topological-rank\">topological rank</a> for every observable at its creation time, and uses that to make <code>combineWith</code> and similar operators glitch-free. But the topological rank of a <code>flatMap</code> observable is not knowable at its creation time, because the observable it depends on can change dynamically based on what its parent observable emits.</p>\n<p dir=\"auto\">And so, every method and operator in Airstream that lets you feed events from an observable back into itself, has to emit its events in a new transaction. This includes the <code>flatMap</code> and <code>flatten</code> operators, but also every method used to update a Var or send an event into an EventBus, such as <code>Var.set</code>, <code>EventBus.emit</code>, etc.</p>\n<p dir=\"auto\"><strong>Bottom line:</strong> Avoid using loopy operators where they are not needed. Don't use <code>flatMap</code> if <code>combineWith</code> works just as well. Don't put state in a Var if you can just map over some signal to compute the same state.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Merge Streams Special Case</h4><a id=\"user-content-merge-streams-special-case\" class=\"anchor\" aria-label=\"Permalink: Merge Streams Special Case\" href=\"#merge-streams-special-case\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><code>stream1.mergeWith(stream2)</code> can behave either as a flowy operator or a loopy operator depending on which streams are being merged.</p>\n<p dir=\"auto\">If both streams never emit in the same transaction, the merged stream behaves as a flowy operator, avoiding FRP glitches as flowy operators do.</p>\n<p dir=\"auto\">However, if one of the parent streams synchronously depends on the other, e.g. if you do <code>stream1.mergeWith(stream1.map(_ * 10))</code>, you must expect one incoming event to produce two independent events with separate propagations because... how else could it possibly work in this case?</p>\n<p dir=\"auto\">And so, in such cases, when both of merged stream's parents emit in the same transaction, the merged stream emits the first event in the same transaction, but it emits the second event in a separate transaction, allowing it to propagate separately. This actually eliminates FRP glitches that could otherwise happen when using the <code>combineWith</code> operator on the output of <code>combineWith</code>.</p>\n<p dir=\"auto\">See also: <a href=\"#avoiding-glitches-when-merging\">Avoiding Glitches When Merging</a></p>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">Restarting Observables</h3><a id=\"user-content-restarting-observables\" class=\"anchor\" aria-label=\"Permalink: Restarting Observables\" href=\"#restarting-observables\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">This documentation section assumes a good understanding of all sections above, especially <a href=\"#signal\">Signals</a>, <a href=\"#laziness\">Laziness</a> and <a href=\"#transactions\">Transactions</a>.</p>\n<p dir=\"auto\">When an Airstream observable loses its last observer, it is stopped, and must detach itself from the rest of the observable graph, so that it can be garbage collected. Specifically, it must remove itself from the list of observers in its parent observable.</p>\n<p dir=\"auto\">Because of that, parent observables stopped observables are unable to receive updates from their parent observables, for example if <code>numSignal</code> continues to update while <code>fooSignal</code> is stopped (we assume that <code>numSignal</code> has other observers and is not stopped itself).</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val numSignal: Signal[Int] = ???\nval fooSignal: Signal[Foo] = numSignal.map(Foo(_))\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">numSignal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">fooSignal</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">Foo</span>] <span class=\"pl-k\">=</span> numSignal.map(<span class=\"pl-en\">Foo</span>(_))</pre></div>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Signals Re-Syncing on Restart</h4><a id=\"user-content-signals-re-syncing-on-restart\" class=\"anchor\" aria-label=\"Permalink: Signals Re-Syncing on Restart\" href=\"#signals-re-syncing-on-restart\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Now let's suppose that <code>fooSignal</code> is started again, after being stopped for a while: we add an observer to it, and <code>fooSignal</code> adds itself to <code>numSignal</code>'s observers, thus starting to receive its updates again. However, those updates have not come in yet (perhaps they only happen in response to user clicks), but as we already started the signal, we need to provide <code>fooSignal</code>'s current value to this new observer that we added, per Signal's contract. Unfortunately, <code>fooSignal</code>'s current value is actually stale, because it missed all of the updates in <code>numSignal</code> while <code>fooSignal</code> was stopped. To mitigate this inconsistency, when restarting, signals attempt to sync their value with the parent signal.</p>\n<p dir=\"auto\">In our case, when restarting, <code>fooSignal</code> will check whether its parent <code>numSignal</code> has emitted any updates while <code>fooSignal</code> was stopped, and if that is the case, then fooSignal will apply the <code>Foo(_)</code> function to update its current value to match <code>numSignal</code>'s latest value. All signals that have one parent signal do it this way (see <code>trait SingleParentSignal</code>).</p>\n<p dir=\"auto\">Different kinds of signals have slightly different re-syncing logic, but at the high level it is all the same – the signals recompute their own current value if the parent signal(s) have emitted any updates. This latter condition is very important, because you don't want to run the signal's computation more than once per incoming event. Not so much because of performance, but because Airstream guarantees shared execution, i.e. that an observable will only process any incoming event only once, regardless of whether it has 1 or 100 subscribers, and regardless of other factors. That way, users' computations and side effects get executed a predictable number of times, even if the users are not disciplined about separating side effects from pure computations. Forcing purity on users in a language that does not enforce purity goes against Airstream design goals.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Restarting Streams</h4><a id=\"user-content-restarting-streams\" class=\"anchor\" aria-label=\"Permalink: Restarting Streams\" href=\"#restarting-streams\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Unlike signals, streams do not have a \"current value\", so we generally can not sync a stream with its parent stream. For example, if <code>barStream</code> was stopped for a while, and then is started again, it will not emit any new events until <code>boolStream</code> emits a new event.</p>\n<p dir=\"auto\">This might sound like an unfortunate limitation, but it actually works just fine when you're using event streams for their intended purpose – to represent events. For example, if you're re-mounting a Laminar component, you probably don't want to suddenly receive a click event that happened a while ago. On the other hand, if you have compiled some <strong>state</strong> based on those click events, that state should already live in a Signal, and your component should be able to sync with it. For example:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val parentClickEvents: EventStream[dom.MouseEvent] = ???\nval state: Signal[State] = parentClickEvents.scanLeft((initialState, ev) =&gt; newState)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">parentClickEvents</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[dom.<span class=\"pl-en\">MouseEvent</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">state</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">State</span>] <span class=\"pl-k\">=</span> parentClickEvents.scanLeft((initialState, ev) <span class=\"pl-k\">=&gt;</span> newState)</pre></div>\n<p dir=\"auto\">Now, if the <code>state</code> signal lives in your parent Laminar component, and is never stopped, any signals in your child component can re-sync with it when they <em>are</em> stopped and then restarted (when the child component is unmounted and then re-mounted).</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Restarting Streams That Depend on Signals (signal.changes)</h4><a id=\"user-content-restarting-streams-that-depend-on-signals-signalchanges\" class=\"anchor\" aria-label=\"Permalink: Restarting Streams That Depend on Signals (signal.changes)\" href=\"#restarting-streams-that-depend-on-signals-signalchanges\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Airstream offers both state-like and stream-like observables under one roof, and integrating them smoothly in one system is profoundly hard. Consider the case of <code>signal.changes</code> – this is a stream that emits all events that the signal emits, except for its initial value.</p>\n<p dir=\"auto\">What happens when <code>signal.changes</code> is stopped and then restarted, but <code>signal</code> itself is never stopped, continuing to emit new updates? On the surface, the answer is simple – <code>signal</code> keeps track of its current value, so when restarting the <code>signal.changes</code> stream, we just do the same thing as we do when restarting signals that depend on other signals – check if the parent <code>signal</code> has emitted while <code>signal.changes</code> was stopped, and if so, update the current value of <code>signal.changes</code>. That would be the desirable behaviour.</p>\n<p dir=\"auto\">However... <code>signal.changes</code> is a stream, not a signal, so it does not have a \"current value\" that can be updated, nor a mechanism by which a new observer could pull its updated value. As an event stream, the only thing <code>signal.changes</code> can do is emit the <code>signal</code>'s updated value as a new event, and under normal circumstances that's exactly what it would do, but restarting of a stream is not exactly a \"normal circumstance\", it is a special moment in its lifetime.</p>\n<p dir=\"auto\">Specifically, when a stream is getting started, we don't really have access to the current / ongoing transaction, and we don't know how far the transaction has already propagated, so I don't think <code>signal.changes</code> can safely emit the signal's updated value in the current transaction when <code>signal.changes</code> is restarting. That does not seem safe, although I haven't quite proved it definitively to myself if I'm being honest. There could be room for improvement here.</p>\n<p dir=\"auto\">The naive alternative then would be for <code>signal.changes</code> to emit the signal's updated value in a new transaction when <code>signal.changes</code> is being restarted. However, that is problematic: what if you add not one, but two observers to <code>signal.changes</code> at the same time? The first observer would trigger the restart of this stream, and would cause <code>signal.changes</code> to emit the new event in a new transaction, but then the second new observer would not receive that event, because it already missed it. This difference in behaviour is obviously undesirable, but that's not even the end of it.</p>\n<p dir=\"auto\">If instead of adding two observers to <code>signal.changes</code>, we add one observer to <code>signal.changes</code> and another one to <code>signal.map(foo).changes</code> at the same time (while they are both stopped), then those streams would emit the new event different transactions, which would never happen under normal circumstances. This could have caused an FRP glitch when restarting these streams like that if we <code>combineWith</code> them somewhere downstream.</p>\n<p dir=\"auto\">To avoid all this, we have a special mechanism that lets us batch simultaneous events in a new transaction when restarting observables. Currently, it's only used to restart <code>signal.changes</code>. Basically, to avoid this restarting glitch, you want to wrap all your simultaneous observer additions into <code>Transaction.onStart.shared { /* code here */ }</code>, so any <code>signal.changes</code> you restart within that block will all emit in the same transaction. This is also not a perfect match for \"normal\" Airstream behaviour, and could potentially cause the other kind of FRP glitch where an intermediary event that you do expect to happen is swallowed by the system instead. However, of the two evils I think this is a lesser one, because it's much less common for that to be a problem. Ideally I would like to find a more robust mechanism for this edge case, but currently I lack the time required to do the research.</p>\n<p dir=\"auto\">Airstream's <code>DynamicOwner</code> uses this <code>onStart.shared</code> mechanism when activating all of its subscriptions, and all Laminar's methods like <code>amend</code> do the same when applying multiple modifiers at a time, so you really shouldn't ever need to use <code>onStart.shared</code> manually, unless you're an advanced user creating your own custom modifiers or ownership primitives.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Restarting Signals That Depend on Streams</h4><a id=\"user-content-restarting-signals-that-depend-on-streams\" class=\"anchor\" aria-label=\"Permalink: Restarting Signals That Depend on Streams\" href=\"#restarting-signals-that-depend-on-streams\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">As event streams have no concept of \"current value\" and don't remember their \"last emitted event\", a signal that depends on a stream can not sync its value with the parent stream when it's being restarted, it simply starts listening to the parent stream again, and the signal's current value remains (potentially) stale until the parent stream emits a new event.</p>\n<p dir=\"auto\">Of course, if you want signals like <code>stream.scanLeft(intial)((acc, ev) =&gt; ???)</code> to keep receiving events from <code>stream</code>, you need to prevent them from getting stopped. In Laminar, this is usually accomplished by either choosing a better owner for the signal (e.g. move it to the parent component that does not get unmounted), or by hiding the owner element with CSS (<code>display: none</code>) instead of unmounting it.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Stopping is Actually Pausing</h4><a id=\"user-content-stopping-is-actually-pausing\" class=\"anchor\" aria-label=\"Permalink: Stopping is Actually Pausing\" href=\"#stopping-is-actually-pausing\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Starting with Airstream 15, Airstream's general paradigm is to \"pause\" the observables when they are stopped, and seamlessly \"resume\" them when they are restarted, instead of tearing them down on stop, and restarting them from scratch. That is, when an observable is stopped and then re-started, it now tries to retain its internal state. This applies to streams too. Even though they generally do not represent \"state\" (that's what signals are for), streams still have internal state that they manage. For example:</p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\"><code>stream.take(numEvents = 2)</code> internally remembers how many events it took from <code>stream</code>, so if <code>stream</code> emits 3 events, and then is stopped and re-started, the <code>take</code> stream will not emit any more events if <code>stream</code> continues to emit, because it already took <code>2</code> events. This can be overriden by passing <code>resetOnStop = true</code> to the <code>take</code> operator.</p>\n</li>\n<li>\n<p dir=\"auto\"><code>stream1.combineWith(stream2)</code> internally remembers the last event(s) that it saw <code>stream1</code> and <code>stream2</code> emit even after it was stopped. That way, when the combined stream is restarted, it behaves as if it was never stopped (sort of), instead of behaving as if we were starting it for the first time (i.e. waiting for both <code>stream1</code> and <code>stream2</code> to emit).</p>\n</li>\n</ul>\n<p dir=\"auto\">As we've established before, signals even sync their value with their parent signal when they're being restarted, following the same paradigm of pausing and unpausing.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Signals That Keep Updating When Stopped</h4><a id=\"user-content-signals-that-keep-updating-when-stopped\" class=\"anchor\" aria-label=\"Permalink: Signals That Keep Updating When Stopped\" href=\"#signals-that-keep-updating-when-stopped\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Generally, signals do not update their current value while they are stopped because they get disconnected from the source of updates, but there are several exceptions to this:</p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\"><strong>Signals that have never been started</strong> – their initial value might not be determined yet, for example if you have <code>stream.toSignal(initial = foo)</code>, the <code>foo</code> initial value will not be evaluated until the signal is started. Until then, the signal's current value is unknown, and Airstream will not evaluate it until and unless the signal is started.</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>Future / Promise signals</strong> – the current value of <code>Signal.fromFuture(future)</code> and <code>Signal.fromJsPromise(promise)</code> mirrors the current value of the future / promise regardless of whether the signal is started.</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>Var signals</strong> – the current value of <code>Var.signal</code> mirrors the current value of the future / promise regardless of whether the signal is started.</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>Custom signals</strong> – signals made using <code>CustomSource</code> API or by extending the <code>WritableSignal</code> trait might behave in whatever way makes sense for them. Remember that if a signal is stopped, it has no observers, so instead of spending resources on keeping the signal's value up to date while it is stopped, you might want to update its value once when the signal is restarting, in its <code>onWillStart</code> method.</p>\n</li>\n</ul>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">Debugging</h3><a id=\"user-content-debugging\" class=\"anchor\" aria-label=\"Permalink: Debugging\" href=\"#debugging\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Debugging Observables</h4><a id=\"user-content-debugging-observables\" class=\"anchor\" aria-label=\"Permalink: Debugging Observables\" href=\"#debugging-observables\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val stream: EventStream[Int] = ???\nval useJsLogger: Boolean = false\n\nval debugStream = stream\n  .debugWithName(&quot;MyStream&quot;) // optional: use this prefix when logging below\n  .debugLogEvents(when = _ &lt; 0, useJsLogger) // optional: only log negative numbers\n  .debugSpyStarts(topoRank =&gt; ???)\n  .debugBreakErrors()\n\n// Before:\nstream.addObserver(obs)\n\n// After: when debugging, replace with:\ndebugStream.addObserver(obs)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">stream</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">useJsLogger</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Boolean</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">false</span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">debugStream</span> <span class=\"pl-k\">=</span> stream\n  .debugWithName(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>MyStream<span class=\"pl-pds\">\"</span></span>) <span class=\"pl-c\"><span class=\"pl-c\">//</span> optional: use this prefix when logging below</span>\n  .debugLogEvents(when <span class=\"pl-k\">=</span> _ <span class=\"pl-k\">&lt;</span> <span class=\"pl-c1\">0</span>, useJsLogger) <span class=\"pl-c\"><span class=\"pl-c\">//</span> optional: only log negative numbers</span>\n  .debugSpyStarts(topoRank <span class=\"pl-k\">=&gt;</span> <span class=\"pl-k\">???</span>)\n  .debugBreakErrors()\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Before:</span>\nstream.addObserver(obs)\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> After: when debugging, replace with:</span>\ndebugStream.addObserver(obs)</pre></div>\n<p dir=\"auto\">Airstream offers many debugging operators for observables, letting you run a callbacks (<code>debugSpy*</code>), log (<code>debugLog*</code>), or set a JS breakpoint (<code>debugBreak*</code>) at the most important times in the observable's lifecycle, including when emitting events or errors, starting or stopping, and evaluating the initial value (for signals). Those methods are available implicitly on every observable via <code>DebuggableObservable</code> and <code>DebuggableSignal</code>.</p>\n<p dir=\"auto\">To debug an observable, call one of the available debug* methods to produce a new observable that listens to the original one, and re-emits all its events and errors, <strong>and</strong> also performs the specified debug action.</p>\n<p dir=\"auto\">For example, <code>stream.debugLog()</code> will create a new observable that will simply print every event <strong>and error</strong> that it emits, that <code>stream</code> feeds to it, and <code>stream.debugLog().debugBreakErrors()</code> will do the same plus also set a JS breakpoint on errors in <code>stream</code>.</p>\n<p dir=\"auto\">Very importantly, <code>debugLog</code> does <strong>not</strong> monkey-patch the original observable to add debugging functionality to it. We create a new observable that depends on the original, and debug <em>that</em>. This is true for every debug operator: in <code>stream.debugLog().debugBreakErrors()</code>, <code>debugLog()</code> creates an observable based on <code>stream</code>, and <code>debugBreakErrors()</code> creates an observable based on <code>stream.debugLog()</code>.</p>\n<p dir=\"auto\">To make it crystal clear: <code>stream.debugLog()</code> will only log the events that <code>stream.debugLog()</code> emits, so you need to make sure to listen to it instead of listening to <code>stream</code>. Easiest is to just use <code>stream.debugLog()</code> in place of the original <code>stream</code> in your code.</p>\n<p dir=\"auto\">Another important consideration is the <strong>order</strong> of debug procedures. It follows the propagation order. For example, in <code>stream.debugLog().debugSpy(fn)</code> the observable <code>stream.debugLog()</code> will obviously emit before the observable <code>stream.debugLog().debugSpy(fn)</code> emits, and so you will see the event printed first, and only after that will <code>fn</code> be called with that event. So if you're ever confused about why your debugger prints stuff in a weird order (e.g. event fired before stream is started), make sure your debug operators are in the expected order.</p>\n<p dir=\"auto\">You can also use <code>debugWith(debugger)</code> method instead of <code>debug*</code> methods to provide an <code>ObservableDebugger</code> with all of the behaviour that you want, instead of adding it piece by piece.</p>\n<p dir=\"auto\">Also regarding timing, the per-event debuggers like (<code>debugSpy()</code> / <code>debugLog()</code> / <code>debugBreak()</code>) do their thing right <em>before</em> the event is fired (by the debugged observable, not the original), and the start/stop debuggers do their thing right <em>after</em> the observable is started or stopped.</p>\n<p dir=\"auto\"><strong>Note for signals:</strong> Any <code>debug*</code> method that triggers when the signal emits an event or an error will also trigger when the signal is <strong>started</strong>. This ensures that you won't miss the signal's initial value when debugging, even though the Signal's initial value technically isn't ever \"emitted\", in Airstream terms.</p>\n<p dir=\"auto\">Logging debug operators generally offer an optional <code>when</code> filter to reduce noise, and a <code>useJsLogger</code> option that you should enable when you're logging native JS values. Logging plain JS objects with <code>println</code> will often result in printing <code>[object Object]</code>, but JS <code>dom.console.log</code> can print them nicely.</p>\n<p dir=\"auto\">Also, your logs will be prefixed with <code>sourceName</code> which defaults to <code>stream.toString</code> but you can provide a prettier name as a param to the <code>.debug()</code> method.</p>\n<p dir=\"auto\">We try to minimize the impact of debugging on the execution of your observable graph. To that end, any errors you throw in the callbacks you provide to <code>debugSpy*</code> methods will be reported as unhandled (wrapped in <code>DebuggerError</code>), and will not affect the propagation of events.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">displayName</h5><a id=\"user-content-displayname\" class=\"anchor\" aria-label=\"Permalink: displayName\" href=\"#displayname\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">When debugging, it's very useful to name your observables. There are two ways to do this: <code>stream.setDisplayName(\"MyStream\")</code> patches <code>stream</code> in place to set its <code>displayName</code>. It returns the same <code>stream</code>, it does <strong>not</strong> create a new observable.</p>\n<p dir=\"auto\">This should be the preferred method for adding <strong>permanent</strong> names to important observables. For example, if you have a global <code>val AuthSignal: Signal[AuthContext]</code>, you might want to add <code>.setDisplayName(\"AuthSignal\")</code> to its definition.</p>\n<p dir=\"auto\"><code>displayName</code>, if explicitly set, is returned by the observable's <code>toString</code> method. If not explicitly set, it defaults to <code>defaultDisplayName</code>, which in turn defaults to java.Object's default <code>type@hashcode</code> toString implementation. If subclassing Observable, you can't override its toString method directly, but you can override <code>defaultDisplayName</code>.</p>\n<p dir=\"auto\"><code>displayName</code> is of course useful to give human-readable identifiers to observables – seeing <code>AuthSignal</code> when print-debugging is much more useful than <code>MapSignal@f161</code>.</p>\n<p dir=\"auto\"><code>displayName</code> is also prepended to logs produced by <code>debugLog*</code> methods. However, given <code>stream.setDisplayName(\"MyStream\")</code>, while the <code>displayName</code> of <code>stream</code> is \"MyStream\", the <code>displayName</code> of <code>stream.setDisplayName(\"MyStream\").debugLog()</code> is \"MyStream|Debug\", to differentiate it from <code>stream</code>.</p>\n<p dir=\"auto\">You can of course also <code>setDisplayName</code> on the debugged stream directly: <code>stream.debugLog().setDisplayName(\"MyDebuggedStream\")</code>, but if you have a <em>chain</em> of debug streams that you want to apply the same name to, you can use the <code>withDisplayName</code> method: <code>stream.withDisplayName(\"MyDisplayName\").debugLogEvents().debugSpyErrors().debugLogStarts()</code> – in this case all three debug* streams will have their <code>displayName</code> set to \"MyDisplayName\", but <code>stream</code> will not. This is because unlike <code>setDisplayName</code>, <code>withDisplayName</code> does not patch the original observable, it creates a new debug observable and patches that instead. <code>withDisplayName</code> works with debug chains because unlike regular observables, debug observables inherit their parent debug observable's <code>displayName</code> by default.</p>\n<p dir=\"auto\">Airstream does not require <code>displayName</code> to be unique, although if you want to keep your sanity, it should be descriptive enough to clearly tell you which instance it refers to.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">debugTopoRank</h5><a id=\"user-content-debugtoporank\" class=\"anchor\" aria-label=\"Permalink: debugTopoRank\" href=\"#debugtoporank\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><a href=\"#topological-rank\">Topological Ranks</a> of observables determine the order of Airstream observable graph propagation. The new observables created using <code>debug*</code> operators will necessarily have different <code>topoRank</code>-s from the original observables. Due to (mostly) depth-first propagation in Airstream, debugging observables generally don't affect your graph's propagation, but if you're specifically debugging an issue related to topoRanks, you might want to avoid adding temporary observables to your observable graph.</p>\n<p dir=\"auto\">You can check the <code>topoRank</code> of an observable using <code>observable.debugTopoRank</code>. Unlike other <code>debug*</code> operators, this one does not affect the observable or create new observables, it just returns the observable's topoRank.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Debugging Observers</h4><a id=\"user-content-debugging-observers\" class=\"anchor\" aria-label=\"Permalink: Debugging Observers\" href=\"#debugging-observers\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val stream: EventStream[Int] = ???\nval obs: Observer[Int] = ???\n\nval debuggedObs = obs\n  .debugWithName(&quot;MyObserver&quot;)\n  .debugLog()\n  .debugSpyErrors(err =&gt; ???)\n\n// Before:\nstream.addObserver(obs)\n\n// After: when debugging, replace with:\nstream.addObserver(debuggedObs)\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">stream</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">obs</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Observer</span>[<span class=\"pl-en\">Int</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">debuggedObs</span> <span class=\"pl-k\">=</span> obs\n  .debugWithName(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>MyObserver<span class=\"pl-pds\">\"</span></span>)\n  .debugLog()\n  .debugSpyErrors(err <span class=\"pl-k\">=&gt;</span> <span class=\"pl-k\">???</span>)\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Before:</span>\nstream.addObserver(obs)\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> After: when debugging, replace with:</span>\nstream.addObserver(debuggedObs)</pre></div>\n<p dir=\"auto\">Observers have debugging functionality very similar to observables, but it works slightly differently. Whereas adding debuggers to observables is similar to mapping them, adding debuggers to observers is similar to <strong>contra</strong>mapping them.</p>\n<p dir=\"auto\">Just as in typical contramapping, the order of execution is reversed, so in the example above <code>debugSpyErrors()</code> callback will run before the error is logged by <code>log()</code>, and all the debugging happens before the original observer runs.</p>\n<p dir=\"auto\">Similarly to debugged observables, your debuggers throwing do not affect the execution of the observable graph, instead they result in an unhandled <code>DebuggerError</code> being reported.</p>\n<p dir=\"auto\">Just like observables, observers can be named using <code>setDisplayName</code> and <code>debugWithName</code>, with similar semantics. Note that even though observers are executed in \"reverse\" order (contramap semantics), debugged observers inherit <code>displayName</code> from their parent, so the <code>displayName</code> of all debugged observers in <code>obs.debugWithName(\"MyObserver\").debugLog().debugSpy(???)</code> is \"MyObserver\".</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h3 class=\"heading-element\" dir=\"auto\">Error Handling</h3><a id=\"user-content-error-handling\" class=\"anchor\" aria-label=\"Permalink: Error Handling\" href=\"#error-handling\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Airstream error handling is very different from conventional streaming libraries. Before diving into implementation details we first need to understand these differences and the reasons why such a departure from the norm is beneficial.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Scala Exception Handling</h4><a id=\"user-content-scala-exception-handling\" class=\"anchor\" aria-label=\"Permalink: Scala Exception Handling\" href=\"#scala-exception-handling\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">First, to clarify what kind of errors we're talking about here: this whole section is concerned with exceptions thrown by <em>user-provided</em> code inside Airstream observables. For example, consider the case of the <code>project</code> function in <code>stream.map(project)</code> throwing. Without special error handling capabilities in Airstream, such an exception would terminate the propagation of this stream and bubble up the call stack.</p>\n<p dir=\"auto\">However, this behaviour is vastly undesirable in FRP context because the caller (which would be the source of events) is not normally in a position to handle failures of child observables. For example, a DOM event listener that publishes DOM events onto a stream can't do much about some other component failing to process some of those events. So we need a different strategy to deal with errors in observables.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Conventional Streaming Libraries</h4><a id=\"user-content-conventional-streaming-libraries\" class=\"anchor\" aria-label=\"Permalink: Conventional Streaming Libraries\" href=\"#conventional-streaming-libraries\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Conventional streaming libraries basically don't propagate errors in observables. If your stream fails, it gets <em>completed</em>, meaning that it informs all of its dependant observables and observers that it errored, and will no longer produce events, and is now shutting down forever.</p>\n<p dir=\"auto\">If you don't want this outcome, you need to <em>recover</em> from such an error by creating a stream that takes two inputs: this original stream, and a stream factory that returns a new stream that you will switch to if the original stream errors.</p>\n<p dir=\"auto\">This model does not make any sense to me. Consider this chain of observables:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"object OtherModule {\n  def doubled(parentStream: EventStream[Double]): EventStream[Double] = {\n    parentStream.map(num =&gt; num * 2)\n  }\n}\n \n// ----\n \nimport OtherModule.doubled\n \nval stream1: EventStream[Double] = ???\nval invertedStream: EventStream[Double] = stream1.map(num =&gt; 1 / num)\n \ndoubled(invertedStream).foreach(dom.console.log(_))\"><pre><span class=\"pl-k\">object</span> <span class=\"pl-en\">OtherModule</span> {\n  <span class=\"pl-k\">def</span> <span class=\"pl-en\">doubled</span>(<span class=\"pl-v\">parentStream</span>: <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Double</span>])<span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Double</span>] <span class=\"pl-k\">=</span> {\n    parentStream.map(num <span class=\"pl-k\">=&gt;</span> num <span class=\"pl-k\">*</span> <span class=\"pl-c1\">2</span>)\n  }\n}\n \n<span class=\"pl-c\"><span class=\"pl-c\">//</span> ----</span>\n \n<span class=\"pl-k\">import</span> <span class=\"pl-en\">OtherModule</span>.<span class=\"pl-en\">doubled</span>\n \n<span class=\"pl-k\">val</span> <span class=\"pl-v\">stream1</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Double</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">invertedStream</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">EventStream</span>[<span class=\"pl-en\">Double</span>] <span class=\"pl-k\">=</span> stream1.map(num <span class=\"pl-k\">=&gt;</span> <span class=\"pl-c1\">1</span> <span class=\"pl-k\">/</span> num)\n \ndoubled(invertedStream).foreach(dom.console.log(_))</pre></div>\n<p dir=\"auto\">Inside <code>doubled</code>, there is nothing you can do to recover from an error in <code>parentStream</code>. You don't know what that stream does, so once it's broke, it's broke. You can't replace it with anything meaningful, just maybe some sentinel value to indicate failure.</p>\n<p dir=\"auto\">So essentially, this requires you to either manually guard every single user-provided input to every stream, or lose your sanity to crazy amounts of coupling. In this scenario the more likely outcome is that you'll just ignore error handling, and your program will stop working on an error that would have been recoverable if only it wasn't in your streaming code.</p>\n<p dir=\"auto\">Fundamentally, the problem here is conceptual: conventional streaming libraries see any exception in a stream as a terminal diagnosis for it.</p>\n<p dir=\"auto\">Yes, such an error could have made parts of your application state inconsistent, that is a legitimate problem. However, unconditionally killing parts of your program that depend on a stream is not a way to mitigate inconsistent state for the simple reason that <em>the streaming library has no idea which, if any, state became inconsistent</em>, therefore it has no idea whether allowing the error to propagate will <em>mitigate</em> state breakage or make it <em>even worse</em>.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Airstream's Approach</h4><a id=\"user-content-airstreams-approach\" class=\"anchor\" aria-label=\"Permalink: Airstream's Approach\" href=\"#airstreams-approach\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Airstream aspires to replicate the feel of native exception handling in FRP. However, whereas in imperative code we typically want to propagate exceptions up the call stack, in Airstream we instead want to propagate errors in observables to their observers and dependent observables.</p>\n<p dir=\"auto\">Think about it this way: in imperative code, you call a function which can throw, and you can either handle the error or decide to let your caller handle it, and so on, recursively. In Airstream, you make an observable that depends on another observable which can \"throw\". So you can either handle the error, or let any downstream observables or observers handle it.</p>\n<p dir=\"auto\">This FRP adaptation of classic exception handling is somewhat similar to the approach of Scala.rx, however since Airstream offers a unified reactive system, we have to adjust this basic idea to support event streams as well.</p>\n<p dir=\"auto\">To contrast our approach with conventional streaming libraries: where they see a failed <em>stream</em>, we only see a failed <em>value</em>, generally expecting the next emitted value to work fine. This is similar to plain Scala exceptions: if a function throws an exception, it does not suddenly become broken forever. You can call it again with perhaps a different value, and it will perhaps not fail that time. Yes, if such an exception produces invalid state, you as a programmer need to address it. Same in Airstream. We give you the tools (more on this below), you do the work, because you're the only one who knows <em>how</em>.</p>\n<p dir=\"auto\">We elaborate on the call stack analogy in the subsection <a href=\"#errors-multiply\">Errors Multiply</a> below.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Error Propagation</h4><a id=\"user-content-error-propagation\" class=\"anchor\" aria-label=\"Permalink: Error Propagation\" href=\"#error-propagation\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Airstream does not complete or terminate observables on error. Instead, we essentially propagate error values the same way we propagate normal values. Each Observer and InternalObserver has <code>onNext(A)</code> and <code>onError(Throwable)</code> methods defined, so both observables and observers are capable of accepting error values as inputs.</p>\n<p dir=\"auto\">If you do not take special action, Airstream observables will generally (but not always, we'll get to that) pass through the errors to their observers untouched. Eventually the error will reach one or more external Observers.</p>\n<p dir=\"auto\">When an error reaches an external observer, its <code>onError</code> method will handle it. If you didn't specify <code>onError</code> (e.g. if you used the <code>Observer(onNext)</code> factory to create an observer) or if your <code>onError</code> partial function is not defined for a given error, Airstream will report this error as <em>unhandled</em>.</p>\n<p dir=\"auto\">You can get notified about unhandled errors by registering a callback using <code>AirstreamError.registerUnhandledErrorCallback(fn: Throwable =&gt; Unit)</code>. Similarly, you can unregister it using <code>AirstreamError.unregisterUnhandledErrorCallback(fn: Throwable =&gt; Unit)</code>.</p>\n<p dir=\"auto\">By default Airstream registers <code>AirstreamErrors.consoleErrorCallback</code> to log all errors to the console because there is nothing worse than silently swallowed unhandled errors. You can unregister it and/or register more callbacks, e.g. to terminate your program, or to report the error to a service like Sentry.</p>\n<p dir=\"auto\">Now let's dive deeper into each step of this process.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">User Input is Generally Guarded Against Exceptions</h5><a id=\"user-content-user-input-is-generally-guarded-against-exceptions\" class=\"anchor\" aria-label=\"Permalink: User Input is Generally Guarded Against Exceptions\" href=\"#user-input-is-generally-guarded-against-exceptions\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Airstream guards from exceptions almost all user (developer) inputs that are used to build observables. For example, if the <code>project</code> function that you provided to <code>stream.map(project)</code> throws an exception, the resulting stream will emit an error, kick-starting this whole error handling process.</p>\n<p dir=\"auto\">However, user inputs that are supposed to return a <code>Try</code> are assumed to not throw. Various public class constructors that require the <code>new</code> keyword are generally not intended to be used directly, these can also have params that are not guarded against exceptions.</p>\n<p dir=\"auto\">For clarity, every Airstream method and constructor available to you has a Scaladoc comment reaffirming whether its parameters are guarded or not.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Errors Do Not Affect Propagation</h5><a id=\"user-content-errors-do-not-affect-propagation\" class=\"anchor\" aria-label=\"Permalink: Errors Do Not Affect Propagation\" href=\"#errors-do-not-affect-propagation\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">When an error happens in an observable (assuming that it was guarded against, as it should always be, see above), the observable emits this error to all of its observers – internal and external – in the same manner that it would emit a value. Think of it as propagating a <code>Try[A]</code> value instead of just <code>A</code>.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Errors in an Observer Do Not Affect Other Observers</h5><a id=\"user-content-errors-in-an-observer-do-not-affect-other-observers\" class=\"anchor\" aria-label=\"Permalink: Errors in an Observer Do Not Affect Other Observers\" href=\"#errors-in-an-observer-do-not-affect-other-observers\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Similarly, and unlike conventional streaming libraries, if an error happened in an observer's <code>onNext</code> or <code>onError</code> callback, this error will be reported as <em>unhandled</em>, but it will not prevent other observers or the code immediately following this observer's definition from running.</p>\n<p dir=\"auto\">If you're concerned that the contents of your <code>onNext</code> / <code>onError</code> can fail and make your app state inconsistent, you do the same thing you've always done in this situation – <code>try</code> some code and <code>catch</code> the error, just keep it all inside the callback in question:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"stream.addObserver(Observer(onNext = v =&gt;\n  try { riskyFoo(v) }\n  catch { case err =&gt; recoverFromFooFail() }\n))\"><pre>stream.addObserver(<span class=\"pl-en\">Observer</span>(onNext <span class=\"pl-k\">=</span> v <span class=\"pl-k\">=&gt;</span>\n  <span class=\"pl-k\">try</span> { riskyFoo(v) }\n  <span class=\"pl-k\">catch</span> { <span class=\"pl-k\">case</span> err <span class=\"pl-k\">=&gt;</span> recoverFromFooFail() }\n))</pre></div>\n<p dir=\"auto\">Remember, this is just for observers. We have a better way for observables, read on.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Unhandled Errors Do Not Terminate The Program</h5><a id=\"user-content-unhandled-errors-do-not-terminate-the-program\" class=\"anchor\" aria-label=\"Permalink: Unhandled Errors Do Not Terminate The Program\" href=\"#unhandled-errors-do-not-terminate-the-program\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">In Airstream, unhandled errors do not result in the program terminating. By default they are reported to the console. You can specify different or additional handlers such as <code>AirstreamError.debuggerErrorCallback</code> or even a custom handler that effectively terminates your program.</p>\n<p dir=\"auto\">Regardless of this seeming leniency, you should still handle all of your errors at some point before they become <em>unhandled</em>. In a good Airstream codebase every <em>unhandled</em> error must be treated as a bug.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Error Timing is Consistent</h5><a id=\"user-content-error-timing-is-consistent\" class=\"anchor\" aria-label=\"Permalink: Error Timing is Consistent\" href=\"#error-timing-is-consistent\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Observables generally emit errors at the same time as they would have emitted a non-error value. For example, a <code>CombinedObservable</code> like <code>stream.combineWith(stream.map(foo))</code> will only emit a single value if <code>stream</code> emits a value (yes, Airstream deals with <a href=\"#frp-glitches\">FRP Glitches</a> for you). Similarly, it will only emit a single error if <code>stream</code> emits an error. However, that error will be wrapped in <code>CombinedError</code> because it needs to support the case when its parent observables simultaneously emit a different error.</p>\n<p dir=\"auto\">On the other hand, <code>MergeStream</code> does no such error combination, it emits the errors similarly to how it emits non-error events – as they come, putting all but the first seen one in a new transaction.</p>\n<p dir=\"auto\"><code>DelayEventStream</code> re-emits incoming errors with the same delay that it uses for normal values.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Event Streams Generally Forget Errors</h5><a id=\"user-content-event-streams-generally-forget-errors\" class=\"anchor\" aria-label=\"Permalink: Event Streams Generally Forget Errors\" href=\"#event-streams-generally-forget-errors\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Similarly to how event streams generally do not keep track of their last emitted value, they also forget their last emitted error once they finish propagating it to their observers.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Signals Remember Errors</h5><a id=\"user-content-signals-remember-errors\" class=\"anchor\" aria-label=\"Permalink: Signals Remember Errors\" href=\"#signals-remember-errors\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">If a <code>Signal[A]</code> observable runs into an error that it doesn't handle itself, this error becomes its current state. <code>Signal</code>s' current state is actually <code>Try[A]</code>, not just <code>A</code>.</p>\n<p dir=\"auto\"><code>StrictSignal[A]</code> has a public <code>now(): A</code> method that returns its current value. Calling it is equivalent to <code>tryNow().get</code>– it will throw if current state is a Failure.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Errors Can Become Wrapped</h5><a id=\"user-content-errors-can-become-wrapped\" class=\"anchor\" aria-label=\"Permalink: Errors Can Become Wrapped\" href=\"#errors-can-become-wrapped\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Errors originating in observables error handling code (e.g. the <code>pf</code> in <code>stream.recover(pf)</code>) are wrapped in <code>ErrorHandlingError</code>.</p>\n<p dir=\"auto\">In Observers created using Airstream-provided constructors:</p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">If the user-provided observer callback (e.g. the <code>handleError</code> in <code>Observer.withRecover[Int](cb, handleError)</code>) throws while processing an incoming error, the error is wrapped into <code>ObserverErrorHandlingError</code> and sent off as unhandled error.</p>\n</li>\n<li>\n<p dir=\"auto\">If <code>handleObserverErrors</code> constructor param is <code>true</code> (that's the default), and the user-provided observer callback throws while processing an incoming event (as opposed to an incoming error), the error is wrapped in <code>ObserverError</code> and sent to this same observer's onError method. So, such an observer has a chance to process its own failure. The usefulness of that lies mostly in being able to automatically pass this error up the chain of observers.</p>\n<p dir=\"auto\">For example:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val sourceObs = Observer.fromTry[Int](println)\nval derivedObs = sourceObs.contramap[Int] { value =&gt;\n  if (value &gt;= 0) 1 else throw new Exception(&quot;negative!&quot;)\n}\nderivedObs.onNext(1) // prints &quot;Success(1)&quot;\nderivedObs.onNext(-1) // prints &quot;Failure(ObserverError: java.lang.Exception: negative!)&quot;\n// no errors are sent into unhandled because `println` is a total function, it handles them all.\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">sourceObs</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">Observer</span>.fromTry[<span class=\"pl-en\">Int</span>](println)\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">derivedObs</span> <span class=\"pl-k\">=</span> sourceObs.contramap[<span class=\"pl-en\">Int</span>] { value <span class=\"pl-k\">=&gt;</span>\n  <span class=\"pl-k\">if</span> (value <span class=\"pl-k\">&gt;=</span> <span class=\"pl-c1\">0</span>) <span class=\"pl-c1\">1</span> <span class=\"pl-k\">else</span> <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-en\">Exception</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>negative!<span class=\"pl-pds\">\"</span></span>)\n}\nderivedObs.onNext(<span class=\"pl-c1\">1</span>) <span class=\"pl-c\"><span class=\"pl-c\">//</span> prints \"Success(1)\"</span>\nderivedObs.onNext(<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>) <span class=\"pl-c\"><span class=\"pl-c\">//</span> prints \"Failure(ObserverError: java.lang.Exception: negative!)\"</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> no errors are sent into unhandled because `println` is a total function, it handles them all.</span></pre></div>\n</li>\n</ul>\n<p dir=\"auto\">You can always access the original errors on wrapped errors, and it will always provide you with a stack trace that includes the line where your code failed. Make sure to configure error reporting as well as Scala.js source maps to make use of this in fullOpt / production.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h5 class=\"heading-element\" dir=\"auto\">Errors Multiply</h5><a id=\"user-content-errors-multiply\" class=\"anchor\" aria-label=\"Permalink: Errors Multiply\" href=\"#errors-multiply\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">The same error might need to be handled multiple times to avoid becoming <em>unhandled</em>.</p>\n<p dir=\"auto\">It is perhaps counter-intuitive, but it's obvious in retrospect:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val upStream = ???\nval fooStream = upStream.map(foo)\nval barStream = upStream.map(bar)\nfooStream.foreach(dom.console.log(&quot;foo&quot;))\nbarStream.foreach(dom.console.log(&quot;bar&quot;))\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">upStream</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">fooStream</span> <span class=\"pl-k\">=</span> upStream.map(foo)\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">barStream</span> <span class=\"pl-k\">=</span> upStream.map(bar)\nfooStream.foreach(dom.console.log(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>foo<span class=\"pl-pds\">\"</span></span>))\nbarStream.foreach(dom.console.log(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>bar<span class=\"pl-pds\">\"</span></span>))</pre></div>\n<p dir=\"auto\">If <code>upStream</code> emits an error, both <code>fooStream</code> and <code>barStream</code> will emit an error – the same instance of it, actually. Then it will end up reported as <em>unhandled</em> – twice!</p>\n<p dir=\"auto\">If we try to lean on our call stack analogy, it kinda breaks this time. Call stack is a stack, a linear data structure much like a list. An exception can only ever bubble to just one caller before bubbling up to its one and only caller. But in our case it feels like the bubbles are splitting into multiple parallel \"streams\".</p>\n<p dir=\"auto\">Instead, think of <code>fooStream</code> and <code>barStream</code> as independent function <strong>calls</strong> that both require the value of <code>upStream</code>, except by magic of FRP <code>upStream</code> is only executed once and its value (well, its exception in this case) is shared with both <code>fooStream</code> and <code>barStream</code> calls. If you call a broken function twice, you get two exceptions (identical ones, thanks to FRP) and thus two call stacks to propagate through.</p>\n<p dir=\"auto\">To be extra clear, if we add <code>.recoverIgnoreErrors</code> to the <code>fooStream</code> definition above, its observer will not receive the error coming from <code>upStream</code>, and will not report that error as <em>unhandled</em>. We did, after all, handle it, so that's fair. However, <code>barStream</code>'s observer would still receive that same error, and would still report it as <em>unhandled</em>. This is why handling errors in the right place is very important, just like handling exceptions is in plain Scala code.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Recovering from Errors</h4><a id=\"user-content-recovering-from-errors\" class=\"anchor\" aria-label=\"Permalink: Recovering from Errors\" href=\"#recovering-from-errors\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">As we mentioned, generally observables propagate the errors they receive with no change. However, we can recover from errors, like this:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"val signal0: Signal[A] = ???\nval signal1 = signal0.map(whatever)\nval signal2 = signal1.recover {\n  case MyException(foo) if foo.isGood =&gt; Some(foo) // emit foo\n  case MyException(foo) if !foo.isGood =&gt; None // skip this, emit nothing\n  case o: MyOtherException =&gt; throw new Exception(&quot;lolwat&quot;) // emit new error\n}\"><pre><span class=\"pl-k\">val</span> <span class=\"pl-v\">signal0</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Signal</span>[<span class=\"pl-en\">A</span>] <span class=\"pl-k\">=</span> <span class=\"pl-k\">???</span>\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">signal1</span> <span class=\"pl-k\">=</span> signal0.map(whatever)\n<span class=\"pl-k\">val</span> <span class=\"pl-v\">signal2</span> <span class=\"pl-k\">=</span> signal1.recover {\n  <span class=\"pl-k\">case</span> <span class=\"pl-en\">MyException</span>(foo) <span class=\"pl-k\">if</span> foo.isGood <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">Some</span>(foo) <span class=\"pl-c\"><span class=\"pl-c\">//</span> emit foo</span>\n  <span class=\"pl-k\">case</span> <span class=\"pl-en\">MyException</span>(foo) <span class=\"pl-k\">if</span> <span class=\"pl-k\">!</span>foo.isGood <span class=\"pl-k\">=&gt;</span> <span class=\"pl-en\">None</span> <span class=\"pl-c\"><span class=\"pl-c\">//</span> skip this, emit nothing</span>\n  <span class=\"pl-k\">case</span> <span class=\"pl-v\">o</span>: <span class=\"pl-en\">MyOtherException</span> <span class=\"pl-k\">=&gt;</span> <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-en\">Exception</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>lolwat<span class=\"pl-pds\">\"</span></span>) <span class=\"pl-c\"><span class=\"pl-c\">//</span> emit new error</span>\n}</pre></div>\n<p dir=\"auto\">Importantly, this <code>recover</code> method does not affect <code>signal0</code>, or even <code>signal1</code>. Like any other operator it's just creating a new observable (<code>signal2</code>), except this one has a defined error handling strategy, so it will process any errors that come through it.</p>\n<p dir=\"auto\">When <code>signal0</code> emits an error, <code>signal2</code> will feed it to the partial function we provided to it. That function should normally emit either <code>Some(value)</code> to make <code>signal2</code> emit some <code>value</code>, or <code>None</code> to just skip this event altogether, as if it never happened. Yes, this latter case means that <code>signal2</code>'s current state would remain at whatever it was before this error came in, meanwhile <code>signal0</code>'s current state would be updated to the error (same for <code>signal1</code>).</p>\n<p dir=\"auto\">Any errors that this partial function is not defined for will pass through without being handled. If the partial function throws an error, it will be passed down wrapped in <code>ErrorHandlingError</code>.</p>\n<p dir=\"auto\">In addition to <code>recover</code>, Observables have a couple shorthand operators:</p>\n<p dir=\"auto\"><strong><code>recoverIgnoreErrors</code></strong> just skips all errors, emitting only good values. This is an FRP equivalent of an empty catch block.</p>\n<p dir=\"auto\">Note that you can't ignore an error in a <code>Signal</code>'s initial value, as it <em>needs</em> a <code>Try[A]</code> value to be its state whenever it's started. Therefore, if the initial value is an error, and <code>recover</code> returns <code>None</code> while handling it (that's what <code>recoverIgnoreErrors</code> does), the initial value is set to the original error.</p>\n<p dir=\"auto\"><strong><code>recoverToTry</code></strong> transforms an <code>Observable[A]</code> into an <code>Observable[Try[A]]</code> that never emits an error (it emits <code>Failure(err)</code> as a value instead).</p>\n<p dir=\"auto\">You can use it to get a stream of errors as plain values, for example:</p>\n<div class=\"highlight highlight-source-scala notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"stream.recoverToTry.collect { case Failure(err) =&gt; err } // EventStream[Throwable]\"><pre>stream.recoverToTry.collect { <span class=\"pl-k\">case</span> <span class=\"pl-en\">Failure</span>(err) <span class=\"pl-k\">=&gt;</span> err } <span class=\"pl-c\"><span class=\"pl-c\">//</span> EventStream[Throwable]</span></pre></div>\n<p dir=\"auto\"><strong><code>throwFailure</code></strong> lets you \"un-recover\" errors, i.e. it converts an observable of <code>Try[A]</code> into an observable of <code>A</code>, throwing the failure case into the error channel.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Handling Errors Using Observers</h4><a id=\"user-content-handling-errors-using-observers\" class=\"anchor\" aria-label=\"Permalink: Handling Errors Using Observers\" href=\"#handling-errors-using-observers\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\"><strong><code>Observer.fromTry(nextTry =&gt; ...)</code></strong> and <strong><code>Observer.withRecover(onNext, onError: PartialFunction[Throwable, Unit])</code></strong> let you handle all or some of the errors coming from upstream observables. Errors for which <code>onError</code> is not defined get reported as unhandled.</p>\n<p dir=\"auto\"><strong><code>Observer.ignoreErrors(onNext)</code></strong> is similar to <code>recoverIgnoreErrors</code> on observables – it simply silences any error it receives, so that it does not get reported as unhandled.</p>\n<p dir=\"auto\">Observers that are derived from other observers, e.g. <code>observer.contramap[Int](...)</code>, pass the error to the original observer, and so maintain the original observer's error handling behaviour.</p>\n<p dir=\"auto\">Airstream-provided Observer constructors that let you specify an error handling callback (e.g. <code>Observer.fromTry</code> and <code>Observer.withRecover</code>) also have a <code>handleObserverErrors</code> param. When this param is true (that's the default), if the observer's callback throws while processing an incoming event, the same observer's <strong>error</strong> callback (the onError method) gets called with the error wrapped in ObserverError. This lets you automatically propagate unexpected exceptions up the chain of observers instead of sending the error into unhandled right away. For more details, see <a href=\"#errors-can-become-wrapped\">Errors Can Become Wrapped</a> above.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Other Error Handling Considerations</h4><a id=\"user-content-other-error-handling-considerations\" class=\"anchor\" aria-label=\"Permalink: Other Error Handling Considerations\" href=\"#other-error-handling-considerations\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\"><strong><code>scanLeft</code></strong> operator is unable to proceed when encountering an error, so such an observable will enter a permanent error state if it encounters an error. You can not use the standard <code>recover</code> method to recover from this. You need to use <code>scanLeftRecover</code> instead of <code>scanLeft</code> to supply your error handling logic.</p>\n</li>\n<li>\n<p dir=\"auto\"><strong><code>filter</code></strong> operator can't filter if its passes function fails, so it will pass through all errors that it receives, unfiltered. You can filter errors using <code>recover</code>, by returning <code>None</code>.</p>\n</li>\n<li>\n<p dir=\"auto\">Remember that Signal's initial value is not evaluated until and unless it is needed. That is true even if the initial value would have been an error because obviously you can't know what it is without evaluating it. And if an error is not evaluated, then it can't possibly be reported anywhere because, well, it didn't actually happen. In practice this means that the initial value of a Signal whose only consumer is its <code>.changes</code> stream is completely ignored (because no one cares about it). @TODO[API] Should we reconsider this particular aspect of laziness? Either way, we should document the rationale for that some more.</p>\n</li>\n</ul>\n<div class=\"markdown-heading\" dir=\"auto\"><h2 class=\"heading-element\" dir=\"auto\">Limitations</h2><a id=\"user-content-limitations\" class=\"anchor\" aria-label=\"Permalink: Limitations\" href=\"#limitations\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<ul dir=\"auto\">\n<li>Airstream only runs on Scala.js because its primary intended use case is unidirectional dataflow architecture on the frontend. I have no plans to make it run on the JVM. It would require too much of my time and too much compromise, complicating the API to support a completely different environment and use cases.</li>\n<li>Airstream has no concept of observables \"completing\". Personally I don't think this is much of a limitation, but I can see it being viewed as such. See <a href=\"https://github.com/raquo/Airstream/issues/23\" data-hovercard-type=\"issue\" data-hovercard-url=\"/raquo/Airstream/issues/23/hovercard\">Issue #23</a>.</li>\n</ul>\n<div class=\"markdown-heading\" dir=\"auto\"><h2 class=\"heading-element\" dir=\"auto\">My Related Projects</h2><a id=\"user-content-my-related-projects\" class=\"anchor\" aria-label=\"Permalink: My Related Projects\" href=\"#my-related-projects\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<ul dir=\"auto\">\n<li><a href=\"https://laminar.dev\" rel=\"nofollow\">Laminar</a> – Efficient reactive UI library for Scala.js that uses Airstream</li>\n<li><a href=\"https://github.com/raquo/Waypoint\">Waypoint</a> – Efficient router for Laminar made with Airstream</li>\n<li><a href=\"https://github.com/raquo/XStream.scala\">XStream.scala</a> – streaming library used by Laminar before Airstream</li>\n</ul>\n<p dir=\"auto\">Other building blocks of Laminar:</p>\n<ul dir=\"auto\">\n<li><a href=\"https://github.com/raquo/scala-dom-types\">Scala DOM Types</a> – Type definitions that we use for all the HTML tags, attributes, properties, and styles</li>\n<li><a href=\"https://github.com/raquo/scala-dom-testutils\">Scala DOM TestUtils</a> – Test that your Javascript DOM nodes match your expectations</li>\n</ul>\n<div class=\"markdown-heading\" dir=\"auto\"><h2 class=\"heading-element\" dir=\"auto\">Author</h2><a id=\"user-content-author\" class=\"anchor\" aria-label=\"Permalink: Author\" href=\"#author\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Nikita Gazarov – <a href=\"https://twitter.com/raquo\" rel=\"nofollow\">@raquo</a></p>\n<p dir=\"auto\">Please <a href=\"https://github.com/sponsors/raquo\">support Airstream development</a> if you use it commercially.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h2 class=\"heading-element\" dir=\"auto\">License</h2><a id=\"user-content-license\" class=\"anchor\" aria-label=\"Permalink: License\" href=\"#license\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Airstream is provided under the <a href=\"https://github.com/raquo/Airstream/blob/master/LICENSE.md\">MIT license</a>.</p>\n</article></div>",
    "contributors" : [
      {
        "login" : "raquo",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/532656?v=4",
        "url" : "https://github.com/raquo",
        "contributions" : 432
      },
      {
        "login" : "ngbinh",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/211327?v=4",
        "url" : "https://github.com/ngbinh",
        "contributions" : 2
      },
      {
        "login" : "yurique",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/919230?v=4",
        "url" : "https://github.com/yurique",
        "contributions" : 2
      },
      {
        "login" : "ajaychandran",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/4387263?v=4",
        "url" : "https://github.com/ajaychandran",
        "contributions" : 1
      },
      {
        "login" : "ajablonski",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/2461496?v=4",
        "url" : "https://github.com/ajablonski",
        "contributions" : 1
      },
      {
        "login" : "armanbilge",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/3119428?v=4",
        "url" : "https://github.com/armanbilge",
        "contributions" : 1
      },
      {
        "login" : "jatcwang",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/4957161?v=4",
        "url" : "https://github.com/jatcwang",
        "contributions" : 1
      },
      {
        "login" : "pishen",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/156619?v=4",
        "url" : "https://github.com/pishen",
        "contributions" : 1
      },
      {
        "login" : "rgwilton",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/7872546?v=4",
        "url" : "https://github.com/rgwilton",
        "contributions" : 1
      },
      {
        "login" : "vic",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/331?v=4",
        "url" : "https://github.com/vic",
        "contributions" : 1
      },
      {
        "login" : "vdnhi",
        "avatarUrl" : "https://avatars.githubusercontent.com/u/9262617?v=4",
        "url" : "https://github.com/vdnhi",
        "contributions" : 1
      }
    ],
    "commits" : 444,
    "topics" : [
      "scalajs",
      "reactive-streams",
      "functional-reactive-programming",
      "scala",
      "scala-js",
      "state-management"
    ],
    "contributingGuide" : null,
    "codeOfConduct" : null,
    "openIssues" : [
      {
        "number" : 124,
        "title" : "StreamFromSignal with onlyChanges = False may filter out initial value",
        "url" : "https://github.com/raquo/Airstream/issues/124"
      },
      {
        "number" : 123,
        "title" : "`composeEither`: fixed-scope `flatten` without transcations",
        "url" : "https://github.com/raquo/Airstream/issues/123"
      },
      {
        "number" : 119,
        "title" : "Zooming into a Var should not require an Owner?",
        "url" : "https://github.com/raquo/Airstream/issues/119"
      },
      {
        "number" : 112,
        "title" : "Vars should be splittable",
        "url" : "https://github.com/raquo/Airstream/issues/112"
      },
      {
        "number" : 103,
        "title" : "splitByType / splitByEnum",
        "url" : "https://github.com/raquo/Airstream/issues/103"
      },
      {
        "number" : 102,
        "title" : "Killing subscriptions from observers (?)",
        "url" : "https://github.com/raquo/Airstream/issues/102"
      },
      {
        "number" : 101,
        "title" : ".split operator is hard to use without Laminar",
        "url" : "https://github.com/raquo/Airstream/issues/101"
      },
      {
        "number" : 78,
        "title" : "Add EventStream.mapError",
        "url" : "https://github.com/raquo/Airstream/issues/78"
      },
      {
        "number" : 70,
        "title" : "Consider keep-alive mechanisms to extend ownership duration",
        "url" : "https://github.com/raquo/Airstream/issues/70"
      },
      {
        "number" : 59,
        "title" : "How should error handlers treat Fatal errors?",
        "url" : "https://github.com/raquo/Airstream/issues/59"
      },
      {
        "number" : 50,
        "title" : "Add spacedWith combinator",
        "url" : "https://github.com/raquo/Airstream/issues/50"
      },
      {
        "number" : 49,
        "title" : "Add HTTP/websocket event sources",
        "url" : "https://github.com/raquo/Airstream/issues/49"
      },
      {
        "number" : 23,
        "title" : "Investigate Observable Completion",
        "url" : "https://github.com/raquo/Airstream/issues/23"
      },
      {
        "number" : 17,
        "title" : "Docs: Version documentation similar to Laminar",
        "url" : "https://github.com/raquo/Airstream/issues/17"
      },
      {
        "number" : 16,
        "title" : "Test: Verify Signal's initialValue laziness",
        "url" : "https://github.com/raquo/Airstream/issues/16"
      },
      {
        "number" : 1,
        "title" : "Concatenation of EventStreams",
        "url" : "https://github.com/raquo/Airstream/issues/1"
      }
    ],
    "scalaPercentage" : 100,
    "license" : "MIT",
    "commitActivity" : [
      {
        "total" : 0,
        "week" : 1692489600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1693094400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1693699200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1694304000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1694908800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1695513600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1696118400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1696723200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1697328000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1697932800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1698537600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1699142400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1699747200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 9,
        "week" : 1700352000000,
        "days" : [
          0,
          0,
          2,
          1,
          1,
          0,
          5
        ]
      },
      {
        "total" : 8,
        "week" : 1700956800000,
        "days" : [
          0,
          0,
          1,
          4,
          3,
          0,
          0
        ]
      },
      {
        "total" : 5,
        "week" : 1701561600000,
        "days" : [
          2,
          2,
          1,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1702166400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1702771200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1703376000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1703980800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 1,
        "week" : 1704585600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ]
      },
      {
        "total" : 3,
        "week" : 1705190400000,
        "days" : [
          2,
          0,
          1,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1705795200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1706400000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1707004800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1707609600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 1,
        "week" : 1708214400000,
        "days" : [
          0,
          0,
          1,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 7,
        "week" : 1708819200000,
        "days" : [
          4,
          1,
          2,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1709424000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 1,
        "week" : 1710028800000,
        "days" : [
          0,
          0,
          1,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1710633600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1711238400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1711843200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1712448000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1713052800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1713657600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1714262400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 3,
        "week" : 1714867200000,
        "days" : [
          0,
          0,
          2,
          1,
          0,
          0,
          0
        ]
      },
      {
        "total" : 2,
        "week" : 1715472000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          2,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1716076800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1716681600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1717286400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1717891200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1718496000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 2,
        "week" : 1719100800000,
        "days" : [
          0,
          0,
          0,
          0,
          2,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1719705600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 2,
        "week" : 1720310400000,
        "days" : [
          0,
          0,
          0,
          1,
          1,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1720915200000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1721520000000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1722124800000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1722729600000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "total" : 0,
        "week" : 1723334400000,
        "days" : [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      }
    ]
  },
  "settings" : {
    "preferStableVersion" : true,
    "defaultArtifact" : null,
    "customScalaDoc" : null,
    "documentationLinks" : [
    ],
    "contributorsWanted" : false,
    "deprecatedArtifacts" : [
    ],
    "cliArtifacts" : [
    ],
    "category" : "asynchronous-and-reactive-programming",
    "chatroom" : null
  }
}